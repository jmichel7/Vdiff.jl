Interrupt List		Release 36á			Last change 8/1/93
This compilation is Copyright (c) 1989,1990,1991,1992,1993 Ralf Brown
--------!---FILELIST-------------------------
Please redistribute the following files unmodified as a group, in a trio of
archives named INTER36A through INTER36C (preferably the original authenticated
PKZIP archives):
	INTERRUP.1ST	the read-me file, containing credits, availability info
	INTERRUP.A	INT 00 through INT 14	 \
	INTERRUP.B	INT 15 through INT 15	  \
	INTERRUP.C	INT 16 through INT 21/41   \   total 1302 pages at
	INTERRUP.D	INT 21/42 through INT 21/7F \  60 lines per page,
	INTERRUP.E	INT 21/80 through INT 21/FF  \ 1394 with INTPRINT -p
	INTERRUP.F	INT 22 through INT 2F/7F     / (5573 entries)
	INTERRUP.G	INT 2F/80 through INT 2F/FF /
	INTERRUP.H	INT 30 through INT 5F	   /
	INTERRUP.I	INT 60 through INT 67	  /
	INTERRUP.J	INT 68 through INT FF	 /
	INTERRUP.PRI	a brief introduction to interrupts
	INTPRINT.COM	a simple formatter that also generates a list summary
	INTPRINT.DOC	instructions for INTPRINT
	86BUGS.LST	a listing of CPU bugs and undocumented features
	CMOS.LST	a description of the CMOS RAM data bytes
	GLOSSARY.LST	a glossary of terms, abbreviations, and acronyms
	MEMORY.LST	format of the BIOS data area
	PORTS.LST	a listing of I/O ports
	COMBINE.BAT	combine the pieces of the list into a single file
The following files should be distributed in an archive called INTER36D:
	INT.COM		invoke interrupts from commandline
	INT2GUID.*	convert list into TurboPower GUIDE or POPHELP database
	INT2HLP.BAT	Perl script to convert list into QuickHelp database
	INT2QH.*	program to convert list into QuickHelp database
	INTERVUE.EXE	indexed interrupt list browser
	INTHELP.*	convert list into TurboPower GUIDE database
	INTLIST.E	Epsilon extension for handling list
	INTLIST.ICO	Windows icon for INTERVUE
	INTPRINT.C	source code for INTPRINT
	RB2NG.*		convert list into Norton Guides database
--------!---CONTACT_INFO---------------------
If you notice any mistakes or omissions, please let me know!  It is only with
YOUR help that the list can continue to grow at the current rate.  Please send
all changes to me rather than distributing a modified version of the list.

Please read the file INTERRUP.1ST before asking me any questions.  You may find
that they have already been addressed.

	 Ralf Brown

Internet: ralf@telerama.pgh.pa.us
UUCP: {uunet,harvard}!telerama.pgh.pa.us!ralf
FIDO: Ralf Brown 1:129/26.1
	or post a message to me in the DR_DEBUG echo (I probably won't see it
	unless you address it to me)
CIS:  >INTERNET:ralf@telerama.pgh.pa.us

I reply to all e-mail submissions and inquiries, but some of my replies bounce
because of bad return paths.  If you don't get a response from me within a
reasonable period of time, send it again with a better return path (starting at
harvard or ucbvax for UUCP, from the ARPA Internet for others).
--------!------------------------------------
See INTERRUP.1ST for the key to system abbreviations and a list of the
trademarks mentioned here.
--------!---DISCLAIMER-----------------------
DISCLAIMER:  THIS MATERIAL IS PROVIDED "AS IS".	 I verify the information
contained in this list to the best of my ability, but I cannot be held
responsible for any problems caused by use or misuse of the information,
especially for those functions not officially  documented.  If it is marked
"internal" or undocumented, you should check it carefully to make sure it
works the same way in your version of the software (and please let me know
whether or not it works the same way).	Information marked with "???" is
known to be incomplete or guesswork.
--------!---FLAGS----------------------------
The use of -> instead of = signifies that the indicated register or register
pair contains a pointer to the specified item, rather than the item itself.
One or more letters may follow the interrupt number; they have the following
meanings:  U - undocumented function, u - partially documented function,
P - available only in protected mode, R - available only in real or V86 mode,
C - callout or callback (usually hooked rather than called),
O - obsolete (no longer present in current versions)
--------!---CATEGORIES-----------------------
The ninth column of the divider line preceding an entry usually contains a
classification code (the entry has not been classified if that character is
a dash).  The codes currently in use are:
	A - applications, a - access software (screen readers, etc),
	B - BIOS, b - vendor-specific BIOS extensions,
	C - CPU-generated, c - caches/spoolers,
	D - DOS kernel, d - disk I/O enhancements,
	E - DOS extenders, e - electronic mail, F - FAX,
	f - file manipulation, G - debuggers/debugging tools,
	H - hardware, h - vendor-specific hardware,
	I - IBM workstation/terminal emulators,
	J - Japanese, j - joke programs,
	K - keyboard enhancers, k - file compression,
	l - shells/command interpreters,
	M - mouse/pointing device, m - memory management,
	N - network, O - other operating systems,
	P - printer enhancements, p - power management,
	Q - DESQview/TopView and Quarterdeck programs,
	R - remote control/file access, r - runtime support,
	S - serial I/O, s - sound/speech,
	T - DOS-based task switchers/multitaskers, t - TSR libraries
	U - resident utilities, u - emulators,
	V - video, v - virus/antivirus,
	W - MS Windows, X - expansion bus BIOSes,
	y - security, * - reserved (& not otherwise classified)
--------C-00---------------------------------
INT 00 - CPU-generated - DIVIDE ERROR
Desc:	generated if the divisor of a DIV or IDIV instruction is zero or the
	  quotient overflows the result register; DX and AX will be unchanged.
Notes:	on an 8086/8088, the return address points to the following instruction
	on an 80286+, the return address points to the divide instruction
	an 8086/8088 will generate this interrupt if the result of a division
	  is 80h (byte) or 8000h (word)
SeeAlso: INT 04
--------G-00---------------------------------
INT 00 - Zenith - ROM DEBUGGER
Desc:	invokes the ROM Debugger when at the BIOS level; equivalent to
	  pressing Ctrl-Alt-Ins on booting.
Note:	since DOS revectors INT 00, it is necessary to restore this vector to
	  its original ROM BIOS value in order to invoke the debugger once DOS
	  loads
SeeAlso: INT 03"Columbia"
--------C-01---------------------------------
INT 01 - CPU-generated - SINGLE STEP
Desc:	generated after each instruction if TF (trap flag) is set; TF is
	  cleared on invoking the single-step interrupt handler
Notes:	interrupts are prioritized such that external interrupts are invoked
	  after the INT 01 pushes CS:IP/FLAGS and clears TF, but before the
	  first instruction of the handler executes
	used by debuggers for single-instruction execution tracing, such as
	  MS-DOS DEBUG's T command
SeeAlso: INT 03
--------C-01---------------------------------
INT 01 - CPU-generated (80386+) - DEBUGGING EXCEPTIONS
Desc:	generated by the CPU on various occurrences which may be of interest
	  to a debugger program
Note:	events which may trigger the interrupt:
	  Instruction address breakpoint fault - will return to execute inst
	  Data address breakpoint trap - will return to following instruction
	  General detect fault, debug registers in use
	  Task-switch breakpoint trap
	  undocumented 386/486 opcode F1h - will return to following instruc
SeeAlso: INT 03
--------H-02---------------------------------
INT 02 - external hardware - NON-MASKABLE INTERRUPT
Desc:	generated by the CPU when the input to the NMI pin is asserted
Notes:	return address points to start of interrupted instruction on 80286+
	on the 80286+, further NMIs are disabled until the next IRET
	  instruction, but one additional NMI is remembered by the hardware
	  and will be serviced after the IRET instruction reenables NMIs
	maskable interrupts may interrupt the NMI handler if interrupts are
	  enabled
	although the Intel documentation states that this interrupt is
	  typically used for power-failure procedures, it has many other uses
	  on IBM-compatible machines:
		Memory parity error: all except Jr, CONV, and some machines
				without memory parity
		Breakout switch on hardware debuggers
		Coprocessor interrupt: all except Jr and CONV
		Keyboard interrupt: Jr, CONV
		I/O channel check: CONV, PS50+
		Disk-controller power-on request: CONV
		System suspend: CONV
		Real-time clock: CONV
		System watch-dog timer, time-out interrupt: PS50+
		DMA timer time-out interrupt: PS50+
		Low battery: HP 95LX
		Module pulled: HP 95LX
--------C-03---------------------------------
INT 03 - CPU-generated - BREAKPOINT
Desc:	generated by the one-byte breakpoint instruction (opcode CCh)
Notes:	used by debuggers to implement breakpoints, such as MS-DOS DEBUG's G
	  command
	also used by Turbo Pascal versions 1,2,3 when {$U+} specified
	return address points to byte following the breakpoint instruction
SeeAlso: INT 01
--------G-03---------------------------------
INT 03 - Columbia PCs (desktop,VP portables) - ROM DEBUGGER
Desc:	invokes the ROM Debugger if INT 03 has not been revectored; equivalent
	  to pressing Esc on booting.
SeeAlso: INT 00"Zenith"
--------G-030910-----------------------------
INT 03 - Soft-ICE - BACK DOOR COMMANDS - DISPLAY STRING IN Soft-ICE WINDOW
	AX = 0910h
	SI = magic value 4647h ('FG')
	DI = magic value 4A4Dh ('JM')
	DS:DX -> ASCIZ string to display (max 100 bytes, 0Dh OK)
Program: Soft-ICE is a debugger by Nu-Mega Technologies, Inc.
--------G-030911-----------------------------
INT 03 - Soft-ICE - BACK DOOR COMMANDS - EXECUTE Soft-ICE COMMAND
	AX = 0911h
	SI = magic value 4647h ('FG')
	DI = magic value 4A4Dh ('JM')
	DS:DX -> ASCIZ command string (max 100 bytes, 0Dh OK)
--------G-030912-----------------------------
INT 03 - Soft-ICE - BACK DOOR COMMANDS - GET BREAKPOINT INFORMATION
	AX = 0912h
	SI = magic value 4647h ('FG')
	DI = magic value 4A4Dh ('JM')
Return: BH = entry number of last breakpoint set
	BL = type of last breakpoint set
	    00h BPM (breakpoint register types)
	    01h I/O
	    02h INTerrupt
	    03h BPX (INT 03h-style breakpoint)
	    04h reserved
	    05h range
	DH = entry number of last breakpoint to be triggered
	DL = type of last triggered breakpoint (see above)
Program: Soft-ICE is a debugger by Nu-Mega Technologies, Inc.
SeeAlso: AX=0913h,AX=0914h
--------G-030913-----------------------------
INT 03 - Soft-ICE v2.5x - BACK DOOR COMMANDS - SET Soft-ICE BREAKPOINT
	AX = 0913h
	SI = magic value 4647h ('FG')
	DI = magic value 4A4Dh ('JM')
	DS:DX -> breakpoint structure (see below)
Return: AX = status
	    00h successful
		BX = breakpoint number
	    03h breakpoint table full
	    06h memory limit error
	    07h I/O limit error
	    09h range limit error
	    16h duplicate breakpoint
SeeAlso: AX=0312h,AX=0314h

Format of breakpoint structure:
Offset	Size	Description
 00h	BYTE	breakpoint type (see below)
 01h	DWORD	breakpoint address 1
		(lower range limit for memory BPs, interrupt # for interrupt
		BPs, address of BP for execution BPs, I/O address (only word)
		for I/O BPs)
 05h	DWORD	breakpoint address 2
		(upper range limit for memory BPs,
		optional value to check for for interrupt BPs,
		overlay number (0 = root) for execution BPs)
 09h	DWORD	breakpoint address 3
 0Dh	BYTE	breakpoint mode 1 (see below)
		(for interrupt BPs = register to check
		     00h  no value checking
		     01h  check AL
		     02h  check AH
		     03h  check AX)
 0Eh	BYTE	breakpoint mode 2 (see below)
 0Fh	BYTE	breakpoint size (00h byte, 01h word, 03h dword)
 10h	BYTE	breakpoint pass count before program stop
 11h	BYTE	breakpoint state
Note:	all unused fields should contain zeros

Values for breakpoint type:
 00h	memory location
 01h	memory range
 03h	I/O
 04h	interrupt
 05h	execution break

Values for breakpoint mode:
 01h	read
 02h	write
 04h	execution
--------G-030914-----------------------------
INT 03 - Soft-ICE v2.5x - BACK DOOR COMMANDS - REMOVE Soft-ICE BREAKPOINT
	AX = 0914h
	SI = magic value 4647h ('FG')
	DI = magic value 4A4Dh ('JM')
	BX = breakpoint number (returned by AX=0913h)
Return: BX = ???
Program: Soft-ICE is a debugger by Nu-Mega Technologies, Inc.
SeeAlso: AX=0912h,AX=0913h
--------C-04---------------------------------
INT 04 - CPU-generated - INTO DETECTED OVERFLOW
Desc:	the INTO instruction will generate this interrupt if OF (Overflow Flag)
	  is set; otherwise, INTO is effectively a NOP
Note:	may be used for convenient overflow testing (to prevent errors from
	  propagating) instead of JO or a JNO/JMP combination
SeeAlso: INT 00
--------B-05---------------------------------
INT 05 - PRINT SCREEN
Desc:	dump the current text screen to the first printer
Notes:	normally invoked by the INT 09 handler when PrtSc key is pressed, but
	  may be invoked directly by applications
	byte at 0050h:0000h contains status used by default handler
	  00h not active
	  01h PrtSc in progress
	  FFh last PrtSc encountered error
	default handler is at F000h:FF54h in IBM PC and 100%-compatible BIOSes
SeeAlso: INT 10/AH=12h/BL=20h
--------C-05---------------------------------
INT 05 - CPU-generated (80186+) - BOUND RANGE EXCEEDED
Desc:	generated by BOUND instruction when the value to be tested is less than
	  the indicated lower bound or greater than the indicated upper bound.
Note:	returning from this interrupt re-executes the failing BOUND instruction
--------P-05454A-----------------------------
INT 05 U - PSPS v2.01 - EJECT PAGE
	AX = 454Ah ('EJ')
Program: PSPS is shareware PostScript PrintScreen utility by A.N.D.
	  Technologies
Note:	sends a ^D to the current printer
SeeAlso: AX=4E57h,AX=5053h,AX=554Eh
--------P-054E57-----------------------------
INT 05 U - PSPS v2.01 - SET PARAMETERS
	AX = 4E57h ('NW')
	ES:SI -> 11-byte buffer containing new settings
Return: buffer filled
SeeAlso: AX=454Ah,AX=5053h,INT 17/AH=63h
--------P-055053-----------------------------
INT 05 U - PSPS v2.01 - GET PARAMETERS
	AX = 5053h ('PS')
	ES:SI -> 11-byte buffer containing new settings
SeeAlso: AX=4E57h,AX=554Eh,INT 17/AH=64h
--------P-05554E-----------------------------
INT 05 U - PSPS v2.01 - UNINSTALL
	AX = 554Eh ('UN')
Program: PSPS is shareware PostScript PrintScreen utility by A.N.D.
	  Technologies
SeeAlso: AX=454Ah,AX=4E57h,INT 17/AH=62h
--------C-06---------------------------------
INT 06 - CPU-generated (80286+) - INVALID OPCODE
Desc:	this interrupt is generated when the CPU attempts to execute an
	  invalid opcode (most protected-mode instructions are considered
	  invalid in real mode) or a BOUND, LDS, LES, or LIDT instruction
	  which specifies a register rather than a memory address
Notes:	return address points to beginning of invalid instruction
	with proper programming, this interrupt may be used to emulate
	  instructions which do not exist; many 386 BIOSes emulate the 80286
	  undocumented LOADALL instruction which was removed from the 80386+
	generated by the 80386+ when the LOCK prefix is used with instructions
	  other than BTS, BTR, BTC, XCHG, XADD (486), CMPXCHG (486), INC, DEC,
	  NOT, NEG, ADD, ADC, SUB, SBB, AND, OR, or XOR, or any instruction
	  not accessing memory.
SeeAlso: INT 0C"CPU",INT 0D"CPU"
--------b-06---------------------------------
INT 06 C - HP 95LX - SLEEP/WAKEUP
Desc:	this interrupt is called just before going into light or deep
	  (shutdown) sleep and just after returning from light or deep sleep
SeeAlso: INT 0B"HP 95LX",INT 15/AX=4DD4h,INT 15/AH=4Eh
--------C-07---------------------------------
INT 07 - CPU-generated (80286+) - PROCESSOR EXTENSION NOT AVAILABLE
Desc:	this interrupt is automatically called if a coprocessor instruction is
	  encountered when no coprocessor is installed
Note:	can be used to emulate a numeric coprocessor in software
SeeAlso: INT 09"MATH UNIT PROTECTION"
--------H-08---------------------------------
INT 08 - IRQ0 - SYSTEM TIMER
Desc:	generated 18.2 times per second by channel 0 of the 8254 system timer,
	  this interrupt is used to keep the time-of-day clock updated
Notes:	programs which need to be invoked regularly should use INT 1C unless
	  they need to reprogram the timer while still keeping the time-of-day
	  clock running at the proper rate
	default handler is at F000h:FEA5h in IBM PC and 100%-compatible BIOSes
	may be masked by setting bit 0 on I/O port 21h
SeeAlso: INT 1C,INT 4A,INT 50"DESQview",INT 58"DoubleDOS",INT 70,INT 78"GO32"
SeeAlso: INT D8"Screen Thief"
--------C-08---------------------------------
INT 08 - CPU-generated (80286+) - DOUBLE EXCEPTION DETECTED
Desc:	called when multiple exceptions occur on one instruction, or an
	  exception occurs in an exception handler
Notes:	called in protected mode if an interrupt above the defined limit of
	  the interrupt vector table occurs
	return address points at beginning of instruction with errors or the
	  beginning of the instruction which was about to execute when the
	  external interrupt caused the exception
	if an exception occurs in the double fault handler, the CPU goes into
	  SHUTDOWN mode (which circuitry in the PC/AT converts to a reset);
	  this "triple fault" is a faster way of returning to real mode on
	  many 80286 machines than the standard keyboard controller reset
--------H-09---------------------------------
INT 09 - IRQ1 - KEYBOARD DATA READY
Desc:	this interrupt is generated when data is received from the keyboard.
	  This is normally a scan code (from either a keypress *or* a key
	  release), but may also be an ACK or NAK of a command on AT-class
	  keyboards.
Notes:	this IRQ may be masked by setting bit 1 on I/O port 21h
	if the BIOS supports an enhanced (101/102-key) keyboard, it calls
	  INT 15/AH=4Fh after reading the scan code from the keyboard and
	  before further processing; all further processing uses the scan
	  code returned from INT 15/AH=4Fh
	the default interrupt handler is at F000h:E987h in 100%-compatible
	  BIOSes
	the interrupt handler performs the following actions for certain
	  special keystrokes:
	    Ctrl-Break	 clear keyboard buffer, place word 0000h in buffer,
			 invoke INT 1B, and set flag at 0040h:0071h
	    SysRq	 invoke INT 15/AH=85h
	    Ctrl-Numlock place system in a tight wait loop until next INT 09
	    Ctrl-Alt-Del jump to BIOS startup code (either F000h:FFF0h or the
			   destination of the jump at that address)
	    Shift-PrtSc	 invoke INT 05
	DRDOS hooks this interrupt to control the cursor shape (underscore/
	  half block) for overwrite/insert mode
	DR Multiuser DOS hooks this interrupt for cursor shape control and to
	  control whether Ctrl-Alt-Del reboots the current session or the
	  entire system
SeeAlso: INT 05,INT 0B"HP 95LX",INT 15/AH=4Fh,INT 15/AH=85h,INT 16,INT 1B
SeeAlso: INT 2F/AX=A901h,INT 51"DESQview",INT 59"DoubleDOS",INT 79"GO32"

Values for scan code:
 01h	Esc		 31h	N
 02h	1 !		 32h	M
 03h	2 @		 33h	, <		 63h	F16
 04h	3 #		 34h	. >		 64h	F17
 05h	4 $		 35h	/ ?		 65h	F18
 06h	5 %		 36h	Right Shift	 66h	F19
 07h	6 ^		 37h	Grey*		 67h	F20
 08h	7 &		 38h	Alt		 68h	F21
 09h	8 *		 39h	SpaceBar	 69h	F22
 0Ah	9 (		 3Ah	CapsLock	 6Ah	F23
 0Bh	0 )		 3Bh	F1		 6Bh	F24
 0Ch	- _		 3Ch	F2		 6Ch	--
 0Dh	= +		 3Dh	F3		 6Dh	EraseEOF
 0Eh	Backspace	 3Eh	F4
 0Fh	Tab		 3Fh	F5		 6Fh	Copy/Play
 10h	Q		 40h	F6
 11h	W		 41h	F7
 12h	E		 42h	F8		 72h	CrSel
 13h	R		 43h	F9
 14h	T		 44h	F10		 74h	ExSel
 15h	Y		 45h	NumLock		 75h	--
 16h	U		 46h	ScrollLock	 76h	Clear
 17h	I		 47h	Home
 18h	O		 48h	UpArrow
 19h	P		 49h	PgUp
 1Ah	[ {		 4Ah	Grey-
 1Bh	] }		 4Bh	LeftArrow
 1Ch	Enter		 4Ch	Keypad 5
 1Dh	Ctrl		 4Dh	RightArrow
 1Eh	A		 4Eh	Grey+
 1Fh	S		 4Fh	End
 20h	D		 50h	DownArrow	 E0h	prefix code
 21h	F		 51h	PgDn		 E1h	prefix code
 22h	G		 52h	Ins		 FAh	ACK
 23h	H		 53h	Del		 FEh	RESEND
 24h	J		 54h	SysRq		 FFh	kbd error/buffer full
 25h	K
 26h	L		 56h	left \| (102-key)
 27h	; :		 57h	F11
 28h	' "		 58h	F12
 29h	` ~
 2Ah	Left Shift	 5Ah	PA1
 2Bh	\ |		 5Bh	F13
 2Ch	Z		 5Ch	F14
 2Dh	X		 5Dh	F15
 2Eh	C
 2Fh	V
 30h	B
Note:	scan codes 56h-E1h are only available on the extended (101/102-key)
	  keyboard and Host Connected (122-key) keyboard; scan codes 5Ah-76h
	  are only available on the 122-key keyboard
--------C-09---------------------------------
INT 09 - CPU-generated (80286,80386) - PROCESSOR EXTENSION PROTECTION ERROR
Desc:	called if the coprocessor attempts to access memory outside a segment
	  boundary; it may occur at an arbitrary time after the coprocessor
	  instruction was issued
Note:	until the condition is cleared or the coprocessor is reset, the only
	  coprocessor instruction which may be used is FNINIT; WAIT or other
	  coprocessor instructions will cause a deadlock because the
	  coprocessor is still busy waiting for data
SeeAlso: INT 07"CPU"
--------*-09---------------------------------
INT 09 P - internal hardware - RESERVED BY Intel (80486)
Note:	this exception has been moved to INT 0D
SeeAlso: INT 09"MATH",INT 0D
--------H-0A---------------------------------
INT 0A - IRQ2 - LPT2 (PC), VERTICAL RETRACE INTERRUPT (EGA,VGA)
Notes:	the TOPS and PCnet adapters use this interrupt request line by default
	DOS 3.2 revectors IRQ2 to a stack-switching routine
	on ATs and above, the physical data line for IRQ2 is labeled IRQ9 and
	  connects to the slave 8259.  The BIOS redirects the interrupt for
	  IRQ9 back here.
	under DESQview, only the INT 15h vector and BASIC segment address (the
	  word at 0000h:0510h) may be assumed to be valid for the handler's
	  process
	many VGA boards do not implement the vertical retrace interrupt,
	  including the IBM VGA Adapter where the traces are either cut or
	  removed
SeeAlso: INT 52"DESQview",INT 5A"DoubleDOS",INT 71,INT 7A"GO32"
--------H-0A---------------------------------
INT 0A - IRQ2 - Tandy 1000-series HARD DISK
Note:	may be masked by setting bit 2 on I/O port 21h
SeeAlso: INT 52"DESQview",INT 5A"DoubleDOS",INT 71
--------H-0A---------------------------------
INT 0A - IRQ2 - ROLAND MPU MIDI INTERFACE
Note:	newer Roland cards and MIDI interfaces by other manufacturers use
	  a jumper-selectable IRQ, but software and hardware generally defaults
	  to IRQ2
SeeAlso: INT 52"DESQview",INT 5A"DoubleDOS",INT 71,INT 7A"GO32"
--------C-0A---------------------------------
INT 0A P - CPU-generated (80286+) - INVALID TASK STATE SEGMENT
Desc:	automatically called during a task switch if the new TSS specified by
	  the task gate is invalid for any of the following reasons:
		TSS limit is less than 43 (80286) or 103 (80386/80486)
		LDT selector invalid or segment not present
		null SS selector, or SS selector outside LDT/GDT limit
		stack segment is read-only
		stack segment DPL differs from new CPL, or RPL <> CPL
		CS selector is outside LDT/GDT limit or not code
		non-conforming code segment's DPL differs from CPL
		conforming code segment's DPL > CPL
		DS/ES selectors outside LDT/GDT limit or not readable segments
Note:	the handler must use a task gate in order to have a valid TSS under
	  which to execute; it must also reset the busy bit in the new TSS
SeeAlso: INT 0B"CPU"
--------H-0B---------------------------------
INT 0B - IRQ3 - SERIAL COMMUNICATIONS (COM2)
Desc:	automatically asserted by the UART when COM2 needs attention, if the
	  UART has been programmed to generate interrupts
Notes:	the TOPS and PCnet adapters use this interrupt request line as an
	  alternate
	on PS/2s, COM2 through COM8 share this interrupt; on many PC's, COM4
	  shares this interrupt
	may be masked by setting bit 3 on I/O port 21h
SeeAlso: INT 0C"COM1",INT 53"DESQview",INT 5B"DoubleDOS",INT 7B"GO32"
--------C-0B---------------------------------
INT 0B P - CPU-generated (80286+) - SEGMENT NOT PRESENT
Desc:	generated when loading a segment register if the segment descriptor
	  indicates that the segment is not currently in memory, unless the
	  segment is an LDT (see INT 0A"CPU") or stack segment (see
	  INT 0C"CPU") needed by a task switch
Note:	may be used to implement virtual memory by loading in segments as they
	  are accessed, clearing the "not present" bit after loading
SeeAlso: INT 0A"CPU",INT 0E"hardware"
--------h-0B---------------------------------
INT 0B - HP 95LX - LOW-LEVEL KEYBOARD HANDLER
Desc:	this is the lowest-level keyboard handler on an HP 95LX palmtop
Note:	debounces key, places the keycode in I/O register 60h, and calls INT 09
SeeAlso: INT 09,INT 0D"HP 95LX",INT 15/AX=4DD4h
--------H-0C---------------------------------
INT 0C - IRQ4 - SERIAL COMMUNICATIONS (COM1)
Desc:	automatically asserted by the UART when COM1 needs attention, if the
	  UART has been programmed to generate interrupts
BUG:	this vector is modified but not restored by Direct Access v4.0, and
	  may be left dangling by other programs written with the same version
	  of compiled BASIC
Notes:	on many PC's, COM3 shares this interrupt
	may be masked by setting bit 4 on I/O port 21h
SeeAlso: INT 0B"COM2",INT 54"DESQview",INT 5C"DoubleDOS",INT 7C"GO32"
--------C-0C---------------------------------
INT 0C - CPU-generated (80286+) - STACK FAULT
Desc:	this interrupt is generated in protected mode on a stack overflow or
	  underflow, or if an inter-level transition or task switch references
	  a stack segment marked "not present"; it is generated in real mode
	  on accessing a word operand at SS:FFFFh
Note:	the 80286 will shut down in real mode if SP=1 before a push.  On the
	  PC AT and compatibles, external circuitry generates a reset on
	  shutdown.
SeeAlso: INT 0B"CPU",INT 0D"CPU"
--------I-0C---------------------------------
INT 0C - IBM SYSTEM 36/38 WORKSTATION EMULATION - API POINTER
Desc:	the IBM System 36/38 emulator may be invoked through a private API,
	  whose entry point address is offset 100h in the segment pointed at
	  by this vector

Call the API entry point with
	AH = function
	    03h update screen
	    05h select next session
		AL = session number (00h-03h)
		Return: AL = session type code
			    00h not active
			    01h display session
			    02h printer session
			    FEh invalid session number
			DS = requested session's data segment (0 if not active)
Return: ???

Format of emulator's data area (offset from interrupt handler's segment):
Offset	Size	Description
13Eh	BYTE	bit flags for status line indicators turned on since this byte
		last zerod
13Fh	BYTE	bit flags for status line indicators turned off since this
		byte last set to FFh
140h	WORD	offset of EBCDIC to ASCII translation
146h	WORD	offset of EBCDIC screen buffer
148h	WORD	offset of EC (engineering change) level signature
150h	BYTE	"KEYI"
151h	BYTE	5250 key scan code to be sent to remote
15Bh	BYTE	"SYSAV"
15Dh	BYTE	5250 cursor column
15Eh	BYTE	5250 cursor row
167h	BYTE	"DVCTAD"
178h	BYTE	"FLAGS"
184h	BYTE	"SESSNOAD"
193h	BYTE	"STNAD"
198h	BYTE	"NSDS"
--------H-0D---------------------------------
INT 0D - IRQ5 - FIXED DISK (PC,XT), LPT2 (AT), reserved (PS/2)
Notes:	under DESQview, only the INT 15h vector and BASIC segment address (the
	  word at 0000h:0510h) may be assumed to be valid for the handler's
	  process
	may be masked by setting bit 5 on I/O port 21h
SeeAlso: INT 0E"IRQ6",INT 0F"IRQ7",INT 55"DESQview",INT 5D"DoubleDOS"
SeeAlso: INT 7D"GO32"
--------H-0D---------------------------------
INT 0D - IRQ5 - Tandy 1000 60 Hz RAM REFRESH
Desc:	used to ensure that the dynamic RAM retains its contents
SeeAlso: INT 55
--------h-0D---------------------------------
INT 0D - HP 95LX - INFRARED INTERRUPT
Desc:	this interrupt is used to perform communications over the infrared
	  data link
SeeAlso: INT 0B"HP 95LX",INT 0E"HP 95LX",INT 15/AX=4DD4h
--------C-0D---------------------------------
INT 0D - CPU-generated (80286+) - GENERAL PROTECTION VIOLATION
Desc:	the CPU generates this interrupt when it detects a protection violation
	  which does not fit under any other category having a separate
	  interrupt
Notes:	called in real mode when
	    an instruction accesses a memory operand extending beyond offset
	      FFFFh (i.e. WORD at FFFFh or DWORD at FFFDh or higher) in segment
	      CS, DS, ES, FG, or GS
	    a PUSH MEM or POP MEM instruction contains an invalid bit encoding
	      in the second byte
	    an instruction exceeds the maximum length allowed (10 bytes for
	      80286, 15 bytes for 80386/80486)
	    an instruction wraps from offset FFFFh to offset 0000h
	called in protected mode on protection violations not covered by INT 06
	  through INT 0C, including
	    segment limit violations
	    write to read-only segments
	    accesses using null DS or ES selectors
	    accesses to segments with privilege greater than CPL
	    wrong descriptor type
	called on 80486 protected-mode floating-point protection fault
SeeAlso: INT 09"80486",INT 0C"STACK"
--------H-0E---------------------------------
INT 0E - IRQ6 - DISKETTE CONTROLLER
Desc:	this interrupt is generated by the floppy disk controller on
	  completion of an operation
Notes:	default handler is at F000h:EF57h in IBM PC and 100%-compatible BIOSes
	may be masked by setting bit 6 on I/O port 21h
SeeAlso: INT 0D"IRQ5",INT 56"DESQview",INT 5E"DoubleDOS",INT 7E"GO32"
--------C-0E---------------------------------
INT 0E - CPU-generated (80386+ native mode) - PAGE FAULT
Desc:	this interrupt is generated in protected and virtual-86 modes on
	  attempting to access a 4K memory page whose page table entry has
	  the "present" bit cleared
Note:	used to implement virtual memory
SeeAlso: INT 0B"hardware"
--------h-0E---------------------------------
INT 0E - HP 95LX - EXTERNAL CARD INTERRUPT
SeeAlso: INT 0D"HP 95LX",INT 0F"HP 95LX",INT 15/AX=4DD4h
--------H-0F---------------------------------
INT 0F - IRQ7 - PARALLEL PRINTER
Desc:	this interrupt is generated by the LPT1 printer adapter when the
	  printer becomes ready
Notes:	most printer adapters do not reliably generate this interrupt
	the 8259 interrupt controller generates an interrupt corresponding to
	  IRQ7 when an error condition occurs
SeeAlso: INT 0D"LPT2",INT 57"DESQview",INT 5F"DoubleDOS",INT 7F"GO32"
--------h-0F---------------------------------
INT 0F - HP 95LX - REAL-TIME CLOCK
SeeAlso: INT 0E"HP 95LX",INT 15/AX=4DD4h,INT 70
--------C-10---------------------------------
INT 10 - CPU-generated (80286+) - COPROCESSOR ERROR
Desc:	this interrupt is generated by the CPU when the -ERROR pin is asserted
	  by the coprocessor
Note:	AT's and clones usually wire the coprocessor to use IRQ13, but not all
	  get it right
SeeAlso: INT 09"hardware",INT 75
--------V-1000-------------------------------
INT 10 - VIDEO - SET VIDEO MODE
	AH = 00h
	AL = mode (see below)
Return: AL = video mode flag (Phoenix BIOS)
	    20h mode > 7
	    30h modes 0-5 and 7
	    3Fh mode 6
	AL = CRT controller mode byte (Phoenix 386 BIOS v1.10)
Desc:	specify the display mode for the currently active display adapter
Notes:	IBM standard modes do not clear the screen if the high bit of AL is set
	  (EGA or higher only)
	the Tseng ET4000 chipset is used by the Orchid Prodesigner II, Diamond
	  SpeedSTAR VGA, Groundhog Graphics Shadow VGA, Boca Super X VGA,
	  Everex EV-673
	the installation check for Ahead adapters is the signature "AHEAD" at
	  C000h:0025h
	the installation check for Paradise adapters is the signature "VGA=" at
	  C000h:007Dh
	the installation check for Oak Tech OTI-037/057/067/077 chipsets is the
	  signature "OAK VGA" at C000h:0008h
	the installation check for ATI adapters is the signature "761295520" at
	  C000h:0031h; the byte at C000h:0043h indicates the chipset revision:
		31h for 18800
		32h for 18800-1
		33h for 18800-2
		34h for 18800-4
		35h for 18800-5
	  the two bytes at C000h:0040h indicate the adapter type
		"22" EGA Wonder
		"31" VGA Wonder
		"32" EGA Wonder800+
	  the byte at C000h:0042h contains feature flags
		bit 1: mouse port present
		bit 4: programmable video clock
	  the byte at C000h:0044h contains additional feature flags if chipset
	    byte > 30h (see below)
	the installation check for Genoa video adapters is the signature
	  77h XXh 99h 66h at C000h:NNNNh, where NNNNh is stored at C000h:0037h
	  and XXh is
		00h for Genoa 6200/6300
		11h for Genoa 6400/6600
		22h for Genoa 6100
		33h for Genoa 5100/5200
		55h for Genoa 5300/5400
	  for SuperEGA BIOS v2.41+, C000h:0057h contains the product level
	  for SuperEGA BIOS v3.0+, C000h:0070h contains the signature
	    "EXTMODE", indicating support for extended modes
SeeAlso: AX=0070h,AX=007Eh,AX=10E0h,AX=10F0h,AH=40h,AX=6F05h,AH=FFh"GO32"
SeeAlso: INT 33/AX=0028h,INT 5F/AH=00h,INT 62/AX=0001h
Index:	installation check;Tseng ET4000|installation check;Ahead video cards
Index:	installation check;Oak Technologies|installation check;ATI video cards
Index:	installation check;Paradise video|installation check;Genoa video cards

Bitfields for ATI additional feature flags:
 bit 0	70 Hz non-interlaced display
 bit 1	Korean (double-byte) characters
 bit 2	45 MHz memory clock rather than 40 MHz
 bit 3	zero wait states
 bit 4	paged ROMs
 bit 6	no 8514/A monitor support
 bit 7	HiColor DAC

Values for video mode:
      text/ text pixel	 pixel	colors	disply	scrn  system
      grph resol  box	resoltn		pages	addr
 00h = T   40x25  8x8		16gray	   8	B800 CGA,PCjr
     = T   40x25  8x14		16gray	   8	B800 EGA
     = T   40x25  8x16		  16	   8	B800 MCGA
     = T   40x25  9x16		  16	   8	B800 VGA
 01h = T   40x25  8x8		  16	   8	B800 CGA,PCjr
     = T   40x25  8x14		  16	   8	B800 EGA
     = T   40x25  8x16		  16	   8	B800 MCGA
     = T   40x25  9x16		  16	   8	B800 VGA
 02h = T   80x25  8x8		16gray	   4	B800 CGA,PCjr
     = T   80x25  8x14		16gray	   4	B800 EGA
     = T   80x25  8x16		  16	   4	B800 MCGA
     = T   80x25  9x16		  16	   4	B800 VGA
 03h = T   80x25  8x8		  16	   4	B800 CGA,PCjr
     = T   80x25  8x14		  16	   4	B800 EGA
     = T   80x25  8x16		  16	   4	B800 MCGA
     = T   80x25  9x16		  16	   4	B800 VGA
 04h = G   40x25  8x8	320x200	   4		B800 CGA,PCjr,EGA,MCGA,VGA
 05h = G   40x25  8x8	320x200	 4gray		B800 CGA,PCjr,EGA
     = G   40x25  8x8	320x200	   4		B800 MCGA,VGA
 06h = G   80x25  8x8	640x200	   2		B800 CGA,PCjr,EGA,MCGA,VGA
 07h = T   80x25  9x14		 mono	  var	B000 MDA,Hercules,EGA
     = T   80x25  9x16		 mono		B000 VGA
 08h = T  132x25  8x8		  16		B800 ATI EGA/VGA Wonder [2]
     = T  132x25  8x8		 mono		B000 ATI EGA/VGA Wonder [2]
     = G   20x25  8x8	160x200	  16		     PCjr, Tandy 1000
     = G   90x43  8x8	720x352	 mono		B000 Hercules + MSHERC.COM
     = G   90x45  8x8		 mono		B000 Hercules + HERKULES [11]
 09h = G   40x25  8x8	320x200	  16		     PCjr
 0Ah = G   80x25  8x8	640x200	   4		     PCjr, Tandy 1000
 0Bh =	 reserved (used internally by EGA BIOS)
     = G		640x200	  16		     Tandy 1000 SL/TL
 0Ch =	 reserved (used internally by EGA BIOS)
 0Dh = G   40x25  8x8	320x200	  16	   8	A000 EGA,VGA
 0Eh = G   80x25  8x8	640x200	  16	   4	A000 EGA,VGA
 0Fh = G   80x25  8x14	640x350	 mono	   2	A000 EGA,VGA
 10h = G   80x25  8x14	640x350	   4	   2	A000 64k EGA
     = G		640x350	  16		A000 256k EGA,VGA
 11h = G   80x30  8x16	640x480	 mono		A000 VGA,MCGA,ATI EGA,ATI VIP
 12h = G   80x30  8x16	640x480	 16/256k	A000 VGA,ATI VIP
     = G   80x30  8x16	640x480	 16/64		A000 ATI EGA Wonder
     = G		640x480	  16		     UltraVision+256K EGA
 13h = G   40x25  8x8	320x200 256/256k	A000 VGA,MCGA,ATI VIP
 14h = T  132x25  Nx16		  16		     XGA, IBM Enhanced VGA [3]
     = T  132x25  8x16 1056x400	 16/256k	     Cirrus CL-GD5420/5422/5426
     = G   80x25  8x8	640x200			     Lava Chrome II EGA
     = G		640x400	  16		     Tecmar VGA/AD
 15h = G   80x25  8x14	640x350			     Lava Chrome II EGA
 16h = G   80x25  8x14	640x350			     Lava Chrome II EGA
     = G		800x600	  16		     Tecmar VGA/AD
 17h = T  132x25				     Tecmar VGA/AD
     = T   80x43  8x8	640x350	  16	   4	B800 Tseng ET4000 BIOS [10]
     = G   80x34  8x14	640x480			     Lava Chrome II EGA
 18h = T   80x30  9x16	720x480	  16	   1	A000 Realtek RTVGA [12]
     = T  132x25		 mono		B000 Cirrus 5320 chipset
     = T  132x44  8x8		 mono		B000 Tseng Labs EVA
     = T  132x44  9x8  1188x352	  4gray	   2	B000 Tseng ET3000 chipset
     = T  132x44  8x8		 16/256	   2	B000 Tseng ET4000 chipset
     = G   80x34  8x14	640x480			     Lava Chrome II EGA
     = G	       1024x768	  16		     Tecmar VGA/AD
 19h = T   80x43  9x11	720x473	  16	   1	A000 Realtek RTVGA [12]
     = T  132x25  8x14		 mono		B000 Tseng Labs EVA
     = T  132x25  9x14 1188x350	  4gray	   4	B000 Tseng ET3000 chipset
     = T  132x25  8x14		 16/256	   4	B000 Tseng ET4000 chipset
     = T  132x34		 mono		B000 Cirrus 5320 chipset
 1Ah = T   80x60  9x8	720x480	  16	   1	A000 Realtek RTVGA [12]
     = T  132x28  8x13		 mono		B000 Tseng Labs EVA
     = T  132x28  9x13 1188x364	  4gray	   4	B000 Tseng ET3000 chipset
     = T  132x28  8x13		 16/256	   4	B000 Tseng ET4000 chipset
     = T  132x44		 mono		B000 Cirrus 5320 chipset
     = G		640x350	 256		     Tecmar VGA/AD
 1Bh = T  132x25  9x14 1188x350	  16	   1	A000 Realtek RTVGA [12]
     = G		640x400	 256		     Tecmar VGA/AD
 1Ch = T  132x25				     Cirrus 5320 chipset
     = T  132x30  9x16 1188x480	  16	   1	A000 Realtek RTVGA [12]
     = G		640x480	 256		     Tecmar VGA/AD
 1Dh = T  132x43				     Cirrus 5320 chipset
     = T  132x43  9x11 1188x473	  16	   1	A000 Realtek RTVGA [12]
     = G		800x600	 256		     Tecmar VGA/AD
 1Eh = T  132x44				     Cirrus 5320 chipset
     = T  132x60  9x8  1188x480	  16	   1	A000 Realtek RTVGA [12]
 1Fh = G  100x75  8x8	800x600	  16	   1	A000 Realtek RTVGA
 20h = G		240x128			B000 HP 95LX
     = G  120x45  8x16	960x720	  16	   1	A000 Realtek RTVGA
 21h = T  132x60		  16	   2	B800 Tseng ET4000 chipset [10]
     = T  132x44  9x9  1188x396	 16/256k	B800 WD90C
     = T  132x44  9x9		  16		B800 Diamond Speedstar 24X
     = G   80x43  8x8	720x348	 mono		B000 DESQview 2.x+Hercules [4]
     = G  128x48  8x16 1024x768	  16	   1	A000 Realtek RTVGA [12]
 22h = T  132x43				     Allstar Peacock (VGA)
     = T  132x44  8x8				     Tseng Labs EVA
     = T  132x44  9x8  1188x352	 16/256k   2	B800 Tseng ET3000 chipset
     = T  132x44  8x8		 16/256k   2	B800 Tseng ET4000 chipset
     = T  132x44  8x8				     Ahead Systems EGA2001
     = T  132x44  8x8		  16	   2	B800 Ahead B
     = T  132x44		  16		     Orchid Prodesigner VGA
     = G   80x43  8x8	720x348	 mono		B800 DESQview 2.x+Hercules [4]
     = G   96x64  8x16	768x1024  16	   1	A000 Realtek RTVGA
 23h = T  132x25  6x14				     Tseng Labs EVA
     = T  132x25  9x14 1188x350	 16/256k   4	B800 Tseng ET3000 chipset
     = T  132x25  8x14		 16/256	   4	B800 Tseng ET4000 chipset
     = T  132x25  8x14				     Ahead Systems EGA2001
     = T  132x25  8x14		  16	   4	B800 Ahead B
     = T  132x25  8x8		  16		B800 ATI EGA Wonder,ATI VIP
     = T  132x25				     Cirrus 5320 chipset
     = T  132x28				     Allstar Peacock (VGA)
     = T  132x28		  16		     Orchid Prodesigner VGA
     = G  128x48  8x16 1024x768	   4	   1	A000 Realtek RTVGA
 24h = T  132x25				     Allstar Peacock (VGA)
     = T  132x25		  16		     Orchid Prodesigner VGA
     = T  132x28  6x13				     Tseng Labs EVA
     = T  132x28  9x13 1188x364	 16/256k   4	B800 Tseng ET3000 chipset
     = T  132x28  8x13		 16/256k   4	B800 Tseng ET4000 chipset
     = T  132x28  8x12		  16	   1	B800 Ahead B
     = T  132x28				     Cirrus 5320 chipset
     = G   64x32  8x16	512x512	 256	   1	A000 Realtek RTVGA
 25h = G   80x60  8x8	640x480			     Tseng Labs EVA
     = G   80x60  8x8	640x480	 16/256k   1	A000 Tseng ET3000/4000 chipset
     = G		640x480	  16		     VEGA VGA
     = G   80x60  8x8	640x480	  16		A000 Orchid Prodesigner VGA
     = G   80x60  8x8	640x480	  16	   1	A000 Ahead B (same as 26h)
     = G		640x480	  16		     NEC GB-1
     = G		640x480	  16		     Cirrus 5320 chipset
     = G		640x400	 256		     Realtek RTVGA
 26h = T   80x60  8x8				     Tseng Labs EVA
     = T   80x60  8x8	640x480	 16/256k   3	B800 Tseng ET3000/4000 chipset
     = T   80x60				     Allstar Peacock (VGA)
     = T   80x60		  16		     Orchid ProDesigner VGA
     = G   80x60  8x8	640x480			     Ahead Systems EGA2001
     = G   80x60  8x8	640x480	  16	   1	A000 Ahead B (same as 25h)
     = G		640x480	 256		     Realtek RTVGA
 27h = T  132x25  8x8		 mono		B000 ATI EGA Wonder,ATI VIP
     = G		720x512	  16		     VEGA VGA
     = G		720x512	  16		     Genoa
     = G  100x75  8x8	800x600	 256	   1	A000 Realtek RTVGA [12]
 28h = T  ???x???				     VEGA VGA
     = G	       1024x768	 256		     Realtek RTVGA (1meg)
 29h = G		800x600	  16		     VEGA VGA
     = G  100x37  8x16	800x600	  16		A000 Orchid
     = G		800x600	  16		A000 STB,Genoa,Sigma
     = G		800x600	  16		     Allstar Peacock (VGA)
     = G  100x37  8x16	800x600	 16/256k   1	A000 Tseng ET3000/4000 chipset
     = G		800x600	 ???		     EIZO MDB10
     = G		800x600	  16		     Cirrus 5320 chipset
     = G	       1024x1024 256		     Realtek RTVGA BIOS v3.C10
 2Ah = T  100x40				     Allstar Peacock (VGA)
     = T  100x40  8x16		  16		     Orchid Prodesigner VGA
     = T  100x40  8x15	800x600	 16/256k   4	B800 Tseng ET3000/4000 chipset
     = G	       1280x1024  16		     Realtek RTVGA
 2Dh = G		640x350	 256		     VEGA VGA
     = G		640x350 256/256k	A000 Orchid, Genoa, STB
     = G   80x25  8x14	640x350 256/256k   1	A000 Tseng ET3000/4000 chipset
     = G		640x350	 256		     Cirrus 5320 chipset
 2Eh = G		640x480	 256		     VEGA VGA
     = G   80x30  8x16	640x480 256/256k	A000 Orchid
     = G		640x480 256/256k	A000 STB,Genoa,Sigma
     = G   80x30  8x16	640x480 256/256k   1	A000 Tseng ET3000/4000 chipset
 2Fh = T  160x50  8x8  1280x400	  16	   4	B800 Ahead B (Wizard/3270)
     = G		720x512	 256		     VEGA VGA
     = G		720x512	 256		     Genoa
     = G   80x25  8x16	640x400 256/256k   1	A000 Tseng ET4000 chipset
 30h = G		800x600	 256		     VEGA VGA
     = G  100x37  8x16	800x600 256/256k	A000 Orchid
     = G		800x600 256/256k	A000 STB,Genoa,Sigma
     = G		720x350	   2		     3270 PC
     = G		800x600	 256		     Cardinal
     = G		???x???			B800 AT&T 6300
     = G  100x37  8x16	800x600 256/256k   1	A000 Tseng ET3000/4000 chipset
 32h = T   80x34  8x10		  16	   4	B800 Ahead B (Wizard/3270)
 33h = T  132x44  8x8		  16		B800 ATI EGA Wonder,ATI VIP
     = T   80x34  8x8		  16	   4	B800 Ahead B (Wizard/3270)
 34h = T   80x66  8x8		  16	   4	B800 Ahead B (Wizard/3270)
 36h = G		960x720	  16		     VEGA VGA
     = G		960x720	  16		     STB
     = G		960x720	  16		     Tseng ET3000 only
 37h = T  132x44  8x8		 mono		B800 ATI EGA Wonder,ATI VIP
     = G	       1024x768	  16		     VEGA VGA
     = G  128x48  8x16 1024x768	  16		A000 Orchid
     = G	       1024x768	  16		A000 STB,Genoa,Sigma
     = G	       1024x768	  16		     Definicon
     = G  128x48  8x16 1024x768	  16	   1	A000 Tseng ET3000/4000 chipset
 38h = G	       1024x768	 256		     STB VGA/EM-16 Plus (1MB)
     = G  128x48  8x16 1024x768 256/256k   1	A000 Tseng ET4000 chipset
     = G	       1024x768	 256		     Orchid ProDesigner II
 3Dh = G	       1280x1024  16		     Definicon
     = G  128x64  8x16 1280x1024  16	   1	A000 Tseng ET4000 v3.00 [1,7]
 3Eh = G	       1280x961	  16		     Definicon
 40h = T   80x43				     VEGA VGA, Tecmar VGA/AD
     = T   80x43				     Video7 V-RAM VGA
     = T   80x43				     Tatung VGA
     = T  100x30		  16		     MORSE VGA
     = T  100x30				     Cirrus 510/520 chipset
     = T   80x25	720x350	 mono		     Genoa SuperEGA BIOS 3.0+
     = G   80x25  8x16	640x400	   2	   1	B800 AT&T 6300, AT&T VDC600
     = G   80x25  8x16	640x400	   2	   1	B800 Compaq Portable
 41h = T  132x25				     VEGA VGA
     = T  132x25				     Tatung VGA
     = T  132x25				     Video7 V-RAM VGA
     = T  100x50		  16		     MORSE VGA
     = T  100x50				     Cirrus 510/520 chipset
     = T   80x34  9x14	720x476	 16/256k	B800 WD90C
     = T   80x34  9x14		  16		B800 Diamond Speedstar 24X
     = G		640x200	  16	   1	     AT&T 6300
     = G   80x25	720x348	 mono		B000 Genoa SuperEGA BIOS 3.0+
 42h = T  132x43				     VEGA VGA
     = T  132x43				     Tatung VGA
     = T  132x43				     Video7 V-RAM VGA
     = T   80x34  9x10		   4	   4	B800 Ahead B (Wizard/3270)
     = T  100x60		  16		     MORSE VGA
     = T  100x60				     Cirrus 510/520 chipset
     = G   80x25  8x16	640x400	  16		     AT&T 6300, AT&T VDC600
     = G   80x25	720x348	 mono		B800 Genoa SuperEGA BIOS 3.0+
 43h = T   80x60				     VEGA VGA
     = T   80x60				     Tatung VGA
     = T   80x60				     Video7 V-RAM VGA
     = T   80x45  9x8		   4	   4	B800 Ahead B (Wizard/3270)
     = T  100x75		  16		     MORSE VGA
     = T   80x29	720x348	 mono		     Genoa SuperEGA BIOS 3.0+
     = G	     640x200 of 640x400 viewport     AT&T 6300 (unsupported)
 44h =	 disable VDC and DEB output		     AT&T 6300
     = T  100x60				     VEGA VGA
     = T  100x60				     Tatung VGA
     = T  100x60				     Video7 V-RAM VGA
     = T   80x32	720x352	 mono		     Genoa SuperEGA BIOS 3.0+
 45h = T  132x28				     Tatung VGA
     = T  132x28				     Video7 V-RAM VGA
     = T   80x44	720x352	 mono		     Genoa SuperEGA BIOS 3.0+
 46h = T  132x25  8x14		 mono		     Genoa 6400
     = T  132x25  9x14		 mono		     Genoa SuperEGA BIOS 3.0+
     = G  100x40  8x15	800x600	   2		     AT&T VDC600
 47h = T  132x29  8x12		 mono		     Genoa 6400
     = T  132x29  9x12		 mono		     Genoa SuperEGA BIOS 3.0+
     = T  132x28  9x16 1188x448	 16/256k	B800 WD90C
     = T  132x28  9x16		  16		B800 Diamond Speedstar 24X
     = G  100x37  8x16	800x600	  16		     AT&T VDC600
 48h = T  132x32  8x12		 mono		     Genoa 6400
     = T  132x32  9x11		 mono		     Genoa SuperEGA BIOS 3.0+
     = G   80x50  8x8	640x400	   2		B800 AT&T 6300, AT&T VDC600
 49h = T  132x44  8x8		 mono		     Genoa 6400
     = T  132x44  9x8		 mono		     Genoa SuperEGA BIOS 3.0+
     = G   80x30  8x16	640x480			     Lava Chrome II EGA
 4Dh = T  120x25				     VEGA VGA
 4Eh = T  120x43				     VEGA VGA
     = T   80x60  8x8		 16/256k	B800 Oak OTI-067/OTI-077 [8]
 4Fh = T  132x25				     VEGA VGA
     = T  132x60				     some Oak Tech VGA [8]
 50h = T   80x30  8x16		 16/256k	B800 Trident TVGA 8800/8900
     = T   80x34				     Lava Chrome II EGA
     = T   80x43		 mono		     VEGA VGA
     = T  132x25  9x14		 mono		     Ahead Systems EGA2001
     = T  132x25  9x14		   4	   4	B800 Ahead B
     = T  132x25  8x14		  16	   8	B800 OAK Technologies VGA-16
     = T  132x25  8x14		 16/256k	B800 Oak OTI-037/067/077 [8]
     = T  132x25  8x14 1056x350	  16	   8	B800 UM587 chipset
     = T  132x30		  16		     MORSE VGA
     = T  132x30				     Cirrus 510/520 chipset
     = G   80x30  8x16	640x480	  16		     Paradise EGA-480
     = G   80x30  8x16	640x480	  16		     NEL Electronics BIOS
     = G		640x480	 mono???	     Taxan 565 EGA
     = G   40x25  8x8	320x200			     Genoa SuperEGA BIOS 3.0+
 51h = T   80x30  8x16				     Paradise EGA-480
     = T   80x30  9x16				     NEL Electronics BIOS
     = T   80x30				     Lava Chrome II EGA
     = T   80x43  8x11		 16/256k	B800 Trident TVGA 8800/8900
     = T  132x25		 mono		     VEGA VGA
     = T  132x28  9x12		   4	   4	B800 Ahead B
     = T  132x43  8x8		  16	   5	B800 OAK Technologies VGA-16
     = T  132x43  8x8		16/256k		B800 Oak OTI-037/067/077
     = T  132x43  8x8  1056x344	  16	   5	B800 UM587 chipset
     = T  132x50		  16		     MORSE VGA
     = T  132x50				     Cirrus 510/520 chipset
     = G   80x34  8x14	640x480	  16		     ATI EGA Wonder
     = G   80x25  8x8	640x200			     Genoa SuperEGA BIOS 3.0+
 52h = T   80x60				     Lava Chrome II EGA
     = T   80x60  8x8		 16/256k	B800 Trident TVGA 8800/8900
     = T  132x43		 mono		     VEGA VGA
     = T  132x44  9x8		 mono		     Ahead Systems EGA2001
     = T  132x44  9x8		   4	   2	B800 Ahead B
     = T  132x60		  16		     MORSE VGA
     = T  132x60				     Cirrus 510/520 chipset
     = G   94x29  8x14	752x410	  16		     ATI EGA Wonder
     = G  100x75  8x8	800x600	  16	   1	A000 OAK Technologies VGA-16
     = G  100x75  8x8	800x600	  16		A000 Oak OTI-037 chipset [8]
     = G  100x37  8x16	800x600	  16		A000 Oak OTI-067/077 chips [8]
     = G  100x75  8x8	800x600	  16		A000 UM587 chipset
     = G  128x30  8x16 1024x480	  16		     NEL Electronics BIOS
 53h = T   80x25  8x16				     NEL Electronics BIOS
     = T   80x60		  16		     MORSE VGA
     = T   80x60				     Cirrus 510/520 chipset
     = T  132x25  8x14		 16/256k	B800 Trident TVGA 8800/8900
     = T  132x43				     Lava Chrome II EGA
     = G		640x480	 256		     Oak VGA
     = G   80x30  8x16	640x480	 256		A000 Oak OTI-067/OTI-077 [8]
     = G  100x40  8x14	800x560	  16		     ATI EGA Wonder,ATI VIP
     = G					     AX PC
 54h = T  132x25				     Lava Chrome II EGA
     = T  132x30  8x16		 16/256k	B800 Trident TVGA 8800/8900
     = T  132x43  8x8				     Paradise EGA-480
     = T  132x43  8x8				     NEL Electronics BIOS
     = T  132x43  7x9		 16/256k	B800 Paradise VGA
     = T  132x43  8x9		 16/256k	B800 Paradise VGA on multisync
     = T  132x43				     Taxan 565 EGA
     = T  132x43				     AST VGA Plus
     = T  132x43				     Hewlett-Packard D1180A
     = T  132x43  7x9		  16		     AT&T VDC600
     = T  132x43  9x9  1188x387	 16/256k	B800 WD90C
     = T  132x43  9x9		  16		B800 Diamond Speedstar 24X
     = T  132x43  8x8  1056x350	 16/256k	     Cirrus CL-GD5420/5422/5426
     = T  132x50  8x8		  16		A000 NCR 77C22 [9]
     = G  100x42  8x14	800x600	  16		A000 ATI EGA Wonder, VGA Wonder
     = G  100x42  8x14	800x600	  16		A000 ATI Ultra 8514A, ATI XL
     = G		800x600	 256		A000 Oak VGA
     = G  100x37  8x16	800x600	 256		A000 Oak OTI-067/077 chips [8]
 55h = T   80x66  8x8		 16/256k	A000 ATI VIP
     = T  132x25  8x14				     Paradise EGA-480
     = T  132x25  8x14				     NEL Electronics BIOS
     = T  132x25  7x16		 16/256k	B800 Paradise VGA
     = T  132x25  8x16		 16/256k	B800 Paradise VGA on multisync
     = T  132x25				     Taxan 565 EGA
     = T  132x25				     AST VGA Plus
     = T  132x25				     Hewlett-Packard D1180A
     = T  132x25  7x16		  16		     AT&T VDC600
     = T  132x25  8x16		  16		A000 NCR 77C22 [9]
     = T  132x25  9x16 1188x400	 16/256k	B800 WD90C
     = T  132x25  9x16		  16		B800 Diamond Speedstar 24X
     = T  132x25  8x14	1056x350 16/256k	     Cirrus CL-GD5420/5422/5426
     = T  132x43  8x11		 16/256k	B800 Trident TVGA 8800/8900
     = G   94x29  8x14	752x410			     Lava Chrome II EGA
     = G  128x48  8x16 1024x768	 16/256k	A000 ATI VGA Wonder v4+	 [5]
     = G	       1024x768	 16/256k	     ATI VGA Wonder Plus
     = G	       1024x768	 16/256k	     ATI Ultra 8514A,ATI XL
     = G  128x48  8x16 1024x768	   4		A000 Oak OTI-067/077 chips [8]
 56h = T  132x43  8x8		   3???	   2	B000 NSI Smart EGA+
     = T  132x43  7x9		   4		B000 Paradise VGA
     = T  132x43  8x9		   4		B000 Paradise VGA on multisync
     = T  132x43		 mono		     Taxan 565 EGA
     = T  132x43  7x9		   2		     AT&T VDC600
     = T  132x43  9x8				     NEL Electronics BIOS
     = T  132x50  8x8		   4		A000 NCR 77C22 [9]
     = T  132x60  8x8		 16/256k	B800 Trident TVGA 8800/8900
     = G	       1024x768	  16		A000 Oak VGA
     = G  128x48  8x16 1024x768	  16		A000 Oak OTI-067/077 chips [8]
 57h = T  132x25  8x14		   3???	   4	B000 NSI Smart EGA+
     = T  132x25  7x16		   4		B000 Paradise VGA
     = T  132x25  8x16		   4		B000 Paradise VGA on multisync
     = T  132x25  9x14				     NEL Electronics BIOS
     = T  132x25		 mono		     Taxan 565 EGA
     = T  132x25  7x16		   2		     AT&T VDC600
     = T  132x25  9x14		 16/256k	B800 Trident TVGA 8800/8900
     = T  132x25  8x16		   4		A000 NCR 77C22 [9]
     = G   96x48  8x16	768x1024  16		A000 Oak OTI-067/077 chips [8]
 58h = T   80x33  8x14		  16		B800 ATI EGA Wonder,ATI VIP
     = T   80x32  9x16		  16		     Genoa 6400
     = T   80x43  8x8				     NEL Electronics BIOS
     = T  132x30  9x16		 16/256k	B800 Trident TVGA 8800/8900
     = G  100x75  8x8	800x600	 16/256k	A000 Paradise VGA
     = G  100x75  8x8	800x600	  16		     AT&T VDC600
     = G  100x75  8x8	800x600	  16		A000 NCR 77C22 [9]
     = G  100x75  8x8	800x600	  16		     Diamond Speedstar 24X
     = G  100x75  8x8	800x600	 16/256k	A000 Paradise VGA, WD90C
     = G		800x600	  16		     AST VGA Plus, Compaq VGA
     = G		800x600	  16		     Dell VGA
     = G		800x600	  16		     Hewlett-Packard D1180A
     = G		800x600	 ???		     ELT VGA PLUS 16
     = G  100x37  8x16	800x600	 16/256k	A000 Cirrus CL-GD5420/5422/5426
     = G  160x64  8x16 1280x1024  16		A000 Oak OTI-077 chipset [8]
 59h = T   80x43  9x8				     NEL Electronics BIOS
     = T   80x66  8x8		 16/256k	A000 ATI VIP
     = T  132x43  9x11		 16/256k	B800 Trident TVGA 8800/8900
     = G  100x75  8x8	800x600	   2		A000 Paradise VGA
     = G  100x75  8x8	800x600	   2		     AT&T VDC600
     = G		800x600	   2		     AST VGA Plus, Compaq VGA
     = G		800x600	   2		     Dell VGA
     = G		800x600	   2		     Hewlett-Packard D1180A
     = G  100x75  8x8	800x600	   2		A000 NCR 77C22 [9]
     = G  128x48  8x16 1024x768	 256		A000 Oak OTI-077 chipset [8]
 5Ah = T   80x60  8x8				     NEL Electronics BIOS
     = T  132x60  9x8		 16/256k	B800 Trident TVGA 8800/8900
     = G  128x48  8x16 1024x768	   2		A000 NCR 77C22 [9]
 5Bh = T   80x30  8x16				B800 ATI VGA Wonder (undoc)
     = G		640x350	 256		     Genoa 6400
     = G   80x25  8x16	640x400	  32K		A000 Oak OTI-067/077 chips [8]
     = G		800x600	  16		     Maxxon, SEFCO TVGA, Imtec
     = G  100x75  8x8	800x600	 16/256k	A000 Trident TVGA 8800, 8900
     = G		800x600	 ???		     Vobis MVGA
     = G  100x37  8x16	800x600			     NEL Electronics BIOS
     = G  128x48  8x16 1024x768	  16		A000 NCR 77C22 [1,9]
 5Ch = T  100x37  8x16				     NEL Electronics BIOS
     = G		640x400	 256		     Logix, ATI Prism Elite
     = G		640x400	 256		     Maxxon, SEFCO TVGA, Imtec
     = G   80x25  8x16	640x400	 256/256k	A000 Zymos Poach, Hi Res 512
     = G   80x25  8x16	640x400	 256/256k	A000 Trident TVGA 8800/8900
     = G   80x30  8x16	640x480	 256		     Genoa 6400
     = G   80x30  8x16	640x480	  32K		A000 Oak OTI-077 chipset [8]
     = G  100x75  8x8	800x600	 256		A000 NCR 77C22 [9]
     = G  100x75  8x8	800x600	 256/256k	A000 WD90C
     = G  100x75  8x8	800x600	 256/256k	A000 Diamond Speedstar 24X
     = G  100x37  8x16	800x600	 256/256k	A000 Cirrus CL-GD5420/5422/5426
 5Dh = T  100x75  8x8				     NEL Electronics BIOS
     = G		640x480	 256		     Logix, ATI Prism Elite
     = G		640x480	 256		     Maxxon, SEFCO TVGA, Imtec
     = G   80x30  8x16	640x480	 256/256k	A000 Zymos Poach, Hi Res 512
     = G   80x30  8x16	640x480	 256/256k	A000 Trident TVGA 8800 (512K)
     = G  128x48  8x16 1024x768	  16		A000 NCR 77C22 [9]
     = G  128x48  8x16 1024x768	  16/256k	A000 WD90C
     = G  128x48  8x16 1024x768	  16		     Diamond Speedstar 24X
     = G  128x48  8x16 1024x768	 16/256k	A000 Cirrus CL-GD5420/5422/5426
 5Eh = G		640x400	 256		     Paradise VGA,VEGA VGA
     = G		640x400	 256		     AST VGA Plus, NCR 77C22
     = G		640x400	 256		     Compaq VGA, Dell VGA
     = G   80x25  8x16	640x400	 256		     AT&T VDC600
     = G   80x25  8x16	640x400	 256		A000 NCR 77C22 [9]
     = G   80x25  8x16	640x400	 256/256k	A000 WD90C
     = G   80x25  8x16	640x400	 256/256k	A000 Diamond Speedstar 24X
     = G		800x600	  16		     Logix, ATI Prism Elite
     = G  100x37  8x16	800x600	  16		     NEL Electronics BIOS
     = G  100x75  8x8	800x600	 256		     Genoa 6400
     = G  100x75  8x8	800x600	 256/256k	A000 Zymos Poach, Trident 8900
     = G  100x75  8x8	800x600	 256/256k	A000 Hi Res 512
 5Fh = G		640x480	 256		     Paradise VGA
     = G		640x480	 256		     AST VGA Plus, NCR 77C22
     = G		640x480	 256		     Compaq VGA, Dell VGA
     = G		640x480	 256		     Hewlett-Packard D1180A
     = G   80x30  8x16	640x480	 256		     AT&T VDC600 (512K)
     = G   80x30  8x16	640x480	 256		A000 NCR 77C22 [9]
     = G   80x30  8x16	640x480	 256/256k	A000 WD90C
     = G   80x30  8x16	640x480	 256/256k	A000 Diamond Speedstar 24X
     = G   80x30  8x16	640x480	 256/256k	A000 Cirrus CL-GD5420/5422/5426
     = G	       1024x768	  16		     Logix, ATI Prism Elite
     = G	       1024x768	  16		     Maxxon, Imtec
     = G  128x48  8x16 1024x768	  16		     Genoa 6400
     = G  128x48  8x16 1024x768	  16/256k	A000 Zymos Poach, Hi Res 512
     = G  128x48  8x16 1024x768	  16/256k	A000 Trident TVGA 88/8900 512K
 60h = T  132x25  8x14		  16/64	   8	B800 Quadram Ultra VGA
     = T  132x25  8x14		  16		     Genoa 6400
     = T  132x25  8x14		  16		     Genoa SuperEGA BIOS 3.0+
     = T  132x25				     Cirrus 5320 chipset
     = G   80x???	???x400			     Corona/Cordata BIOS 4.10+
     = G   80x25  8x16	640x400	 256	   1	A000 Ahead A, Ahead B
     = G		752x410			     VEGA VGA
     = G		752x410	  16		     Tatung VGA
     = G		752x410	  16		     Video7 V-RAM VGA
     = G  128x48  8x16 1024x768	   4/256k	A000 Trident TVGA 8900
     = G  128x48  8x16 1024x768	 256/256k	A000 WD90C
     = G  128x48  8x16 1024x768	 256/256k	A000 Diamond Speedstar 24X
     = G  128x48  8x16 1024x768	 256/256k	A000 Cirrus CL-GD5420/5422/5426
 61h = T  132x29  8x12		  16/64	   8	B800 Quadram Ultra VGA
     = T  132x29  8x8		  16		     Genoa 6400
     = T  132x29  8x8		  16		     Genoa SuperEGA BIOS 3.0+
     = T  132x50				     Cirrus 5320 chipset
     = G		???x400			     Corona/Cordata BIOS 4.10+
     = G   80x25  8x16	640x400	 256		A000 ATI VGA Wonder,VGA Wonder+
     = G   80x25  8x16	640x400	 256		A000 ATI Ultra 8514A,ATI XL
     = G   80x30  8x16	640x480	 256	   1	A000 Ahead A, Ahead B (512K)
     = G		720x540			     VEGA VGA
     = G		720x540	  16		     Tatung VGA
     = G		720x540	  16		     Video7 V-RAM VGA
     = G   96x64  8x16	768x1024  16/256k	A000 Trident TVGA 88/8900 512K
     = G  128x48  8x16 1024x768	 256		A000 NCR 77C22 [1,9]
 62h = T  132x32  8x11		  16/64	   6	B800 Quadram Ultra VGA
     = T  132x32  8x12		  16		     Genoa 6400
     = T  132x32  8x11		  16		     Genoa SuperEGA BIOS 3.0+
     = G		640x450	  16		     Cirrus 510/520 chipset
     = G   80x30  8x16	640x480	 256		A000 ATI VGA Wonder,VGA Wonder+
     = G   80x30  8x16	640x480	 256		A000 ATI Ultra 8514A,ATI XL
     = G   80x30  8x16	640x480	 32K		A000 WD90C
     = G   80x30  8x16	640x480	 32K		A000 Diamond Speedstar 24X
     = G		800x600			     VEGA VGA
     = G		800x600	  16		     Tatung VGA
     = G		800x600	  16		     Video7 V-RAM VGA
     = G  100x75  8x8	800x600	 256	   1	A000 Ahead A, Ahead B (512K)
     = G  128x48  8x16 1024x768	 256/256k	A000 Trident TVGA 8900, Zymos
     = G  128x48  8x16 1024x768	 256		A000 NCR 77C22 [9]
 63h = T  132x44  8x8		  16/64	   5	B800 Quadram Ultra VGA
     = T  132x44  8x8		  16		     Genoa 6400
     = T  132x44  8x8		  16		     Genoa SuperEGA BIOS 3.0+
     = G		720x540	  16		     MORSE VGA
     = G		720x540	  16		     Cirrus 510/520 chipset
     = G  100x42  8x14	800x600	 256		A000 ATI VGA Wonder,VGA Wonder+
     = G  100x42  8x14	800x600	 256		A000 ATI Ultra 8514A,ATI XL
     = G		800x600	 32K		A000 WD90C
     = G		800x600	 32K		A000 Diamond Speedstar 24X
     = G  128x48  7x16 1024x768	 256	   1	A000 Ahead B (1MB)
     = G	       1024x768	   2		     Video7 V-RAM VGA
 64h = T  132x60  8x8		  16		     Genoa 6400
     = G    -	   -	640x480	 64K		A000 Cirrus CL-GD 5422/5426
     = G		800x600	  16		     MORSE VGA
     = G		800x600	  16		     Cirrus 510/520 chipset
     = G		800x600	 ???		     SAMPO-Mira VGA
     = G	       1024x768	   4		     Video7 V-RAM VGA
     = G  128x48  8x16 1024x768	 256		A000 ATI VGA Wonder Plus,ATI XL
     = G  160x64  8x16 1280x1024 16/256k	A000 WD90C [1]
     = G  160x64  8x16 1280x1024 16/256k	A000 Diamond Speedstar 24X [1]
 65h = G    -	   -	800x600	 64K		A000 Cirrus CL-GD 5422/5426
     = G	       1024x768	  16		     Video7 V-RAM VGA
     = G  128x48  8x16 1024x768	  16		A000 ATI VGA Wonder
 66h = T   80x50  8x8	640x400	 16/256k	B800 WD90C
     = T   80x50  8x8		  16		B800 Diamond Speedstar 24X
     = G		640x400	 256		     Tatung VGA
     = G		640x400	 256		     Video7 V-RAM VGA
     = G    -	   -	640x480	 32K		A000 Cirrus CL-GD 5422/5426
 67h = T   80x43  8x8	640x344	 16/256k	B800 WD90C
     = T   80x43  8x8		  16		B800 Diamond Speedstar 24X
     = G		640x480	 256		     Video7 V-RAM VGA
     = G    -	   -	800x600	 32K		A000 Cirrus CL-GD 5422/5426
     = G  128x48  8x16 1024x768	   4		A000 ATI VGA Wonder
     = G  160x64  8x16 1280x1024  16		A000 NCR 77C22 [1,9]
 69h = T  132x50  8x8  1056x400	 16/256k	B800 WD90C
     = T  132x50  8x8		  16		B800 Diamond Speedstar 24X
     = G		720x540	 256		     Video7 V-RAM VGA
 6Ah = G		800x600	  16		A000 VESA standard interface
     = G  100x75  8x8	800x600	  16		     Genoa 6400
     = G  100x75  8x8	800x600	  16		     Diamond Speedstar 24X
     = G		800x600	  16		A000 Ahead A
     = G  100x75  8x8	800x600	  16	   1	A000 Ahead B (VESA) (see 71h)
     = G		800x600	  16		     Zymos Poach, Hi Res 512
     = G		800x600	  16		     Epson LT-386SX in CRT Mode
     = G		800x600	  16		     Compuadd 316SL in CRT Mode
     = G  100x37  8x16	800x600	 16/256k	A000 Cirrus CL-GD5420/5422/5426
     = G  100x42  8x14	800x600			A000 ATI VGA Wonder (undoc)
     = G  160x64  8x16 1280x1024 256		A000 NCR 77C22 [1,9]
 6Bh = T  100x37  8x16		  16		     Genoa 6400
     = T  100x37  8x16				     NEL Electronics BIOS
 6Ch = G   80x30  8x16	640x480	  16M		A000 Trident 8900CL/BIOS C04
     = G  100x75  8x8	800x600	 256		     Genoa 6400
     = G  160x60  8x16 1280x960	 16/256k	A000 WD90C [1]
     = G  160x60  8x16 1280x960	 16/256k	A000 Diamond Speedstar 24X [1]
     = G  160x64  8x16 1280x1024 16/256k	A000 Cirrus CL-GD 5422/5426 [1]
 6Dh = G  160x64  8x16 1280x1024 256/256k	A000 Cirrus CL-GD 5422/5426 [1]
 6Eh = G   40x25  8x8	320x200	  64K		A000 Cirrus CL-GD 5422/5426
 6Fh = G   40x25  8x8	320x200	  16M		A000 Cirrus CL-GD 5422/5426
 70h =	 extended mode set (see AX=0070h)	     Everex Micro Enhancer EGA
     = T   40x25  8x8		  16	   8	B800 Quadram (CGA double scan)
     = T   40x25  8x8	(CGA dblscan)		     Genoa SuperEGA BIOS 3.0+
     = G		360x480	 256		     Cirrus 510/520/5320 chips
     = G   90x28  8x14	720x392	  16	   1	A000 Ahead B
     = G		800x600	  16		     C&T chipset, Cardinal
     = G	       1024x480	 256		     Trident 8900C BIOS C3.0
 71h = T   80x25  8x8		  16	   8	B800 Quadram (CGA double scan)
     = T   80x25  8x8	(CGA dblscan)		     Genoa SuperEGA BIOS 3.0+
     = G		528x400	 256		     Cirrus 510/520 chipset
     = G   80x30  8x16	640x480	  16M		A000 Cirrus CL-GD 5422/5426
     = G  100x35  8x16	800x600	 16of64		A000 NSI Smart EGA+
     = G  100x75  8x8	800x600	  16	   1	A000 Ahead B (same as 6Ah)
     = G		960x720	  16		     C&T chipset, Cardinal
     = G	       1024x480	 256		     Trident 8900C BIOS C3.0
 72h = T   80x60  8x8		  16		B800 Quadram Ultra VGA
     = T   80x60  8x8		  16		B800 Genoa 6400
     = T   80x60  8x8		  16		B800 Genoa SuperEGA BIOS 3.0+
     = G		528x480	 256		     Cirrus 510/520 chipset
     = G		640x480 32768		A000 ATI
     = G		640x480	 16M		A000 WD90C
     = G		640x480	 16M		A000 Diamond Speedstar 24X
     = G	       1024x768	  16		     C&T chipset, Cardinal
 73h = G   80x60  8x8	640x480	  16		A000 Quadram Ultra VGA
     = G   80x60  8x8	640x480	  16		     Genoa 6400
     = G   80x60  8x8	640x480	  16		     Genoa SuperEGA BIOS 3.0+
 74h = T   80x66  8x8		  16		B800 Quadram Ultra VGA
     = T   80x66  8x8		  16		B800 Genoa 6400
     = T   80x66  8x8		  16		B800 Genoa SuperEGA BIOS 3.0+
     = G		640x400	   2		B800 Toshiba 3100 AT&T mode
     = G   80x30  8x16	640x480	  32K		A000 Trident 8900C/BIOS C03
     = G  128x48  8x16 1024x768	  16	   1	A000 Ahead A, Ahead B (512K)
     = G     -	   -   1024x768	  64K		A000 Cirrus CL-GD 5422/5426 [1]
 75h = G   80x30  8x16	640x480	  64K		A000 Trident 8900C/BIOS C03
     = G   80x66	640x528	  16???		A000 Quadram Ultra VGA
     = G   80x66	640x528	  16		     Genoa SuperEGA BIOS 3.0+
     = G  128x48  8x16 1024x768	   4	   1	A000 Ahead B
 76h = T   94x29  8x14		  16		B800 Quadram Ultra VGA
     = T   94x29  8x14				     Genoa SuperEGA BIOS 3.0+
     = G  100x75  8x8	800x600	  32K		A000 Trident 8900C/BIOS C03
     = G  128x48  8x16 1024x768	   2	   1	A000 Ahead B
 77h = G   94x29	752x410	  16???		A000 Quadram Ultra VGA
     = G   94x29	752x410	  16		     Genoa SuperEGA BIOS 3.0+
     = G  100x75  8x8	800x600	  64K		A000 Trident 8900C/BIOS C03
 78h = T  100x37  8x16		  16		     Genoa 6400
     = T  100x75  8x8		  16		B800 Quadram Ultra VGA
     = T  100x75  8x8				     Genoa SuperEGA BIOS 3.0+
     = G		640x400	 256		     STB VGA/EM-16 Plus
     = G		640x400	 256		     Cardinal, C&T chipset
     = G		640x400	 256		     Cirrus 5320 chipset
 79h = G		640x480	 256		     Cardinal, C&T chipset
     = G  100x75	800x600	  16???		A000 Quadram Ultra VGA
     = G  100x75  8x8	800x600	  16		     Genoa SuperEGA BIOS 3.0+
     = G  100x75  8x8	800x600	  16		     Genoa 6400
 7Ah = T  114x60  8x8		  16		B800 Quadram Ultra VGA
     = T  114x60  8x8				     Genoa SuperEGA BIOS 3.0+
     = G		720x540	 256		     C&T chipset, Cardinal
 7Bh = G		800x600	 256		     C&T chipset, Cardinal
     = G  114x60	912x480	  16???		A000 Quadram Ultra VGA
     = G		912x480	  16		     Genoa SuperEGA BIOS 3.0+
 7Ch = G		512x512	  16		     Genoa
 7Dh = G   64x32  8x16	512x512	 256		     Genoa
 7Eh =	 special mode set (see AX=007Eh)	     Paradise VGA, AT&T VDC600
     = G   80x25  8x16	640x400	 256		     Genoa 6400
 7Fh =	 special function set (see AX=007Fh)	     Paradise VGA, AT&T VDC600
     = G  128x48  8x16 1024x768	   4		     Genoa 6400
 82h = T   80x25		 B&W		     AT&T VDC overlay mode [6]
 83h = T   80x25				     AT&T VDC overlay mode [6]
 86h = G		640x200	 B&W		     AT&T VDC overlay mode [6]
 88h = G   90x43  8x8	720x352	 mono		B000 Hercules + MSHERC.COM
 C0h = G		640x400	 2/prog pallet	     AT&T VDC overlay mode [6]
 C4h =	 disable output				     AT&T VDC overlay mode [6]
 D0h = G		640x400	   2		B800 DEC VAXmate AT&T mode
Notes:
[1] interlaced only
[2] for ATI EGA Wonder, mode 08h is only valid if SMS.COM is loaded resident.
      SMS maps mode 08h to mode 27h if the byte at location 0040:0063 is 0B4h,
      otherwise to mode 23h, thus selecting the appropriate (monochrome or
      color) 132x25 character mode.
    for ATI VGA Wonder, mode 08h is the same, and only valid if VCONFIG loaded
      resident
[3] early XGA boards support 132-column text but do not have this BIOS mode
[4] DESQview intercepts calls to change into these two modes (21h is page 0,
      22h is page 1) even if there is no Hercules graphics board installed
[5] ATI BIOS v4-1.00 has a text-scrolling bug in this mode
[6] for AT&T VDC overlay modes, BL contains the DEB mode, which may be 06h,
      40h, or 44h
[7] BIOS text support is broken in this undocumented mode; scrolling moves only
      about 1/3 of the screen (and does even that portion incorrectly), while
      screen clears only clear about 3/4.
[8] The Oak OTI-037/067/077 modes are present in the Oak VGA BIOS, which OEMs
      may choose to use only partially or not at all; thus, not all Oak boards
      support all "Oak" modes listed here
[9] this card uses the full 128K A000h-BFFFh range for the video buffer,
      precluding the use of a monochrome adapter in the same system
[10] mode 17h supported by Tseng ET4000 BIOS 8.01X dated 09/14/90, but not
      v8.01X dated 02/28/92; mode 21h supported by 02/28/92 version but not
      09/14/90 version
[11] HERKULES simulates a 90x45 text mode in Hercules graphics mode; the
      installation check for HERKULES.COM is the signature "Herkules" two bytes
      beyond the INT 10 handler
[12] The Realtek RTVGA BIOS v3.C10 crashes when attempting to switch into modes
	21h or 27h; this version of the BIOS also sets the BIOS data area
	incorrectly for extended text modes, resulting in scrolling after only
	24 lines (the VMODE.EXE	utility does set the data area correctly)
Index:	video modes
Index:	installation check|HERKULES
--------V-100070-----------------------------
INT 10 - VIDEO - Everex Micro Enhancer EGA/Viewpoint VGA - EXTENDED MODE SET
	AX = 0070h
	BL = mode (see below)
Desc:	specify a proprietary display mode on the Everex Micro Enhancer or
	  Viewpoint video adapters
SeeAlso: AH=00h,AX=6F05h,AX=7000h/BX=0004h,AH=FFh"GO32"

Values for video mode:
      text/ text pixel	 pixel	colors	disp	scrn  monitor	adapter
      grph resol  box	resoltn		page	addr
 00h = G		640x480	  16		     multsync	EGA,VGA
 01h = G		752x410	  16		     multsync	EGA,VGA
 02h = G		800x600	  16		     multsync	EGA,VGA
 03h = T   80x34				     multsync	EGA,VGA
 04h = T   80x60				     multsync	EGA,VGA
 05h = T   94x29				     multsync	EGA only
 06h = T   94x51				     multsync	EGA only
 07h = T  100x43  8x14		  16				VGA only
 08h = T  100x75  8x8		  16				VGA only
 09h = T   80x44				     EGA	EGA only
 0Ah = T  132x25				     EGA	EGA,VGA
 0Bh = T  132x44				     EGA	EGA,VGA
 0Ch = T  132x25				     CGA	EGA only
 0Dh = T   80x44				     mono	EGA only
 0Eh = T  132x25				     mono
 0Fh = T  132x44				     mono
 10h =	 reserved
 11h = G	       1280x350	   4				EGA only
 12h = G	       1280x600	   4				EGA only
 13h = G		640x350	 256				EGA,EV673
 14h = G		640x400	 256
 15h = G		512x480	 256
 16h = T   80x30  8x16		 256				VGA only
 18h = T  100x27  8x16		  16				VGA only
 20h = G	       1024x768	  16				Everex 629,678
								Everex EV-673
 21h = T  160x64  8x16 1280x1024  16				1MB VGA only
 30h = G		640x480	 256				Everex 629,678
								Everex EV-673
 31h = G		800x600	 256				Everex 629,678
								Everex EV-673
 32h = G  128x48  8x16 1024x768	 256				1MB VGA only
 40h = T  132x30  8x16		  16				VGA only
 50h = T  132x32  8x16		 mono				VGA only
 62h = G   40x25  8x8	320x200	 32K				Vwpt TC (EV629)
 70h = G   64x30  8x16	512x480	 32K				Viewpoint TC
 71h = G   80x30  8x16	640x480	 32K				Viewpoint TC
 76h = G   64x30  8x16	512x480	 16M				Viewpoint TC
 77h = G   80x30  8x16	640x480	 16M				Viewpoint TC
Index:	video modes
--------V-10007E-----------------------------
INT 10 - VIDEO - Paradise VGA, AT&T VDC600 - SET SPECIAL MODE
	AX = 007Eh
	BX = horizontal dimension of the mode desired
	CX = vertical dimension of the mode desired
	     (both BX/CX in pixels for graphics modes, rows for alpha modes)
	DX = number of colors of the mode desired (0000h for monochrome modes)
Return: BH = 7Eh if successful (Paradise VGA)
	AL = 7Eh if successful (AT&T VDC600)
Desc:	specify a display mode by resolution rather than mode number
SeeAlso: AH=00h,AX=0070h,AX=007Fh,AX=6F05h,AH=FFh"GO32"
Index:	video modes
--------V-10007F-----------------------------
INT 10 - VIDEO - Paradise VGA, AT&T VDC600 - EXTENDED FUNCTIONS
	AX = 007Fh
	BH = function
	    00h	 set VGA operation
	    01h	 set non-VGA operation
		color modes (0,1,2,3,4,5,6) will set non-VGA CGA operation
		monochrome mode 7 will set non-VGA MDA/Hercules operation
	    02h	 query mode status
		Return: BL = 00h if operating in VGA mode, 01h if non-VGA mode
			CH = total video RAM size in 64k byte units
			CL = video RAM used by the current mode
	    03h	 lock current mode
		allows current mode (VGA or non-VGA) to survive re-boot
	    04h	 enter CGA mode (AT&T VDC600 only)
	    05h	 enter MDA mode (AT&T VDC600 only)
	    0Ah,0Bh,0Ch,0Dh,0Eh,0Fh  WRITE PARADISE REGISTERS 0,1,2,3,4,5
		(port 03CEh indices 0Ah,0Bh,0Ch,0Dh,0Eh,0Fh)
		BL = value to set in the paradise register
	    1Ah,1Bh,1Ch,1Dh,1Eh,1Fh READ PARADISE REGISTERS 0,1,2,3,4,5
		(port 03CEh indices 0Ah,0Bh,0Ch,0Dh,0Eh,0Fh)
		Return: BL = value of the paradise register
			BH = 7Fh if successful
Return: AL = 7Fh if successful (AT&T VDC600)
Desc:	set emulation mode or access proprietary extended data registers
SeeAlso: AX=007Eh,AH=FF"Oak"
--------V-1001-------------------------------
INT 10 - VIDEO - SET TEXT-MODE CURSOR SHAPE
	AH = 01h
	CH = bit 7    should be zero
	     bits 6,5 cursor blink
		     (00=normal, 01=invisible, 10=erratic, 11=slow)
		     (00=normal, other=invisible on EGA/VGA)
	     bits 4-0 top scan line containing cursor
	CL = bottom scan line containing cursor (bits 0-4)
Desc:	specify the starting and ending scan lines to be occupied by the
	  hardware cursor in text modes
Notes:	buggy on EGA systems--BIOS remaps cursor shape in 43 line modes, but
	  returns unmapped cursor shape
	UltraVision scales size to the current font height by assuming 14-line
	  monochrome and 8-line color fonts; this call is not valid if cursor
	  emulation has been disabled
	applications which wish to change the cursor by programming the
	  hardware directly on EGA or above should call INT 10/AX=1130h or
	  read 0040h:0085h first to determine the current font height
BUG:	AMI 386 BIOS and AST Premier 386 BIOS will lock up the system if AL
	  is not equal to the current video mode
SeeAlso: AH=03h,AX=CD05h,AH=12h/BL=34h
--------V-1002-------------------------------
INT 10 - VIDEO - SET CURSOR POSITION
	AH = 02h
	BH = page number
	    0-3 in modes 2&3
	    0-7 in modes 0&1
	    0 in graphics modes
	DH = row (00h is top)
	DL = column (00h is left)
SeeAlso: AH=03h,AH=05h,INT 60/DI=030Bh
--------V-1003-------------------------------
INT 10 - VIDEO - GET CURSOR POSITION AND SIZE
	AH = 03h
	BH = page number
	    0-3 in modes 2&3
	    0-7 in modes 0&1
	    0 in graphics modes
Return: AX = 0000h (Phoenix BIOS)
	CH = start scan line
	CL = end scan line
	DH = row (00h is top)
	DL = column (00h is left)
Notes:	a separate cursor is maintained for each of up to 8 display pages
	many ROM BIOSes incorrectly return the default size for a color display
	  (start 06h, end 07h) when a monochrome display is attached
SeeAlso: AH=01h,AH=02h,AH=12h/BL=34h
--------V-1004-------------------------------
INT 10 - VIDEO - READ LIGHT PEN POSITION (except VGA)
	AH = 04h
Return: AH = light pen trigger flag
	    00h not down/triggered
	    01h down/triggered
		DH,DL = row,column of character light pen is on
		CH = pixel row (graphics modes 04h-06h)
		CX = pixel row (graphics modes with >200 rows)
		BX = pixel column
Desc:	determine the current position and status of the light pen (if
	  present)
Notes:	on a CGA, returned column numbers are always multiples of 2 (320-
	  column modes) or 4 (640-column modes)
	returned row numbers are only accurate to two lines
--------V-1005-------------------------------
INT 10 - VIDEO -  SELECT ACTIVE DISPLAY PAGE
	AH = 05h
	AL = new page number (00h to number of pages - 1) (see AH=00h)
Desc:	specify which of possibly multiple display pages will be visible
Note:	to determine whether the requested page actually exists, use AH=0Fh
	  to query the current page after making this call
SeeAlso: AH=0Fh,AH=43h,AH=45h
--------V-1005-------------------------------
INT 10 - VIDEO - PCjr - MANIPULATE CRT/CPU PAGE REGISTERS
	AH = 05h
	AL = subfunction
	    80h read CRT and CPU page registers
		Return: BH = CRT page register
			BL = CPU page register
	    81h set CPU page register
		BL = CPU page
	    82h set CRT page register
		BH = CRT page
	    83h set both CPU and CRT page registers
		BL = CPU page
		BH = CRT page
Notes:	the CPU page determines which 16K block of the first 128K of physical
	  memory will be mapped at B800h by the hardware
	the CRT page determines the start address of the memory used by the
	  video controller
--------V-1005-------------------------------
INT 10 - VIDEO - Corona/Cordata BIOS v4.10+ - GRAPHICS BITMAP BUFFER
	AH = 05h
	AL = function
	    00h set address of graphics bitmap buffer (video modes 60h,61h)
		BX = segment of buffer
	    0Fh get address of graphics bitmap buffer (video modes 60h,61h)
		Return: DX = segment of graphics bitmap buffer
--------V-1006-------------------------------
INT 10 - VIDEO - SCROLL UP WINDOW
	AH = 06h
	AL = number of lines by which to scroll up (00h = clear entire window)
	BH = attribute used to write blank lines at bottom of window
	CH,CL = row,column of window's upper left corner
	DH,DL = row,column of window's lower right corner
Note:	affects only the currently active page (see AH=05h)
Warning: some implementations have a bug which destroys BP
SeeAlso: AH=07h,AH=72h,AH=73h,AX=7F07h,INT 50/AX=0014h
--------V-1007-------------------------------
INT 10 - VIDEO - SCROLL DOWN WINDOW
	AH = 07h
	AL = number of lines by which to scroll down (00h=clear entire window)
	BH = attribute used to write blank lines at top of window
	CH,CL = row,column of window's upper left corner
	DH,DL = row,column of window's lower right corner
Note:	affects only the currently active page (see AH=05h)
Warning: some implementations have a bug which destroys BP
SeeAlso: AH=06h,AH=72h,AH=73h,INT 50/AX=0014h
--------V-1008-------------------------------
INT 10 - VIDEO - READ CHARACTER AND ATTRIBUTE AT CURSOR POSITION
	AH = 08h
	BH = page number (00h to number of pages - 1) (see AH=00h)
Return: AH = charater's attribute (see below)
	AL = character
Notes:	for monochrome displays, a foreground of 1 with background 0 is
	  underlined
	the blink bit may be reprogrammed to enable intense background colors
	  using AX=1003h or by programming the CRT controller
	the foreground intensity bit (3) can be programmed to switch between
	  character sets A and B on EGA and VGA cards, thus enabling 512
	  simultaneous characters on screen.  In this case the bit's usual
	  function (intensity) is regularly turned off.
SeeAlso: AH=09h,AX=1003h,AX=5001h

Bitfields for character's attribute:
 bit 7	blink
 bits 6-4  background color
		000 black	100 red
		001 blue	101 magenta
		010 green	110 brown
		011 cyan	111 white
 bits 3-0  foreground color
		0000 black	 1000 dark gray
		0001 blue	 1001 light blue
		0010 green	 1010 light green
		0011 cyan	 1011 light cyan
		0100 red	 1100 light red
		0101 magenta	 1101 light magenta
		0110 brown	 1110 yellow
		0111 light gray	 1111 white
--------V-1009-------------------------------
INT 10 - VIDEO - WRITE CHARACTER AND ATTRIBUTE AT CURSOR POSITION
	AH = 09h
	AL = character to display
	BH = page number (00h to number of pages - 1) (see AH=00h)
	BL = attribute (text mode) or color (graphics mode)
	     if bit 7 set in graphics mode, character is xor'ed onto screen
	CX = number of times to write character
Notes:	all characters are displayed, including CR, LF, and BS
	replication count in CX may produce an unpredictable result in graphics
	  modes if it is greater than the number of positions remaining in the
	  current row
SeeAlso: AH=08h,AH=0Ah,AH=4Bh"GRAFIX",INT 17/AH=60h,INT 1F,INT 43,INT 44
--------V-100A-------------------------------
INT 10 - VIDEO - WRITE CHARACTER ONLY AT CURSOR POSITION
	AH = 0Ah
	AL = character to display
	BH = page number (00h to number of pages - 1) (see AH=00h)
	BL = attribute (PCjr only) or color (graphics mode)
	     if bit 7 set in graphics mode, character is xor'ed onto screen
	CX = number of times to write character
Notes:	all characters are displayed, including CR, LF, and BS
	replication count in CX may produce an unpredictable result in graphics
	  modes if it is greater than the number of positions remaining in the
	  current row
SeeAlso: AH=08h,AH=09h,AH=4Bh,INT 17/AH=60h,INT 1F,INT 43,INT 44
--------V-100B--BH00-------------------------
INT 10 - VIDEO - SET BACKGROUND/BORDER COLOR
	AH = 0Bh
	BH = 00h
	BL = background/border color (border only in text modes)
SeeAlso: AH=0Bh/BH=01h
--------V-100B--BH01-------------------------
INT 10 - VIDEO - SET PALETTE
	AH = 0BH
	BH = 01h
	BL = palette ID
	    00h background, green, red, and brown/yellow
	    01h background, cyan, magenta, and white
SeeAlso: AH=0Bh/BH=00h
--------V-100C-------------------------------
INT 10 - VIDEO - WRITE GRAPHICS PIXEL
	AH = 0Ch
	BH = page number
	AL = pixel color (if bit 7 set, value is xor'ed onto screen)
	CX = column
	DX = row
Desc:	set a single pixel on the display in graphics modes
Notes:	valid only in graphics modes
	BH is ignored if the current video mode supports only one page
SeeAlso: AH=0Dh,AH=46h
--------V-100D-------------------------------
INT 10 - VIDEO - READ GRAPHICS PIXEL
	AH = 0Dh
	BH = page number
	CX = column
	DX = row
Return: AL = pixel color
Desc:	determine the current color of the specified pixel in grahics modes
Notes:	valid only in graphics modes
	BH is ignored if the current video mode supports only one page
SeeAlso: AH=0Ch,AH=47h
--------V-100E-------------------------------
INT 10 - VIDEO - TELETYPE OUTPUT
	AH = 0Eh
	AL = character to write
	BH = page number
	BL = foreground color (graphics modes only)
Desc:	display a character on the screen, advancing the cursor and scrolling
	  the screen as necessary
Notes:	characters 07h (BEL), 08h (BS), 0Ah (LF), and 0Dh (CR) are interpreted
	  and do the expected things
	IBM PC ROMs dated 4/24/81 and 10/19/81 require that BH be the same as
	  the current active page
SeeAlso: AH=02h,AH=0Ah
--------V-100F-------------------------------
INT 10 - VIDEO - GET CURRENT VIDEO MODE
	AH = 0Fh
Return: AH = number of character columns
	AL = display mode (see AH=00h)
	BH = active page (see AH=05h)
Notes:	if mode was set with bit 7 set ("no blanking"), the returned mode will
	  also have bit 7 set
	EGA, VGA, and UltraVision return either AL=03h (color) or AL=07h
	  (monochrome) in all extended-row text modes
SeeAlso: AH=00h,AH=05h,AX=10F2h/BL=00h,AX=1130h,AX=CD04h
--------V-100F56BX4756-----------------------
INT 10 - VUIMAGE DISPLAY DRIVER (v2.20 and below)
	AX = 0F56h
	BX = 4756h
	CX = 4944h
	DL = function
	    01h installation check
		Return: AX = 5649h
			BX = 4443h
			CX = 5647h
			DH = 01h
	    02h get first video mode's parameters
		Return: AX = BIOS mode number
			BX = width in pixels
			CX = height in pixels
			DX = number of colors
	    03h get next video mode's parameters
		Return: as for DL=02h
	    04h display line???
		ES:DI -> record (see below)
		???
		Return: ???
Program: VUIMAGE is a shareware GIF/TIFF image viewer by Offe Enterprises
Note:	the use of TSR display drivers was discontinued after v2.20
Index:	installation check;VUIMAGE display driver

Format of record for DL=04h:
Offset	Size	Description
 00h	WORD	row number
 02h	WORD	starting column???
 04h	WORD	ending column???
	???
--------V-100F--SIF123-----------------------
INT 10 - FRIEZE v7.41+ - INSTALLATION CHECK
	AH = 0Fh
	SI = F123h
	DI = 321Fh
Return: AH = number of character columns
	AL = display mode (see AH=00h)
	BH = active page (see AH=05h)
	SI = DI = F345h if installed
Notes:	if mode was set with bit 7 set ("no blanking"), the returned mode will
	  also have bit 7 set
	EGA, VGA, and UltraVision return either AL=03h (color) or AL=07h
	  (monochrome) in all extended-row text modes
SeeAlso: AH=0Fh"VIDEO",AH=4Bh"FRIEZE"
--------V-1010-------------------------------
INT 10 - BIOS Window Extension v1.1 - SET WINDOW COORDINATES
	AH = 10h
	CH,CL = row,column of upper left corner of window
	DH,DL = row,column of lower right corner of window
Return: AL = status
	    00h successful
	    01h failed
	AH destroyed
Program: BWE is a TSR by John J. Seal published in May 1986 Dr. Dobb's Journal
Note:	when a window has been set, all output via AH=0Eh is restricted to
	  the specified window
SeeAlso: AH=11h"Window",AH=12h"Window"
--------V-1010-------------------------------
INT 10 - VIDEO - Eagle PC2 BIOS Rev. C - SET SCROLL SPEED
	AH = 10h
	AL = speed
	    00h fast
	    01h slow (scrolling only moves characters during vertical retrace)
Return: AH = previous speed
--------V-101000-----------------------------
INT 10 - VIDEO - SET SINGLE PALETTE REGISTER (PCjr,EGA,MCGA,VGA)
	AX = 1000h
	BL = palette register number (00h-0Fh)
	   = attribute register number (undocumented)
	     10h attribute mode control register (should let BIOS control this)
	     11h overscan color register (see also AX=1001h)
	     12h color plane enable register (bits 3-0 enable corresponding
		text attribute bit)
	     13h horizontal PEL panning register
	     14h color select register
	BH = color or attribute register value
Notes:	on MCGA, only BX = 0712h is supported
	under UltraVision, the palette locking status (see AX=CD01h)
	  determines the outcome
SeeAlso: AX=1002h,AX=1007h,AX=CD01h
--------V-101001-----------------------------
INT 10 - VIDEO - SET BORDER (OVERSCAN) COLOR (PCjr,EGA,VGA)
	AX = 1001h
	BH = border color (00h-3Fh)
BUG:	the original IBM VGA BIOS incorrectly updates the parameter save area
	  and places the border color at offset 11h of the palette table
	  rather than offset 10h
Note:	under UltraVision, the palette locking status (see AX=CD01h)
	  determines the outcome
SeeAlso: AX=1002h,AX=1008h,AX=CD01h
--------V-101002-----------------------------
INT 10 - VIDEO - SET ALL PALETTE REGISTERS (PCjr,EGA,VGA)
	AX = 1002h
	ES:DX -> palette register list
Note:	under UltraVision, the palette locking status (see AX=CD01h)
	  determines the outcome
SeeAlso: AX=1000h,AX=1001h,AX=1009h,AX=CD01h

Format of palette register list:
Offset	Size	Description
 00h 16 BYTEs	colors for palette registers 00h through 0Fh
 10h	BYTE	border color
--------V-101003-----------------------------
INT 10 - VIDEO - TOGGLE INTENSITY/BLINKING BIT (Jr, PS, TANDY 1000, EGA, VGA)
	AX = 1003h
	BL = new state
	    00h background intensity enabled
	    01h blink enabled
	BH = 00h to avoid problems on some adapters
Notes:	although there is no function to get the current status on adapters
	  prior to the VGA, bit 5 of 0040h:0065h indicates the state; on the
	  VGA, use AH=1Bh and check offset 2Dh of the returned data
	when configured for a monochrome display, the Boca Research Multi-EGA
	  with ROM v M1.1 Type D has its screen disrupted if BH is not clear
SeeAlso: AH=08h,AH=1Bh
--------V-101007-----------------------------
INT 10 - VIDEO - GET INDIVIDUAL PALETTE REGISTER (VGA,UltraVision v2+)
	AX = 1007h
	BL = palette or attribute (undoc) register number (see AX=1000h)
Return: BH = palette or attribute register value
Note:	UltraVision v2+ supports this function even on color EGA systems in
	  video modes 00h-03h, 10h, and 12h; direct programming of the palette
	  registers will cause incorrect results because the EGA registers are
	  write-only.  To guard against older versions or unsupported video
	  modes, programs which expect to use this function on EGA systems
	  should set BH to FFh on entry.
SeeAlso: AX=1000h,AX=1009h
--------V-101008-----------------------------
INT 10 - VIDEO - READ OVERSCAN (BORDER COLOR) REGISTER (VGA,UltraVision v2+)
	AX = 1008h
Return: BH = border color (00h-3Fh)
Note:	(see AX=1007h)
SeeAlso: AX=1001h
--------V-101009-----------------------------
INT 10 - VIDEO - READ ALL PALETTE REGISTERS AND OVERSCAN REGISTER (VGA)
	AX = 1009h
	ES:DX -> 17-byte buffer (see AX=1002h)
Note:	UltraVision v2+ supports this function even on color EGA systems in
	  video modes 00h-03h, 10h, and 12h; direct programming of the palette
	  registers will cause incorrect results because the EGA registers are
	  write-only.  To guard against older versions or unsupported video
	  modes, programs which expect to use this function on EGA systems
	  should set the ES:DX buffer to FFh before calling.
SeeAlso: AX=1002h,AX=1007h,AX=CD02h
--------V-101010-----------------------------
INT 10 - VIDEO - SET INDIVIDUAL DAC REGISTER (VGA/MCGA)
	AX = 1010h
	BX = register number
	CH = new value for green (0-63)
	CL = new value for blue (0-63)
	DH = new value for red (0-63)
SeeAlso: AX=1012h,AX=1015h
--------V-101012-----------------------------
INT 10 - VIDEO - SET BLOCK OF DAC REGISTERS (VGA/MCGA)
	AX = 1012h
	BX = starting color register
	CX = number of registers to set
	ES:DX -> table of 3*CX bytes where each 3 byte group represents one
		 byte each of red, green and blue (0-63)
SeeAlso: AX=1010h,AX=1017h,INT 62/AX=00A5h
--------V-101013-----------------------------
INT 10 - VIDEO - SELECT VIDEO DAC COLOR PAGE (VGA)
	AX = 1013h
	BL = subfunction
	    00h select paging mode
		BH = 00h select 4 blocks of 64
		BH = 01h select 16 blocks of 16
	    01h select page
		BH = page number (00h to 03h) or (00h to 0Fh)
Note:	this function is not valid in mode 13h
SeeAlso: AX=101Ah
--------V-101015-----------------------------
INT 10 - VIDEO - READ INDIVIDUAL DAC REGISTER (VGA/MCGA)
	AX = 1015h
	BL = palette register number
Return: DH = red value
	CH = green value
	CL = blue value
SeeAlso: AX=1010h,AX=1017h
--------V-101017-----------------------------
INT 10 - VIDEO - READ BLOCK OF DAC REGISTERS (VGA/MCGA)
	AX = 1017h
	BX = starting palette register
	CX = number of palette registers to read
	ES:DX -> buffer (3 * CX bytes in size) (see also AX=1012h)
Return: buffer filled with CX red, green and blue triples
SeeAlso: AX=1012h,AX=1015h,INT 62/AX=00A4h
--------V-101018-----------------------------
INT 10 U - VIDEO - SET PEL MASK (VGA/MCGA)
	AX = 1018h
	BL = new PEL value
SeeAlso: AX=1019h
--------V-101019-----------------------------
INT 10 U - VIDEO - READ PEL MASK (VGA/MCGA)
	AX = 1019h
Return: BL = value read
SeeAlso: AX=1018h
--------V-10101A-----------------------------
INT 10 - VIDEO - GET VIDEO DAC COLOR-PAGE STATE (VGA)
	AX = 101Ah
Return: BL = paging mode
	    00h four pages of 64
	    01h sixteen pages of 16
	BH = current page
SeeAlso: AX=1013h
--------V-10101B-----------------------------
INT 10 - VIDEO - PERFORM GRAY-SCALE SUMMING (VGA/MCGA)
	AX = 101Bh
	BX = starting palette register
	CX = number of registers to convert
Desc:	convert the RGB values of one or more palette registers such that the
	  resulting values are grays with the same intensities as the original
	  colors
SeeAlso: AH=12h/BL=33h
--------V-1010E0-----------------------------
INT 10 - VIDEO - Diamond Speedstar 24 - SET 24-BIT GRAPHICS MODE
	AX = 10E0h
	BL = video mode (see also AH=00h)
	    2Eh = 640x480
Return: ???
SeeAlso: AH=00h,AX=10F0h
--------V-1010F0-----------------------------
INT 10 - VIDEO - Tseng ET-4000 BIOS - SET HiColor GRAPHICS MODE
	AX = 10F0h
	BL = video mode (see also AH=00h)
	    13h = 320x200x32K
	    2Dh = 640x350x32K
	    2Eh = 640x480x32K
	    2Fh = 640x400x32K
	    30h = 800x600x32K
	    3Eh = 640x480x16M (Genoa 7900)
	    FFh Tseng 24-bit color mode
		BH = mode
		    2Eh = 640x480x16M
Return: AL = 10h if supported
	AH = status
	    00h if successful
	    other on error
Desc:	switch the display into a graphics mode with 15 or more bits per pixel
Note:	the Tseng HiColor BIOS extensions are supported by:
	  Diamond Computer Systems	SpeedStar HiColor VGA
	  Everex Systems		HC VGA
	  Focus Information Systems	2theMax 4000
	  Cardinal Technologies		VGA732
	  Orchid ProDesigner IIs	Genoa 7900
SeeAlso: AH=00h,AX=10E0h,AX=10F1h,AX=10F2h
Index:	video modes
--------V-1010F1-----------------------------
INT 10 - VIDEO - Tseng ET-4000 BIOS - GET DAC TYPE
	AX = 10F1h
Return: AL = 10h if supported
	BL = type of digital/analog converter
	    00h normal VGA DAC
	    01h Sierra SC1148x HiColor DAC
	    02h new Sierra DAC
	   else other HiColor DAC
Desc:	determine which type of digital-to-analog converter is installed on the
	  display board
SeeAlso: AX=10F0h,AX=10F2h
--------V-1010F2BL00-------------------------
INT 10 u - VIDEO - Tseng ET-4000 BIOS - CHECK IF IN HiColor MODE
	AX = 10F2h
	BL = 00h
Return: AX = 0010h if supported
	BL = video mode type
	    00h normal
	    else HiColor mode
Desc:	determine whether the display is in a graphics mode with 15 or more
	  bits per pixel color resolution
SeeAlso: AH=0Fh,AX=10F0h,AX=10F1h
--------V-1011-------------------------------
INT 10 - BIOS Window Extension v1.1 - GET WINDOW COORDINATES
	AH = 11h
Return: CH,CL = row,column of upper left corner
	DH,DL = row,column of lower right corner
Desc:	determine the portion of the display to which output is restricted
Program: BWE is a TSR by John J. Seal published in May 1986 Dr. Dobb's Journal
SeeAlso: AH=10h"Window",AH=12h"Window"
--------V-1011-------------------------------
INT 10 - VIDEO - TEXT-MODE CHARACTER GENERATOR FUNCTIONS (PS, EGA, VGA)
	AH = 11h
	The following functions will cause a mode set, completely resetting
	the video environment, but without clearing the video buffer
	AL = 00h, 10h: load user-specified patterns
	    ES:BP -> user table
	    CX	  = count of patterns to store
	    DX	  = character offset into map 2 block
	    BL	  = block to load in map 2
	    BH	  = number of bytes per character pattern
	AL = 01h, 11h: load ROM monochrome patterns (8 by 14)
	    BL	  = block to load
	AL = 02h, 12h: load ROM 8 by 8 double-dot patterns
	    BL	  = block to load
	AL = 03h: set block specifier
	    BL	  = block specifier
		   (EGA/MCGA) bits 0,1 = block selected by chars with attribute
					 bit 3 = 0
			      bits 2,3 = block selected by chars with attribute
					 bit 3 = 1
		   (VGA) bits 0,1,4 = block selected by attribute bit 3 = 0
			 bits 2,3,5 = block selected by attribute bit 3 = 1
	AL = 04h, 14h: load ROM 8x16 character set (VGA)
	    BL	= block to load
Notes:	The routines called with AL=1xh are designed to be called only
	  immediately after a mode set and are similar to the routines called
	  with AL=0xh, except that:
	      Page 0 must be active.
	      Bytes/character is recalculated.
	      Max character rows is recalculated.
	      CRT buffer length is recalculated.
	      CRTC registers are reprogrammed as follows:
		     R09 = bytes/char-1 ; max scan line (mode 7 only)
		     R0A = bytes/char-2 ; cursor start
		     R0B = 0		; cursor end
		     R12 = ((rows+1)*(bytes/char))-1 ; vertical display end
		     R14 = bytes/char	; underline loc
			   (*** BUG: should be 1 less ***)
	the current block specifiers may be determined with INT 10/AH=1Bh,
	  looking at offsets 2Bh and 2Ch of the returned data (VGA only)
SeeAlso: AH=1Bh,AX=CD10h
--------V-1011-------------------------------
INT 10 - VIDEO - Realtek RTVGA - TEXT-MODE CHARACTER GENERATOR FUNCTIONS
	AH = 11h
	AL = 07h load user-specified paterns and recalculate mode parms
		 parameters are the same as for AL = 10h
	AL = 08h load monochrome patterns (8x14) and recalculate mode parms
		 parameters are the same as for AL = 11h
	AL = 09h load ROM 8 by 8 double-dot patterns and recalculate mode parms
		 parameters are the same as for AL = 12h
	AL = 0Bh load ROM 8x16 character set (VGA) and recalculate mode parms
		 parameters are the same as for AL = 14h
Note:	these functions should only be called under the same conditions as
	  AL=1xh (see entry above)
SeeAlso: AH=11h
--------V-10110F-----------------------------
INT 10 - VIDEO - Realtek RTVGA - SET USER 8x8 GRAPHICS CHARACTERS
	AX = 110Fh
	ES:BP -> user table for INT 1F
Note:	this function is meant to be called immediately after a mode set;
	  results are unpredictable at other times
SeeAlso: AX=1110h,AX=1111h,AX=1112h,AX=1120h
--------V-101110-----------------------------
INT 10 - VIDEO - Realtek RTVGA - SET USER GRAPHICS CHARACTERS
	AX = 1110h
	ES:BP -> user table
	CX = bytes per character
	BL = row specifier
	    00h user set
		DL = number of rows
	    01h 14 rows
	    02h 25 rows
	    03h 43 rows
Note:	this function is meant to be called immediately after a mode set;
	  results are unpredictable at other times
SeeAlso: AX=110Fh,AX=1112h,AX=1121h
--------V-101111-----------------------------
INT 10 - VIDEO - Realtek RTVGA - SET ROM 8x14 GRAPHICS CHARACTERS
	AX = 1111h
	BL = row specifier (see AX=1121h)
Note:	this function is meant to be called immediately after a mode set;
	  results are unpredictable at other times
SeeAlso: AX=110Fh,AX=1110h,AX=1122h
--------V-101112-----------------------------
INT 10 - VIDEO - Realtek RTVGA - SET ROM 8x8 DOUBLE-DOT CHARACTERS
	AX = 1112h
	BL = row specifier (see AX=1121h)
Note:	this function is meant to be called immediately after a mode set;
	  results are unpredictable at other times
SeeAlso: AX=110Fh,AX=1110h,AX=1111h,AX=1123h
--------V-101120-----------------------------
INT 10 - VIDEO - GRAPH-MODE CHARGEN - SET USER 8x8 GRAPHICS CHARS (PS,EGA,VGA)
	AX = 1120h
	ES:BP -> user table for INT 1F
Note:	this function is meant to be called immediately after a mode set;
	  results are unpredictable at other times
SeeAlso: AX=1121h,AX=1122h,AX=1123h,AX=1124h,AX=1125h,INT 1F,INT 43
--------V-101121-----------------------------
INT 10 - VIDEO - GRAPH-MODE CHARGEN - SET USER GRAPHICS CHARACTERS (PS,EGA,VGA)
	AX = 1121h
	ES:BP -> user table
	CX = bytes per character
	BL = row specifier
	    00h user set
		DL = number of rows
	    01h 14 rows
	    02h 25 rows
	    03h 43 rows
Note:	this function is meant to be called immediately after a mode set;
	  results are unpredictable at other times
SeeAlso: AX=1120h,AX=1122h,AX=1123h,AX=1124h,AX=1129h,INT 1F,INT 43
--------V-101122-----------------------------
INT 10 - VIDEO - GRAPH-MODE CHARGEN - SET ROM 8x14 GRAPHICS CHARS (PS,EGA,VGA)
	AX = 1122h
	BL = row specifier (see AX=1121h)
Notes:	this function is meant to be called immediately after a mode set;
	  results are unpredictable at other times
	UltraVision v2+ sets INT 43 to the appropriate font on this call
SeeAlso: AX=1111h,AX=1120h,AX=1121h,AX=1123h,AX=1124h,AX=1129h,INT 1F,INT 43
--------V-101123-----------------------------
INT 10 - VIDEO - GRAPH-MODE CHARGEN - SET ROM 8x8 DOUBLE-DOT CHARS (PS,EGA,VGA)
	AX = 1123h
	BL = row specifier (see AX=1121h)
Notes:	this function is meant to be called immediately after a mode set;
	  results are unpredictable at other times
	UltraVision v2+ sets INT 43 to the appropriate font on this call
SeeAlso: AX=1112h,AX=1120h,AX=1121h,AX=1122h,AX=1124h,AX=1129h,INT 1F,INT 43
--------V-101124-----------------------------
INT 10 - VIDEO - GRAPH-MODE CHARGEN - LOAD 8x16 GRAPHICS CHARS (VGA,MCGA)
	AX = 1124h
	BL = row specifier (see AX=1121h)
Notes:	this function is meant to be called immediately after a mode set;
	  results are unpredictable at other times
	UltraVision v2+ sets INT 43 to the appropriate font on this call
SeeAlso: AX=1120h,AX=1121h,AX=1122h,AX=1123h,AX=1129h,INT 1F,INT 43
--------V-101129-----------------------------
INT 10 - VIDEO - GRAPH-MODE CHARGEN - LOAD 8x16 GRAPH CHARS (Compaq Systempro)
	AX = 1129h
	BL = row specifier (see AX=1121h)
Notes:	this function is meant to be called immediately after a mode set;
	  results are unpredictable at other times
	UltraVision v2+ sets INT 43 to the appropriate font on this call
SeeAlso: AX=1120h,AX=1121h,AX=1122h,AX=1123h,AX=1124h,INT 1F, INT 43
--------V-101130-----------------------------
INT 10 - VIDEO - GET FONT INFORMATION (EGA, MCGA, VGA)
	AX = 1130h
	BH = pointer specifier
	    00h INT 1Fh pointer
	    01h INT 43h pointer
	    02h ROM 8x14 character font pointer
	    03h ROM 8x8 double dot font pointer
	    04h ROM 8x8 double dot font (high 128 characters)
	    05h ROM alpha alternate (9 by 14) pointer (EGA,VGA)
	    06h ROM 8x16 font (MCGA, VGA)
	    07h ROM alternate 9x16 font (VGA only)
	    11h (UltraVision v2+) 8x20 font (VGA) or 8x19 font (autosync EGA)
	    12h (UltraVision v2+) 8x10 font (VGA) or 8x11 font (autosync EGA)
Return: ES:BP = specified pointer
	CX    = bytes/character of on-screen font (not the requested font!)
	DL    = character rows on screen - 1 (VGA)
	      = character rows on screen (EGA)
Note:	for UltraVision v2+, the 9xN alternate fonts follow the corresponding
	  8xN font at ES:BP+256N
SeeAlso: AX=1100h,AX=1120h,INT 1F,INT 43

Format of alternate font table [array]:
Offset	Size	Description
 00h	BYTE	character to be replaced (00h = end of table)
 01h  N BYTEs	graphics data for character, one byte per scan line
--------V-101130BX4D4F-----------------------
INT 10 - M10_SCR.COM v3.5+ - INSTALLATION CHECK
	AX = 1130h
	BX = 4D4Fh
Return: CX = 4F4Dh if installed
	    ES:BP -> M10_SCR INT 10 handler
Program: M10_SCR is a shareware extended text mode and font driver by
	  I.V. Morozov
SeeAlso: INT 16/AX=4D4Fh
--------V-1012-------------------------------
INT 10 - BIOS Window Extension v1.1 - GET BLANKING ATTRIBUTE
	AH = 12h
Return: BH = attribute to use on blanked lines when scrolling
Program: BWE is a TSR by John J. Seal published in May 1986 Dr. Dobb's Journal
SeeAlso: AH=11h"Window",AH=12h"Window"
--------V-1012--BL10-------------------------
INT 10 - VIDEO - ALTERNATE FUNCTION SELECT (PS, EGA, VGA, MCGA) - GET EGA INFO
	AH = 12h
	BL = 10h
Return: BH = 00h color mode in effect (I/O port 3Dxh)
	     01h mono mode in effect (I/O port 3Bxh)
	BL = installed memory (00h = 64K, 01h = 128K, 02h = 192K, 03h = 256K)
	CH = feature bits
	CL = switch settings
	    bit 0: switch 1 OFF
	    bit 1: switch 2 OFF
	    bit 2: switch 3 OFF
	    bit 3: switch 4 OFF
	    bits 4-7: unused
Note:	one possible check for the presence of an EGA or later display card
	  is to call this function with BH=FFh; if not present, BH will be
	  unchanged on return
--------V-1012--BL11-------------------------
INT 10 - VIDEO - Trident TVGA 8800/8900/9000 BIOS - GET BIOS INFO
	AH = 12h
	BL = 11h
Return: AL = 12h if function supported
	    ES:BP -> BIOS info structure
SeeAlso: AH=12h/BL=12h"TRIDENT"

Format of Info structure:
Offset	Size	 Description
 00h	BYTE	 ??? (=0)
 01h	BYTE	 OEM Code (00h for original Trident)
 02h	WORD	 ID??? (1073h for 8800BR, 1074 for 8800CS)
 04h  8 BYTEs	 BIOS date ('mm/dd/yy')
 0Ch	WORD	 ???
 0Eh  8 BYTEs	 BIOS Version (' C3-128 ', ' C3-129 ')
--------V-1012--BL12-------------------------
INT 10 - VIDEO - Trident TVGA 8800/8900/9000 BIOS - GET VIDEO RAM SIZE
	AH = 12h
	BL = 12h
Return: AL = 12h if function supported
	    AH = number of 256K banks of RAM installed
SeeAlso: AH=12h/BL=11h"TRIDENT"
--------V-1012--BL20-------------------------
INT 10 - VIDEO - ALTERNATE FUNCTION SELECT (PS,EGA,VGA,MCGA) - ALTERNATE PRTSC
	AH = 12h
	BL = 20h  select alternate print screen routine
Desc:	installs a PrtSc routine from the video card's BIOS to replace the
	  default PrtSc handler from the ROM BIOS, which usually does not
	  understand screen heights other than 25 lines
Note:	some adapters disable print-screen instead of enhancing it
SeeAlso: INT 05
--------V-1012--BL2E-------------------------
INT 10 - Tseng ET-4000 BIOS v3.00 - BUG
	AH = 12h
	BL = 2Eh
Note:	due to an omitted end-of-list marker, this version of the BIOS will
	  crash the system on this function
--------V-1012--BL30-------------------------
INT 10 - VIDEO - ALTERNATE FUNCTION SELECT (VGA) - SELECT VERTICAL RESOLUTION
	AH = 12h
	BL = 30h
	AL = vertical resolution
	     00h 200 scan lines
	     01h 350 scan lines
	     02h 400 scan lines
Return: AL = 12h if function supported
Desc:	specify the number of scan lines used to display text modes
Note:	the specified resolution will take effect on the next mode set
SeeAlso: AH=00h
--------V-1012--BL31-------------------------
INT 10 - VIDEO - ALTERNATE FUNCTION SELECT (VGA, MCGA) - PALETTE LOADING
	AH = 12h
	BL = 31h
	AL = new state
	    00h enable default palette loading
	    01h disable default palette loading
Return: AL = 12h if function supported
Desc:	specify whether a default palette should be loaded when the display
	  mode is set
SeeAlso: AH=00h
--------V-1012--BL32-------------------------
INT 10 - VIDEO - ALTERNATE FUNCTION SELECT (VGA, MCGA) - VIDEO ADDRESSING
	AH = 12h
	BL = 32h
	AL = new state
	    00h enable video addressing
	    01h disable video addressing
Return: AL = 12h if function supported
Desc:	specify whether the CPU should have access to video memory and the
	  display adapters I/O registers
--------V-1012--BL33-------------------------
INT 10 - VIDEO - ALTERNATE FUNCTION SELECT (VGA, MCGA) - GRAY-SCALE SUMMING
	AH = 12h
	BL = 33h
	AL = new state
	    00h enable gray scale summing
	    01h disable gray scale summing
Return: AL = 12h if function supported
Desc:	specify whether or not colors should be converted to gray scale when
	  palette or color registers are loaded
SeeAlso: AX=101Bh,AX=BF06h,AX=BF08h
--------V-1012--BL34-------------------------
INT 10 - VIDEO - ALTERNATE FUNCTION SELECT (VGA) - CURSOR EMULATION
	AH = 12h
	BL = 34h
	AL = new state
	    00h enable alphanumeric cursor emulation
	    01h disable alphanumeric cursor emulation
Return: AL = 12h if function supported
Desc:	specify whether the BIOS should automatically remap cursor start/end
	  according to the current character height in text modes
SeeAlso: AH=01h,AH=03h
--------V-1012--BL35-------------------------
INT 10 - VIDEO - ALTERNATE FUNCTION SELECT (PS) - DISPLAY-SWITCH INTERFACE
	AH = 12h
	BL = 35h
	AL = subfunction
	    00h initial adapter video off
	    01h initial planar video on
	    02h switch active video off
	    03h switch inactive video on
	    80h *UNDOCUMENTED* set system board video active flag
	ES:DX -> buffer for 128 byte save area (if AL = 0, 2 or 3)
Return: AL = 12h if function supported
Desc:	switch between two video adapters which may otherwise have address
	  conflicts
--------V-1012--BL36-------------------------
INT 10 - VIDEO - ALTERNATE FUNCTION SELECT (PS, VGA) - VIDEO REFRESH CONTROL
	AH = 12h
	BL = 36h
	AL = new state
	    00h enable refresh
	    01h disable refresh
Return: AL = 12h if function supported
Desc:	specify whether the contents of video memory should be displayed on
	  the screen; disabling refresh effectively blanks the screen
SeeAlso: AX=BF05h
--------V-1012--BH55-------------------------
INT 10 - VIDEO - ALTERNATE FUNC SELECT (ATI,Tatung,Taxan) - ENHANCED FEATURES
	AH = 12h
	BH = 55h
	BL = subfunction
	    00h disable enhanced features
	    01h enable enhanced features
	    02h get status
		Return: AL = status flags (see below)
	    03h disable register trapping (CGA emulation)
	    04h enable register trapping
	    05h program video mode
		ES:BP -> video mode table (see below)
	    06h get mode table
		AL = video mode
		Return: ES:BP -> table suitable for mode AL (and subfnc BL=05h)
			BP = FFFFh on error
SeeAlso: AH=FFh"Oak"

Bitfields for status flags:
 bit 3	set if enhanced features enabled
 bits 7-5 monitor type
	000 PS/2 mono
	001 PS/2 color
	010 multi-sync
	011 Taxan 650 25kHz
	100 RGB
	101 mono
	110 EGA
	111 Compaq internal

Format of ATI VGA Wonder video mode table:
Offset	Size	Description
 00h	BYTE	number of columns
 01h	BYTE	maximum row (number of rows - 1)
 02h	BYTE	scan lines per row
 03h	WORD	video buffer size in bytes
 05h  4 BYTEs	values for Sequencer registers 1-4
 09h	BYTE	value for Miscellaneous Output register
 0Ah 25 BYTEs	values for CRTC registers 00h-18h
		00h horizontal total size (chars)
		01h horizontal displayed (chars)
		02h horizontal sync position (chars)
		03h horizontal sync width (chars)
		04h vertical total size (char rows)
		05h vertical total adjust (scan lines)
		06h vertical displayed (char rows)
		07h vertical sync position (char rows)
		08h interlace mode
		09h max scan line in row
		0Ah cursor start scan line
		0Bh cursor end scan line
		0Ch screen memory start (high)
		0Dh screen memory start (low)
		0Eh cursor address (high)
		0Fh cursor address (low)
		10h light pen (high)
		11h light pen (low)
 23h 20 BYTEs	default palette (values for Attribute Controller regs 00h-13h)
 37h  9 BYTEs	values for Graphics Controller registers 00h-08h
--------V-1012--BL74-------------------------
INT 10 - Tseng ET-4000 BIOS v3.00 - BUG
	AH = 12h
	BL = 74h
Note:	due to an omitted end-of-list marker, this version of the BIOS will
	  crash the system on this function
--------V-1012--BL80-------------------------
INT 10 - Tseng ET-4000 BIOS v3.00 - BUG
	AH = 12h
	BL = 80h
Note:	due to an omitted end-of-list marker, this version of the BIOS will
	  crash the system on this function
--------V-1012--BL80-------------------------
INT 10 - Cirrus Logic BIOS - INQUIRE VGA TYPE
	AH = 12h
	BL = 80h
Return: AX = controller type (see below)
	BL = silicon revision number (bit 7 set if not available)
SeeAlso: AH=12h/BL=81h,AH=12h/BL=82h,AH=12h/BL=85h,AH=12h/BL=9Ah,AH=12h/BL=A1h

Values for controller type:
 0000h	no extended alternate select support
 0002h	510/520
 0003h	610/620
 0004h	5320
 0005h	6410
 0006h	5410
 0007h	6420
 0008h	6412
 0010h	5401
 0011h	5402
 0012h	5420
 0013h	5422
 0014h	5424
 0015h	5426
 0016h	5420r1
 0017h	5402r1
 0018h	5428
 0020h	6205/15/25
 0030h	5432
 0031h	5434
--------V-1012--BL81-------------------------
INT 10 - Cirrus Logic BIOS - GET BIOS VERSION NUMBER
	AH = 12h
	BL = 81h
Return: AH = BIOS major version
	AL = BIOS minor version
SeeAlso: AH=12h/BL=80h,AH=12h/BL=82h
--------V-1012--BL82-------------------------
INT 10 - Cirrus Logic BIOS - GET DESIGN REVISION CODE
	AH = 12h
	BL = 82h
Return: AL = chip revision
SeeAlso: AH=12h/BL=80h,AH=12h/BL=81h
--------V-1012--BL85-------------------------
INT 10 - Cirrus Logic BIOS - GET INSTALLED MEMORY
	AH = 12h
	BL = 85h
Return: AL = number of 64K banks of video memory
SeeAlso: AH=12h/BL=80h,AH=12h,BL=93h
--------V-1012--BL93-------------------------
INT 10 - Cirrus Logic BIOS - FORCE 8-BIT OR 16-BIT OPERATION
	AH = 12h
	BL = 93h
	AL = new I/O width (00h = 16 bits, 01h = 8 bits)
SeeAlso: AH=12h/BL=9Ah
--------V-1012--BL9A-------------------------
INT 10 - Cirrus Logic BIOS - GET USER OPTIONS
	AH = 12h
	BL = 9Ah
Return: AX = options word 1 (see below)
	CX = options word 2 (see below)
SeeAlso: AH=12h/BL=80h,AH=12h/BL=93h,AH=12h/BL=A0h,AH=12h/BL=A3h,AH=12h/BL=A4h

Bitfields for options word 1:
 bits 0,1 reserved
 bits 2-4 monitor type
 bits 5-6 maximum vertical resolution
 bits 7-9 reserved
 bit 10	force 8-bit operation
 bits 11-13 reserved
 bit 14	vertical refresh frequency at 640x480
 bit 15	reserved

Bitfields for options word 2:
 bits 0-3 reserved
 bits 4-5 vertical refresh frequency at 1280x1024
 bits 6-10 reserved
 bits 11-12 vertical refresh frequency at 800x600
 bits 13-15 vertical refresh frequency at 1024x768
--------V-1012--BLA0-------------------------
INT 10 - Cirrus Logic BIOS - GET VIDEO MODE AVAILABILITY
	AH = 12h
	BL = A0h
	AL = video mode number (00h-7Fh)
Return: AH bit 0: video mode supported
	BX = offset of BIOS subroutine to fixup standard video parameters
		(call subroutine with DS:SI and ES:DI as returned by this call)
	DS:SI -> standard video parameters or FFFFh:FFFFh
	ES:DI -> supplemental video parameters or FFFFh:FFFFh
SeeAlso: AH=00h,AH=12h/BL=9Ah,AH=12h/BL=A1h
--------V-1012--BLA1-------------------------
INT 10 - Cirrus Logic BIOS - READ MONITOR TYPE AND ID FROM 15-PIN CONNECTOR
	AH = 12h
	BL = A1h
Return: BH = monitor ID (see below)
	BL = monitor type (00h color, 01h grayscale, 02h no display)
SeeAlso: AH=12h/BL=9Ah,AH=12h/BL=A2h

Values for monitor ID:
 00h-08h reserved
 09h	IBM 8604/8507 or equivalent
 0Ah	IBM 8514 or equivalent
 0Bh	IBM 8515 or equivalent
 0Dh	IBM 8503 or equivalent
 0Eh	IBM 8512/8513 or equivalent
 0Fh	no monitor
--------V-1012--BLA2-------------------------
INT 10 - Cirrus Logic BIOS - SET MONITOR HORIZONTAL RETRACE FREQUENCY
	AH = 12h
	BL = A2h
	AL = retrace rate
	    00h standard VGA (31.5 kHz)
	    01h 8514-compatible (31.5 kHz and 35.5 kHz interlaced)
	    02h SuperVGA (31.5-35.1 kHz)
	    03h extended SuperVGA (31.5-35.5 kHz)
	    04h multi-frequency (31.5-37.8 kHz)
	    05h extended multi-frequency (31.5-48.0 kHz)
	    06h super multi-frequency (31.5-56.0 kHz)
	    07h extended super multi-frequency (31.5-64.0 kHz)
SeeAlso: AH=12h/BL=9Ah,AH=12h/BL=A0h,AH=12h/BL=A4h
--------V-1012--BLA2-------------------------
INT 10 - Cirrus Logic BIOS - SET VGA REFRESH
	AH = 12h
	BL = A3h
	AL = refresh rate for 640x480 (00h normal, 01h high)
SeeAlso: AH=12h/BL=9Ah,AH=12h/BL=A4h
--------V-1012--BLA4-------------------------
INT 10 - Cirrus Logic BIOS - SET MONITOR TYPE
	AH = 12h
	BL = A4h
	AL bits 3-0 = maximum vertical resolution
		(0 = 480 scanlines, 1 = 600, 2 = 768, 3 = 1024, other reserved)
	AL bits 7-4 = vertical refresh at 640x480
		(0 = 60Hz, 1 = 72Hz, other reserved)
	BH bits 3-0 = vertical refresh at 800x600
		(0 = 56Kz, 1 = 60Hz, 2 = 72Hz, other reserved)
	BH bits 7-4 = vertical refresh at 1024x768
		(0=87Hz-int, 1=60Hz, 2=70Hz, 3=72Hz, 4=76Hz, other reserved)
	CH bits 4-7 = vertical refresh at 1280x1024
		(0=87Hz-int, 1=60Hz, 2=70Hz, other reserved)
SeeAlso: AH=12h/BL=9Ah,AH=12h/BL=A3h
--------V-1012--BLBE-------------------------
INT 10 - Tseng ET-4000 BIOS v3.00 - BUG
	AH = 12h
	BL = BEh
Note:	due to an omitted end-of-list marker, this version of the BIOS will
	  crash the system on this function
--------V-1012--BLC6-------------------------
INT 10 - Tseng ET-4000 BIOS v3.00 - BUG
	AH = 12h
	BL = C6h
Note:	due to an omitted end-of-list marker, this version of the BIOS will
	  crash the system on this function
--------V-1012--BLF0-------------------------
INT 10 - Tseng ET-4000 BIOS v3.00 - BUG
	AH = 12h
	BL = F0h
Note:	due to an omitted end-of-list marker, this version of the BIOS will
	  crash the system on this function
--------V-1013-------------------------------
INT 10 - VIDEO - WRITE STRING (AT and later,EGA)
	AH = 13h
	AL = write mode
	   bit 0: update cursor after writing
	   bit 1: string contains alternating characters and attributes
	BH = page number
	BL = attribute if string contains only characters
	CX = number of characters in string
	DH,DL = row,column at which to start writing
	ES:BP -> string to write
Notes:	recognizes CR, LF, BS, and bell
	also available PC or XT with EGA or higher
	HP 95LX only supports write mode 00h
BUG:	on the IBM VGA Adapter, any scrolling which may occur is performed on
	  the active page rather than the requested page
SeeAlso: AH=09h,AH=0Ah
--------V-101400-----------------------------
INT 10 - VIDEO - LOAD USER-SPECIFIED LCD CHARACTER FONT (CONV,Compaq Port 386)
	AX = 1400h
	ES:DI -> character font
	BH = number of bytes per character
	    08h or 10h (Compaq)
	BL = 00h load main font (block 0)
	     01h load alternate font (block 1)
	CX = number of characters to store
	DX = character offset into RAM font area
SeeAlso: AH=11h,AX=1401h
--------V-101401-----------------------------
INT 10 - VIDEO - LOAD SYSTEM ROM DEFAULT LCD CHARACTER FONT (CONV,CP386)
	AX = 1401h
	BL = font to load
	    00h main font (block 0)
	    01h alternate font (block 1)
SeeAlso: AH=11h,AX=1400h
--------V-101402-----------------------------
INT 10 - VIDEO - SET MAPPING OF LCD HIGH INTENSITY ATTRIBUTES (CONV,CP386)
	AX = 1402h
	BL = function
	    00h ignore high intensity attribute
	    01h map high intensity to underscore
	    02h map high intensity to reverse video
	    03h map high intensity to selected alternate font
	    B0h half intensity (Compaq)
	    B1h toggle active intensity bit interpretation (CP386)
--------V-1015-------------------------------
INT 10 - VIDEO - GET PHYSICAL DISPLAY PARAMETERS (CONVERTIBLE)
	AH = 15h
Return: AX = alternate display adapter type (see below)
	ES:DI -> parameter table (see below)
SeeAlso: AH=1Bh

Values for alternate display adapter type:
 0000h	none
 5140h	LCD
 5153h	CGA
 5151h	mono

Format of display parameter table:
Offset	Size	Description
 00h	WORD	monitor model number
 02h	WORD	vertical pixels per meter
 04h	WORD	horizontal pixels per meter
 06h	WORD	total vertical pixels
 08h	WORD	total horizontal pixels
 0Ah	WORD	horizontal pixel separation in micrometers
 0Ch	WORD	vertical pixel separation in micrometers
--------V-1015-------------------------------
INT 10 - VIDEO - SET SUPERIMPOSE MODE (Sperry PC)
	AH = 15h
	AL = superimpose mode
	    00h show graphics screen
	    01h show text screen
	    02h show text screen superimposed on graphics screen
--------V-101A00-----------------------------
INT 10 - VIDEO - GET DISPLAY COMBINATION CODE (PS,VGA/MCGA)
	AX = 1A00h
Return: AL = 1Ah if function was supported
	    BL = active display code (see below)
	    BH = alternate display code
SeeAlso: AH=12h/BH=35h,AX=1A01h,AH=1Bh

Values for display combination code:
 00h	no display
 01h	monochrome adapter w/ monochrome display
 02h	CGA w/ color display
 03h	reserved
 04h	EGA w/ color display
 05h	EGA w/ monochrome display
 06h	PGA w/ color display
 07h	VGA w/ monochrome analog display
 08h	VGA w/ color analog display
 09h	reserved
 0Ah	MCGA w/ digital color display
 0Bh	MCGA w/ monochrome analog display
 0Ch	MCGA w/ color analog display
 FFh	unknown display type
--------V-101A01-----------------------------
INT 10 - VIDEO - SET DISPLAY COMBINATION CODE (PS,VGA/MCGA)
	AX = 1A01h
	BL = active display code (see AX=1A00h)
	BH = alternate display code
Return: AL = 1Ah if function was supported
SeeAlso: AH=12h/BH=35h,AX=1A00h
--------V-101B-------------------------------
INT 10 - VIDEO - FUNCTIONALITY/STATE INFORMATION (PS,VGA/MCGA)
	AH = 1Bh
	BX = implementation type
	    0000h return funtionality/state information
	ES:DI -> 64-byte buffer for state information (see below)
Return: AL = 1Bh if function supported
	    ES:DI buffer filled with state information
BUG:	Trident 8900 (BIOS D3.0 11/12/91) and Trident 9000 (C3.0 10/25/91)
	  do not correctly set the fields at offsets 27h and 29h of the
	  state information
SeeAlso: AH=15h,AX=1A00h,AX=1F01h

Format of state information:
Offset	Size	Description
 00h	DWORD	address of static funtionality table (see below)
 04h	BYTE	video mode in effect
 05h	WORD	number of columns
 07h	WORD	length of regen buffer in bytes
 09h	WORD	starting address of regen buffer
 0Bh	WORD	cursor position for page 0
 0Dh	WORD	cursor position for page 1
 0Fh	WORD	cursor position for page 2
 11h	WORD	cursor position for page 3
 13h	WORD	cursor position for page 4
 15h	WORD	cursor position for page 5
 17h	WORD	cursor position for page 6
 19h	WORD	cursor position for page 7
 1Bh	WORD	cursor type
 1Dh	BYTE	active display page
 1Eh	WORD	CRTC port address
 20h	BYTE	current setting of register (3?8)
 21h	BYTE	current setting of register (3?9)
 22h	BYTE	number of rows
 23h	WORD	bytes/character
 25h	BYTE	display combination code of active display
 26h	BYTE	DCC of alternate display
 27h	WORD	number of colors supported in current mode
 29h	BYTE	number of pages supported in current mode
 2Ah	BYTE	number of scan lines active
		(0,1,2,3) = (200,350,400,480)
		Tseng ET3000: (4,5,6 = 512,600,768)
 2Bh	BYTE	primary character block
 2Ch	BYTE	secondary character block
 2Dh	BYTE	miscellaneous flags (see below)
 2Eh  3 BYTEs	reserved (00h)
 31h	BYTE	video memory available
		00h = 64K, 01h = 128K, 02h = 192K, 03h = 256K
 32h	BYTE	save pointer state flags (see below)
 33h 13 BYTEs	reserved (00h)

Bitfields for miscellaneous flags:
 bit 0	all modes on all displays on
 bit 1	gray summing on
 bit 2	monochrome display attached
 bit 3	default palette loading disabled
 bit 4	cursor emulation enabled
 bit 5	0 = intensity; 1 = blinking
 bit 6	PS/2 P70 plasma display (without 9-dot wide font) active
 bit 7	reserved

Bitfields for save pointer state flags:
 bit 0	512 character set active
 bit 1	dynamic save area present
 bit 2	alpha font override active
 bit 3	graphics font override active
 bit 4	palette override active
 bit 5	DCC override active
 bits 6-7 reserved

Format of Static Functionality Table:
Offset	Size	Description
 00h	BYTE	modes supported #1
		bit 0 to bit 7 = 1 modes 0,1,2,3,4,5,6 supported
 01h	BYTE	modes supported #2
		bit 0 to bit 7 = 1 modes 8,9,0Ah,0Bh,0Ch,0Dh,0Eh,0Fh supported
 02h	BYTE	modes supported #3
		bit 0 to bit 3 = 1 modes 10h,11h,12h,13h supported
		bit 4 to bit 7 reserved
 03h	BYTE	(IBM) reserved
		(Tseng ET3000/4000) modes supported #4
				bit 0 to bit 7 = modes 18h-1Fh supported
 04h	BYTE	(IBM) reserved
		(Tseng ET3000/4000) modes supported #5
				bit 0 to bit 7 = modes 20h-27h supported
 05h	BYTE	(IBM) reserved
		(Tseng ET3000/4000) modes supported #6
				bit 0 to bit 7 = modes 28h-2Fh supported
 06h	BYTE	(IBM) reserved
		(Tseng ET3000/4000) modes supported #7
				bit 0 to bit 7 = modes 30h-37h supported
 07h	BYTE	scan lines supported
		bit 0 to bit 2 = 1 if scan lines 200,350,400 supported
 08h	BYTE	total number of character blocks available in text modes
 09h	BYTE	maximum number of active character blocks in text modes
 0Ah	WORD	miscellaneous function support flags (see below)
 0Ch	WORD	reserved
 0Eh	BYTE	save pointer function flags (see below)
 0Fh	BYTE	reserved

Bitfields for miscellaneous function support flags:
 bit 0	all modes on all displays function supported
 bit 1	gray summing function supported
 bit 2	character font loading function supported
 bit 3	default palette loading enable/disable supported
 bit 4	cursor emulation function supported
 bit 5	EGA palette present
 bit 6	color palette present
 bit 7	color paging function supported
 bit 8	light pen supported
 bit 9	save/restore state function 1Ch supported
 bit 10 intensity blinking function supported
 bit 11 Display Combination Code supported
 bits 12-15 reserved

Bitfields for save pointer function flags:
 bit 0	512 character set supported
 bit 1	dynamic save area supported
 bit 2	alpha font override supported
 bit 3	graphics font override supported
 bit 4	palette override supported
 bit 5	DCC extension supported
 bits 6-7 reserved
--------V-101C-------------------------------
INT 10 - VIDEO - SAVE/RESTORE VIDEO STATE (PS50+,VGA)
	AH = 1Ch
	AL = function
	    00h return state buffer size
		Return: BX = number of 64-byte blocks needed
	    01h save video state
		ES:BX -> buffer
	    02h restore video state
		ES:BX -> buffer containing previously saved state
	CX = requested states
	     bit 0 video hardware
	     bit 1 BIOS data areas
	     bit 2 color registers and DAC state
	     bits 3-15 reserved
Return: AL = 1Ch if function supported
Notes:	many BIOSes corrupt the video registers when saving the state, so a
	  program should restore the state immediately after saving it (the
	  saved data is uncorrupted)
	the BIOS data area consists of the 96 bytes from 0040h:0049h-00A8h

Format of video hardware state:
Offset	Size	Description
 00h	BYTE	sequencer index register
 01h	BYTE	CRTC index register
 02h	BYTE	graphics controller index register
 03h	BYTE	attribute controller index register
 04h	BYTE	feature controller register
 05h  4 BYTEs	sequencer registers
 09h	BYTE	sequencer register 0
 0Ah 25 BYTEs	CRTC registers 0-8
 23h 16 BYTEs	palette registers 00h-0Fh
 33h  4 BYTEs	attribute registers 10h-13h
 37h  9 BYTEs	graphics controller registers 0-8
 40h	BYTE	CRTC base address (low)
 41h	BYTE	CRTC base address (high)
 42h	BYTE	plane 0 latch
 43h	BYTE	plane 1 latch
 44h	BYTE	plane 2 latch
 45h	BYTE	plane 3 latch

Format of DAC state:
Offset	Size	Description
 00h	BYTE	read/write mode DAC
 01h	BYTE	pixel address
 02h	BYTE	pixel mask
 03h 768 BYTEs	color data (256 triples)
303h	BYTE	color select register
--------V-101D-------------------------------
INT 10 - SpeedSTAR Plus BIOS v4.23+ - SET SYNC PARAMETERS
	AH = 1Dh
	AL = video mode
	ES = caller's segment
Return: nothing
Note:	the caller's segment contains at offset 5Ch (FCB field in PSP)
	  or 100h a table with sync parameters (BIOS looks at both offsets)

Format of sync table:
Offset	Size	Description
 00h  9 BYTEs	ID contains string 'ey5CENTER'
 09h  5 BYTEs	sync parameters for 640x480 modes 11h,12h,25h,26h,2Eh
 0Bh  5 BYTEs	sync parameters for 800x600 modes 29h,30h,2Ah
 13h  5 BYTEs	sync parameters for 1024x768 modes 37h,38h
--------V-101D-------------------------------
INT 10 - Tseng ET-4000 BIOS v3.00 - BUG
	AH = 1Dh
Note:	this version of the BIOS jumps to a random location on this function
	  due to a fencepost error
--------V-101F00-----------------------------
INT 10 - VIDEO - XGA - GET DMQS (Display Mode Query and Set) DATA LENGTH
	AX = 1F00h
Return: AL = 1Fh if supported
	    BX = number of bytes of DMQS data
Note:	not supported on the original IBM XGA, only on XGA-NI (non-interlaced)
	  and later models.
SeeAlso: AX=1F01h
--------V-101F01-----------------------------
INT 10 - VIDEO - XGA - READ DMQS DATA
	AX = 1F01h
	ES:DI -> user buffer for return data (call AX=1F00h for size)
Return: AL = 1Fh if function supported
	user buffer filled with DMQS data, see below.
Note:	not supported on the original IBM XGA, only on XGA-NI (non-interlaced)
	  and later models.
SeeAlso: AH=1Bh,AX=1F00h,AX=3000h

Format of DMQS buffer:
Offset	Size	Description
 00h	WORD	offset (in bytes) to DMQS data for next XGA instance
 02h	BYTE	slot number
 03h	BYTE	XGA implementation function level identifier
 04h	BYTE	XGA implementation resolution level identifier
 05h	WORD	vendor identifier - identifies card vendor
 07h	WORD	vendor defined field
 09h	WORD	XGA adapter I/O register base address
 0Bh	WORD	XGA coprocessor register base address
		(paragraph--multiply by 10h to get physical address)
 0Dh	WORD	1 Megabyte system video memory aperture
		0000h if not allocated
		(Multiply by 100000h to get physical address)
 0Fh	WORD	4 Megabyte system video memory aperture
		0000h if not allocated
		(multiply by 100000h to get physical address)
 11h	WORD	video memory base address
		(multiply by 100000h to get physical address)
 13h	WORD	composite ID of the attached display
 15h	BYTE	amount of video memory available, in multiples of 256K bytes
 16h	DWORD	alternate XGA coprocessor register base address.  0 = none.
 1Ah	var	DMQS Data for further XGA Instances (as above)
Note:	"Instances" refers to the capability of having up to 8 XGA
	  adapters in one computer.
--------V-103000CX0000-----------------------
INT 10 - VIDEO - LOCATE 3270PC CONFIGURATION TABLE (INSTALLATION CHECK)
	AX = 3000h
	CX = 0000h
	DX = 0000h
Return: CX:DX -> 3270PC configuration table (see below)
	CX:DX = 0000h:0000h if 3270PC Control Program not active
SeeAlso: AX=1F01h

Format of 3270 PC configuration table:
Offset	Size	Description
 00h	BYTE	aspect ratio X
 01h	BYTE	aspect ratio Y
 02h	BYTE	monitor type (see below)
 03h	BYTE	reserved
 04h	BYTE	adapter ID
		00h = 5151/5272 adapter
		04h = 5151/5272 with XGA adapter
		30h = 3295 or 3270PC G/GX adapter
 05h	BYTE	reserved
 06h	BYTE	function flags 1 (see below)
 07h	BYTE	function flags 2
		bit 6: GPI graphics supported
 08h	WORD	segment address of Control Program Level table (see below)
 0Ah 10 BYTEs	reserved

Values for monitor type:
 00h	5151 (mono) or 5272 (color)
 01h	3295
 02h	5151 or 5272 with XGA (???) graphics adapter
 03h	5279 with 3270PC G adapter
 04h	5379 model C01 with 3270PC GX adapter
 05h	5379 model M01 with 3270PC GX adapter
 07h	non-3270PC with 3270 Workstation Program
 FFh	3270PC Control Program not loaded

Bitfields for function flags 1:
 bit 7	mono text, 1 page
 bit 6	color text, 1 page
 bit 5	color text, 4 pages
 bit 4	CGA color graphics
 bit 3	720x350 two-color graphics
 bit 2	360x350 four-color graphics
 bit 1	720x350 eight-color graphics

Format of Control Program Level table:
Offset	Size	Description
 00h	WORD	program version
		02xxh = 3270PC Control Program v2.xx
		03xxh = 3270PC Control Program v3.xx
		04xxh = 3270 Workstation Program v1.xx
 02h	BYTE	Control Program ID (00h)
 03h 27 BYTEs	Control Program Descriptor ("IBM 3270 PC CONTROL PROGRAM")
--------a-103800-----------------------------
INT 10 - Tinytalk Personal v1.09f+ - GET CONFIGURATION INFO
	AX = 3800h
Return: ES:DI -> configuration info (see below)
Program: Tinytalk is a shareware screen reader by OMS Development/Eric Bohlman
Notes:	this call is also used as the installation check by verifying that the
	  returned ES:DI points at valid configuration info
	Tinytalk v1.09f ignores AL and always returns the configuration info;
	  v1.10 adds several subfunctions selected with AL
SeeAlso: AX=3801h,AX=3803h,AX=3806h,AH=39h,INT 14/AX=F0F1h
SeeAlso: INT 2F/FB00h"AutoBraille"
Index:	installation check;Tinytalk Personal

Format of configuration info:
Offset	Size	Description
 00h  8 BYTEs	signature "TTCONFIG"
 08h	WORD	size of configuration data, not counting signature, this WORD,
		or the following byte
 0Ah	BYTE	???
 0Bh	???	configuration data
--------a-103801-----------------------------
INT 10 - Tinytalk Personal v1.10 - ???
	AX = 3801h
	DL = ???
Return: ???
SeeAlso: AX=3800h,AX=3802h
--------a-103802-----------------------------
INT 10 - Tinytalk Personal v1.10 - ???
	AX = 3802h
	DL = ???
Return: ???
SeeAlso: AX=3800h,AX=3801h
--------a-103803-----------------------------
INT 10 - Tinytalk Personal v1.10 - GET ???
	AX = 3803h
Return: AL = ???
SeeAlso: AX=3800h,AX=3804h,AX=3805h
--------a-103804-----------------------------
INT 10 - Tinytalk Personal v1.10 - GET ???
	AX = 3804h
Return: AX = ???
SeeAlso: AX=3800h,AX=3803h,AX=3805h
--------a-103805-----------------------------
INT 10 - Tinytalk Personal v1.10 - GET ???
	AX = 3805h
Return: AL = ???
SeeAlso: AX=3800h,AX=3803h,AX=3804h
--------a-103806-----------------------------
INT 10 - Tinytalk Personal v1.10 - ???
	AX = 3806h
	ES:DX -> ASCIZ ???
Return: ???
SeeAlso: AX=3800h
--------a-1039-------------------------------
INT 10 - Tinytalk Personal v1.10 - ???
	AH = 39h
Program: Tinytalk is a shareware screen reader by OMS Development/Eric Bohlman
Note:	this function was a NOP in TTDEMO.EXE, but may be implemented in other
	  variants of Tinytalk
--------V-1040-------------------------------
INT 10 - VIDEO - SET GRAPHICS MODE (Hercules GRAFIX)
	AH = 40h
Desc:	switch the Hercules Graphics Card into graphics mode (720x348)
SeeAlso: AH=00h,AH=41h
Index:	video modes
--------V-1041-------------------------------
INT 10 - VIDEO - SET TEXT MODE (Hercules GRAFIX)
	AH = 41h
Desc:	switch the Hercules Graphics Card into text mode
SeeAlso: AH=00h,AH=40h
Index:	video modes
--------V-1042-------------------------------
INT 10 - VIDEO - CLEAR CURRENT PAGE (Hercules GRAFIX)
	AH = 42h
SeeAlso: AH=45h
--------V-1043-------------------------------
INT 10 - VIDEO - SELECT DRAWING PAGE (Hercules GRAFIX)
	AH = 43h
	AL = page number (0,1)
Desc:	specify which of the two pages of video memory is to be used for
	  output
SeeAlso: AH=05h,AH=44h,AH=45h
--------V-1044-------------------------------
INT 10 - VIDEO - SELECT DRAWING FUNCTION (Hercules GRAFIX)
	AH = 44h
	AL = drawing function
	    00h clear pixels
	    01h set pixels
	    02h invert pixels
Desc:	specify how graphics output will change the display
SeeAlso: AH=45h,AH=46h,AH=4Ch,AH=4Dh
--------V-1045-------------------------------
INT 10 - VIDEO - SELECT PAGE TO DISPLAY (Hercules GRAFIX)
	AH = 45h
	AL = page number (0,1)
Desc:	specify which of the two pages of video memory is visible on screen
SeeAlso: AH=05h,AH=42h,AH=43h
--------V-1046-------------------------------
INT 10 - VIDEO - DRAW ONE PIXEL (Hercules GRAFIX)
	AH = 46h
	DI = x (0-720)
	BP = y (0-347)
Note:	function 44h determines operation and function 43h which page to use
SeeAlso: AH=0Ch,AH=47h,AH=49h,AH=4Ch,AH=4Dh
--------V-1047-------------------------------
INT 10 - VIDEO - FIND PIXEL VALUE (Hercules GRAFIX)
	AH = 47h
	DI = x (0-720)
	BP = y (0-347)
Return: AL = 00h pixel clear
	AL = 01h pixel set
Note:	function 43h specifies which page is used
SeeAlso: AH=0Dh,AH=46h
--------V-1048-------------------------------
INT 10 - VIDEO - MOVE TO POINT (Hercules GRAFIX)
	AH = 48h
	DI = x (0-720)
	BP = y (0-347)
Desc:	specify the location from which to start the next graphics output
SeeAlso: AH=49h
--------V-1049-------------------------------
INT 10 - VIDEO - DRAW TO POINT (Hercules GRAFIX)
	AH = 49h
	DI = x (0-720)
	BP = y (0-347)
Note:	function 48h or 49h specify first point, 44h operation and 43h page to
	  use
SeeAlso: AH=43h,AH=44h,AH=48h,AH=4Ch,AH=4Dh
--------V-104A-------------------------------
INT 10 - VIDEO - BLOCK FILL (Hercules GRAFIX)
	AH = 4Ah
	DI = x coordinate of lower left corner
	BP = y coordinate of lower left corner
	BX = height in pixels
	CX = width in pixels
Desc:	draw a solid rectangle of the specified size at the given location
SeeAlso: AH=4Eh
--------V-104B-------------------------------
INT 10 - VIDEO - DISPLAY CHARACTER (Hercules GRAFIX)
	AH = 4Bh
	AL = character to display
	DI = x (0-720)
	BP = y (0-347)
Note:	unlike the other BIOS character functions character position is
	  specified in pixels rather than rows and columns
SeeAlso: AH=09h,AH=0Ah
----------104B-------------------------------
INT 10 - FRIEZE - API
	AH = 4Bh
	CL = function
	    00h (v6.x-) print window
		AL = mode
		    00h character
		    01h normal
		    02h sideways
	    01h load window
		ES:BX -> ASCIZ filename from which to read
	    02h save window
		ES:BX -> ASCIZ filename to which to write
	    03h set print width
		AL = width in 1/4 inches
	    04h set print height
		AL = height in 1/4 inches
	    05h reserved
	    06h set left margin
		AL = printout margin in 1/4 inches
	    07h set window size
		ES:BX -> four-WORD structure with Xmin, Ymin, Xmax, Ymax
	    08h reserved
	    09h set patterns
		ES:BX -> 16-BYTE vector of screen->printer color correspondnces
	    0Ah get patterns
		ES:BX -> 16-BYTE buffer for color correspondences
	    0Bh set mode
		AL = mode
	    0Ch (v7.41) ???
		AL = ???
		    00h ??? (calls original INT 05)
		    else ???
	    0Dh (v7.41) ???
		AL = ???
		    00h ??? (calls original INT 05)
		    else ???
	    0Eh (v7.41) ???
		???
	    0Fh get window
		ES:BX -> four-WORD buffer for Xmin, Ymin, Xmax, Ymax
	    10h set print options
		ES:BX -> printer options in same format as FRIEZE cmdline
	    11h initialize
		ES:BX -> three-WORD array from CARDS.DAT for HRes, VRes, code
	    12h (v7.41) ???
		???
	    13h (v7.41) ???
		???
	    14h get version
		Return: AH = major version (00h if FRIEZE version before 7)
			AL = minor version
	    15h set parameters
		ES:BX -> parameter table (see below)
	    16h get parameters
		ES:BX -> buffer for parameter table (see below)
	    17h get printer resolution
		ES:BX -> 12-WORD table for six horizontal/vertical resol pairs
	    18h (v8.0 only) reserved
	    50h (v7.41) get ???
		Return: AX = ???
	    51h (v7.41) get ???
		Return: ES = ??? (seen 2348h)
			AX = ??? (seen 8432h)
Return: AX = status (see below)
SeeAlso: AH=0Fh/SI=F123h

Values for status:
 00h	successful
 01h	user aborted printout with ESC
 02h	reserved
 03h	file read error
 04h	file write error or printer error
 05h	file not found
 06h	invalid header (not an image or wrong screen mode) or can't create file
 07h	file close error
 08h	disk error
 09h	(v7.0+) printer error
 0Ah	invalid function
 0Bh	(v7.0+) can't create file
 0Ch	(v7.0+) wrong video mode

Format of parameter table:
Offset	Size	Description
 00h	WORD	top margin (1/100 inch)
 02h	WORD	left margin (1/100 inch)
 04h	WORD	horizontal size (1/100 inch)
 06h	WORD	vertical size (1/100 inch)
 08h	WORD	quality/draft mode
		00h draft mode
		01h quality mode
		02h use horizontal/vertical resolution for output resolution
 0Ah	WORD	printer horizontal resolution (dots per inch)
 0Ch	WORD	printer vertical resolution (dots per inch)
 0Eh	WORD	reserved (FFFFh)
Note:	any field which should remain unchanged may be filled with FFFFh
--------V-104C-------------------------------
INT 10 - VIDEO - DRAW ARC (Hercules GRAFIX)
	AH = 4Ch
	AL = quadrant (1 = upper right, 2 = upper left, etc)
	DI = x coordinate of center
	BP = y coordinate of center
	BX = radius
SeeAlso: AH=49h,AH=4Dh
--------V-104D-------------------------------
INT 10 - VIDEO - DRAW CIRCLE (Hercules GRAFIX)
	AH = 4Dh
	DI = x of center
	BP = y of center
	BX = radius
SeeAlso: AH=49h,AH=4Ch
--------V-104E-------------------------------
INT 10 - VIDEO - FILL AREA (Hercules GRAFIX)
	AH = 4Eh
	DI = x coordinate of an interior point
	BP = y coordinate of an interior point
Desc:	fill a convex polygonal area bounded by a contiguous line of the
	  opposite color with the border color
Note:	the first fill makes the figure solid, the second erases it
SeeAlso: AH=4Ah
--------V-104F00-----------------------------
INT 10 - VESA SuperVGA BIOS - GET SuperVGA INFORMATION
	AX = 4F00h
	ES:DI -> 256-byte buffer for SuperVGA information (see below)
Return: AL = 4Fh function supported
	AH = status
	    00h successful
		ES:DI buffer filled
	    01h failed
Desc:	determine whether VESA BIOS extensions are present and the capabilities
	  supported by the display adapter
SeeAlso: AX=4F01h,AX=7F00h
Index:	installation check;VESA

Format of SuperVGA information:
Offset	Size	Description
 00h  4 BYTEs	signature ('VESA')
 04h	WORD	VESA version number
 06h	DWORD	pointer to OEM name
		"761295520" for ATI
 0Ah  4 BYTEs	capabilities
 0Eh	DWORD	pointer to list of supported VESA and OEM video modes
		(list of words terminated with FFFFh)
 12h 238 BYTEs	reserved
Note:	the list of supported video modes is stored in the reserved portion of
	  the SuperVGA information record by some implementations, and it may
	  thus be necessary to either copy the mode list or use a different
	  buffer for all subsequent VESA calls
--------V-104F01-----------------------------
INT 10 - VESA SuperVGA BIOS - GET SuperVGA MODE INFORMATION
	AX = 4F01h
	CX = SuperVGA video mode
	ES:DI -> 256-byte buffer for mode information (see below)
Return: AL = 4Fh function supported
	AH = status
	    00h successful
		ES:DI buffer filled
	    01h failed
Desc:	determine the attributes of the specified video mode
SeeAlso: AX=4F00h,AX=4F02h

Format of mode information:
Offset	Size	Description
 00h	WORD	mode attributes
		bit 0: mode supported
		bit 1: optional information available
		bit 2: BIOS output supported
		bit 3: set if color, clear if monochrome
		bit 4: set if graphics mode, clear if text mode
 02h	BYTE	window A attributes
		bit 0: exists
		bit 1: readable
		bit 2: writable
		bits 3-7 reserved
 03h	BYTE	window B attributes (as for window A)
 04h	WORD	window granularity in KB
 06h	WORD	window size in KB
 08h	WORD	start segment of window A
 0Ah	WORD	start segment of window B
 0Ch	DWORD	-> FAR window positioning function (equivalent to AX=4F05h)
 10h	WORD	bytes per scan line
---remainder is optional for VESA modes in v1.0/1.1, needed for OEM modes---
 12h	WORD	width in pixels
 14h	WORD	height in pixels
 16h	BYTE	width of character cell in pixels
 17h	BYTE	height of character cell in pixels
 18h	BYTE	number of memory planes
 19h	BYTE	number of bits per pixel
 1Ah	BYTE	number of banks
 1Bh	BYTE	memory model type (see below)
 1Ch	BYTE	size of bank in KB
 1Dh	BYTE	number of image pages
 1Eh	BYTE	reserved (0)
---VBE v1.2+---
 1Fh	BYTE	red mask size
 20h	BYTE	red field position
 21h	BYTE	green mask size
 22h	BYTE	green field size
 23h	BYTE	blue mask size
 24h	BYTE	blue field size
 25h	BYTE	reserved mask size
 26h	BYTE	reserved mask position
 27h	BYTE	direct color mode info
 28h	BYTE	reserved (0)

Values for memory model type:
 00h	text
 01h	CGA graphics
 02h	HGC graphics
 03h	16-color (EGA) graphics
 04h	packed pixel graphics
 05h	"sequ 256" (non-chain 4) graphics
 06h	direct color (HiColor, 24-bit color)
 07h	YUV (luminance-chrominance, also called YIQ)
 08h-0Fh reserved for VESA
 10h-FFh OEM memory models
--------V-104F02-----------------------------
INT 10 - VESA SuperVGA BIOS - SET SuperVGA VIDEO MODE
	AX = 4F02h
	BX = mode
		bit 15 set means don't clear video memory
Return: AL = 4Fh function supported
	AH = status
	    00h successful
	    01h failed
SeeAlso: AX=4F01h,AX=4F03h

Values for VESA video mode:
 00h-FFh OEM video modes (see AH=00h)
 100h	640x400x256
 101h	640x480x256
 102h	800x600x16
 103h	800x600x256
 104h	1024x768x16
 105h	1024x768x256
 106h	1280x1024x16
 107h	1280x1024x256
 108h	80x60 text
 109h	132x25 text
 10Ah	132x43 text
 10Bh	132x50 text
 10Ch	132x60 text
---VBE v1.2---
 10Dh	320x200x32K
 10Eh	320x200x64K
 10Fh	320x200x16M
 110h	640x480x32K
 111h	640x480x64K
 112h	640x480x16M
 113h	800x600x32K
 114h	800x600x64K
 115h	800x600x16M
 116h	1024x768x32K
 117h	1024x768x64K
 118h	1024x768x16M
 119h	1280x1024x32K
 11Ah	1280x1024x64K
 11Bh	1280x1024x16M
Index:	video modes

Values for S3 OEM video mode:
 201h	640x480x256
 202h	800x600x16
 203h	800x600x256
 204h	1024x768x16
 205h	1024x768x256
 206h	1280x960x16
 208h	1280x1024x16
 301h	640x480x32K
Index:	video modes
--------V-104F03-----------------------------
INT 10 - VESA SuperVGA BIOS - GET CURRENT VIDEO MODE
	AX = 4F03h
Return: AL = 4Fh function supported
	AH = status
	    00h successful
	    01h failed
	BX = video mode (see AX=4F02h)
SeeAlso: AX=4F02h
--------V-104F04-----------------------------
INT 10 - VESA SuperVGA BIOS - SAVE/RESTORE SuperVGA VIDEO STATE
	AX = 4F04h
	DL = subfunction
	    00h get state buffer size
		Return: BX = number of 64-byte blocks needed
	    01h save video states
		ES:BX -> buffer
	    02h restore video states
		ES:BX -> buffer
	CX = flags for states to save/restore
	    bit 0: video hardware state
	    bit 1: video BIOS data state
	    bit 2: video DAC state
	    bit 3: SuperVGA state
Return: AL = 4Fh function supported
	AH = status
	    00h successful
	    01h failed
--------V-104F05-----------------------------
INT 10 - VESA SuperVGA BIOS - CPU VIDEO MEMORY CONTROL
	AX = 4F05h
	BH = subfunction
	    00h select video memory window
		DX = window address in video memory (in granularity units)
	    01h get video memory window
		Return: DX = window address in video memory (in gran. units)
	BL = window number
	    00h window A
	    01h window B
Return: AL = 4Fh function supported
	AH = status
	    00h successful
	    01h failed
SeeAlso: AX=4F01h,AX=4F06h,AX=4F07h,AX=7000h/BX=0004h
--------V-104F06-----------------------------
INT 10 - VESA SuperVGA BIOS v1.1+ - GET/SET LOGICAL SCAN LINE LENGTH
	AX = 4F06h
	BL = function
	    00h set scan line length
		CX = desired width in pixels
	    01h get scan line length
Return: AL = 4Fh if function supported
	AH = status
	    00h successful
	    01h failed
	BX = bytes per scan line
	CX = number of pixels per scan line
	DX = maximum number of scan lines
Notes:	if the desired width is not achievable, the next larger width will be
	  set
	the scan line may be wider than the visible area of the screen
	this function is valid in text modes, provided that values are
	  multiplied by the character cell width/height
SeeAlso: AX=4F01h,AX=4F05h,AX=4F07h
--------V-104F07BH00-------------------------
INT 10 - VESA SuperVGA BIOS v1.1+ - GET/SET DISPLAY START
	AX = 4F07h
	BH = 00h (reserved)
	BL = function
	    00h set display start
		CX = leftmost displayed pixel in scan line
		DX = first displayed scan line
	    01h get display start
		Return: BH = 00h
			CX = leftmost displayed pixel in scan line
			DX = first displayed scan line
Return: AL = 4Fh if function supported
	AH = status
	    00h successful
	    01h failed
Note:	this function is valid in text modes, provided that values are
	  multiplied by the character cell width/height
SeeAlso: AX=4F01h,AX=4F05h,AX=4F06h
--------V-104F08-----------------------------
INT 10 - VESA SuperVGA BIOS v1.2+ - GET/SET DAC PALETTE CONTROL
	AX = 4F08h
	BL = function
	    00h set DAC palette width
		BH = desired number of bits per primary color
	    01h get DAC palette width
Return: AL = 4Fh if function supported
	AH = status
	BH = current number of bits per primary (06h = standard VGA)
--------V-104FFF-----------------------------
INT 10 - VESA SuperVGA BIOS - Everex - TURN VESA ON/OFF
	AX = 4FFFh
	DL = new state (00h off, 01h on)
Return: AX = 0000h if successful
--------U-1050-------------------------------
INT 10 - SCROLOCK.COM - INSTALLATION CHECK
	AH = 50h
Return: BX = 1954h if installed
	    AL = 00h if inactive, nonzero if active
Program: SCROLOCK is a utility supplied with System Enhancement Associates' ARC
SeeAlso: AH=51h
--------J-105000-----------------------------
INT 10 - VIDEO - AX PC - SET SCREEN COUNTRY CODE
	AX = 5000h
	BX = country code
	    0001h USA (English), 0051h Japan
Return: AL = status
	    00h successful
	    01h bad country code
	    02h other error
SeeAlso: AX=5001h,INT 16/AX=5000h
--------J-105001-----------------------------
INT 10 - VIDEO - AX PC - GET SCREEN COUNTRY CODE
	AX = 5001h
Return: AL = status
	    00h successful
		BX = country code
	    02h error
SeeAlso: AH=00h,AX=5000h,INT 16/AX=5001h,INT 21/AH=38h
--------V-105049-----------------------------
INT 10 - VIDEO - SCREENR v1.55+ - API
	AX = 5049h ('PI')
	BX = function
	    0000h installation check
	    0001h lock mode
	    0002h unlock mode
	    0003h lock palette
	    0004h unlock palette
Return: AX = 0000h if installed
	    BX = TSR version (BH=major,BL=minor)
	    CL = mode locking status
		00h mode not locked
		01h mode locked: INT 10/AH=00h disabled
	    CH = palette locking status
		00h palette not locked
		01h palette locked, the following functions are disabled:
			AX=1000h, AX=1001h, AX=1002h, AX=1010h, AX=1012h
Program: SCREENR is a TSR supplied with Patrick Ibbetson's SCREEN display
	  utility.
Index:	installation check;SCREENR
--------U-1051-------------------------------
INT 10 - SCROLOCK.COM - ENABLE/DISABLE
	AH = 51h
	AL = state
	    00h disable
	    nonzero enable
Program: SCROLOCK is a utility supplied with System Enhancement Associates' ARC
SeeAlso: AH=50h"SCROLOCK"
--------J-105100-----------------------------
INT 10 - VIDEO - AX PC - REGISTER EXTERNAL CHARACTER
	AX = 5100h
	BH = character width in bits (10h)
	BL = character height (10h)
	DX = character code (DH = F0h-F3h, DL=40h-7Eh,80h-FCh)
	ES:BP -> character bitmap
Return: AL = status (00h successful, 01h failed)
SeeAlso: AX=5101h,INT 1F
--------J-105101-----------------------------
INT 10 - VIDEO - AX PC - READ CHARACTER
	AX = 5101h
	BH = character width in bits
	BL = character height
	DX = character code (DH = 00h if 8-bit character)
	ES:BP -> buffer for character bitmap
Return: AL = status (00h successful, 01h failed)
SeeAlso: AH=09h,AX=5100h
--------J-105200-----------------------------
INT 10 - VIDEO - AX PC - SET VIRTUAL TEXT RAM BUFFER
	AX = 5200h
	BX = segment of buffer
SeeAlso: AX=5201h
--------J-105201-----------------------------
INT 10 - VIDEO - AX PC - GET VIRTUAL TEXT RAM BUFFER
	AX = 5201h
Return: BX = segment of buffer or 0000h if failed
SeeAlso: AX=8300h,AH=FEh
----------1053-------------------------------
INT 10 - Show Partner F/X v3.6 - START PRESENTATION
	AH = 53h
	DS:DX -> ASCIZ name of presentation file (no path, extension forced to
		.PR2)
Return: ???
SeeAlso: AH=55h
----------1055-------------------------------
INT 10 - Show Partner F/X v3.6 - UNINSTALL
	AH = 55h
Return: FXSHOW.EXE removed from memory
SeeAlso: AH=53h
--------V-105555-----------------------------
INT 10 - VIDEO - ATI EGA/VGA Wonder Super Switch - INSTALLATION CHECK
	AX = 5555h
Return: AX = AAAAh    if installed
	BX:CX -> ??? routine in SMS.COM resident portion
	      -> data area in VCONFIG
Program: Super Switch (SMS.COM) is a video mode switch program supplied with
	  ATI EGA Wonder. It also maps video mode 08h to 27h or 23h.
SeeAlso: INT 10/AH=00h,INT 2F/AX=6400h
Index:	screen saver;ATI Wonder SMS.COM

Format of data area:
Offset	Size	Description
 00h	DWORD	original INT 09 vector
 04h	DWORD	original INT 10 vector
 08h	DWORD	original INT 1C vector
 0Ch	WORD	screen saver state, 0=off, 1=on
 0Eh	WORD	blanking interval in clock ticks
--------V-105F00-----------------------------
INT 10 - Chips & Technologies Extended BIOS - RETURN CHIP INFORMATION
	AX = 5F00h
Return: AL = 5Fh function supported
	    BL = chip type (see below)
	    BH = video memory size (00h 256KB, 01h 512KB, 02h 1MB)
	    CX = miscellaneous flags
		bits 15-2 reserved
		bit 1 = system type (0=PC/AT, 1=PS/2)
		bit 2 = DAC size (0=6-bit, 1=8-bit)
SeeAlso: AX=5F01h

Bitfields for chip type:
 bits 7-4 chip type
	0000: 82c451
	0001: 82c452
	0010: 82c455
 bits 3-0 revision number
--------V-105F00-----------------------------
INT 10 - VIDEO - Realtek RTVGA - RETURN CHIP VERSION
	AX = 5F00h
Return: AH = 00h, if successful
	AL = chip version (the same value that VTEST.EXE reads)
	    00h RTG3103???
	    01h RTG31030/RTG3105
	    02h RTG3106???
	    3Fh non-Realtek chip
BUG:	in v3.C10, AX=5F00h on return due to improper stack restoration code
SeeAlso: AX=5F01h"RTVGA"
--------V-105F01-----------------------------
INT 10 - Chips & Technologies Extended BIOS - SET EMULATION
	AX = 5F01h
	BL = emulation type (see below)
Return: AL = 5Fh if function supported
	    AH = status
		00h unsuccessful
		01h successful
SeeAlso: AX=5F00h,AX=5F02h,AH=FFh"Oak"

Values for emulation type:
 00h,01h reserved
 02h	CGA
 03h	MDA
 04h	Hercules
 05h	EGA
 06h	VGA
--------V-105F01-----------------------------
INT 10 - VIDEO - Realtek RTVGA - WRITE RTVGA BIOS STRING TO DESTINATION
	AX = 5F01h
	ES:DI -> zero-filled buffer for BIOS ID string
Return: AH = 00h if succesful
	ES:DI -> ASCII signature "REALTEK VGA BIOS Version 3C.10"
BUG:	in v3.C10, AX=5F01h on return due to improper stack restoration code
SeeAlso: AX=5F00h"RTVGA",AX=5F02h"RTVGA"
--------V-105F02-----------------------------
INT 10 - Chips & Technologies Extended BIOS - AUTO EMULATION
	AX = 5F02h
	BL = new state of autmatic emulation (00h enabled, 01h disabled)
Return: AL = 5Fh if function supported
	    AH = status
		00h unsuccessful
		01h successful
SeeAlso: AX=5F01h,AX=5F03h
--------V-105F02-----------------------------
INT 10 - VIDEO - Realtek RTVGA - RETURN RTVGA ON-BOARD MEMORY SIZE
	AX = 5F02h
Return: AH = 00h, if succesful
	AL = on-board memory size
	     (00h = 256K, 01h = 512K, 02h = 768K, 03h = 1024K)
BUG:	in v3.C10, AX=5F02h on return due to improper stack restoration code
SeeAlso: AX=5F01h"RTVGA",AX=5F03h"RTVGA"
--------V-105F03-----------------------------
INT 10 - VIDEO - Realtek RTVGA - SET ???
	AX = 5F03h
	BL = 0-3 (???)
Return: AH = 00h if succesful
BUG:	in v3.C10, AX=5F03h on return due to improper stack restoration code
SeeAlso: AX=5F02h"RTVGA"
--------V-105F03BL00-------------------------
INT 10 - Chips & Technologies Extended BIOS - SET POWER-ON DISPLAY MODE
	AX = 5F03h
	BL = 00h
	CL = display mode
	CH = mode
	    bits 1-0 scanlines
		00: 200
		01: 350
		10: 400
	    bit 7 persistence (0 reset on next boot, 1 until changed)
Return: AL = 5Fh if function supported
	    AH = status
		00h unsuccessful
		01h successful
SeeAlso: AX=5F02h,AX=5F03h/BL=01h,AX=5F90h
--------V-105F03BL01-------------------------
INT 10 - Chips & Technologies Extended BIOS - SET POWER-ON EMULATION MODE
	AX = 5F03h
	BL = 01h
	CL = emulation mode
	CH = mode
	    bit 7 persistence (0 reset on next boot, 1 until changed)
Return: AL = 5Fh if function supported
	    AH = status
		00h unsuccessful
		01h successful
SeeAlso: AX=5F02h,AX=5F03h/BL=00h,AX=5F90h
--------V-105F-------------------------------
INT 10 - Chips & Technologies Extended BIOS - SAVE/RESTORE SUPERVGA STATE
	AH = 5Fh
	AL = subfunction
	    90h determine size of save buffer
	    91h save state
	    92h restore state
	CX = state mask (see below)
	ES:BX -> save buffer (subfunctions 91h,92h only)
Return: AL = 5Fh if function supported
	    ---subfunction 90h---
		BX = number of 64-byte blocks required
	    ---subfunction 92h---
		buffer at ES:BX filled
SeeAlso: AH=1Ch,AX=5F03h

Bitfields for state mask:
 bit 0	video hardware
 bit 1	BIOS data state
 bit 2	DAC state
 bit 15 type (0 all state info, 1 SuperVGA state only)
--------V-106A00BX0000-----------------------
INT 10 - Direct Graphics Interface Standard (DGIS) - INQUIRE AVAILABLE DEVICES
	AX = 6A00h
	BX = 0000h
	CX = 0000h
	DX = buffer length (may be 0)
	ES:DI -> buffer
Return: BX = number of bytes stored in buffer
	CX = bytes required for all descriptions (0 if no DGIS)
Note:	buffer contains descriptions and addresses of DGIS-compatible
	  display(s) and printer(s)
SeeAlso: AX=6A02h
--------V-106A01CX0000-----------------------
INT 10 - Direct Graphics Interface Standard (DGIS) - REDIRECT CHARACTER OUTPUT
	AX = 6A01h
	CX = 0000h
	ES:DI = address of device to send INT 10 output to
Return: CX = 0000h  output could not be redirected
	     else INT 10h output now routed to requested display
SeeAlso: AX=6A02h
--------V-106A02-----------------------------
INT 10 - DGIS - INQUIRE INT 10 OUTPUT DEVICE
	AX = 6A02h
	ES:DI = 0000h:0000h
Return: ES:DI = 0000h:0000h  if current display is non-DGIS
		else address of the current DGIS INT 10 display
SeeAlso: AX=6A00h,AX=6A01h
--------V-106E00-----------------------------
INT 10 - Paradise VGA internal - GET ???
	AX = 6E00h
Return: AH = ??? (depends on serial number)
	AL = ???
	BX = ???
	CL = ???
	CH = ???
	DX = ???
SeeAlso: AX=6E04h,AX=6E05h
--------V-106E04-----------------------------
INT 10 - Paradise VGA internal - GET SCREEN SIZE AND ???
	AX = 6E04h
Return: BX = screen width (columns)
	CX = screen height (lines)
	AH = ??? (05h or FFh)
	AL = ??? (04h or video mode)
SeeAlso: AX=6E00h,AX=6E05h
--------V-106E05-----------------------------
INT 10 - Paradise VGA internal - SET MODE
	AX = 6E05h
	BL = mode
Note:	like AH=00h, AL=BL.
SeeAlso: AH=00h,AX=6E00h,AX=6E04h,AX=6F05h
--------V-106F00BX0000-----------------------
INT 10 - VIDEO - Video7 VGA,VEGA VGA,HP Ext BIOS - INSTALLATION CHECK
	AX = 6F00h
	BX = 0000h
Return: BX = 5637h ('V7') indicates Video7 VGA/VEGA VGA extensions are present
	BX = 4850h ('HP') indicates HP Extended BIOS video functions present
SeeAlso: AX=6F01h,AX=6F02h,AX=6F03h,AX=6F04h,AX=6F05h
--------V-106F01-----------------------------
INT 10 - VIDEO - Video7 VGA,VEGA VGA,HP Ext BIOS - GET MONITOR INFO
	AX = 6F01h
Return: AL = monitor type code (HP,VEGA VGA only) (see below)
	AH = status register information
	     bit  0 = display enable
			0 = display enabled
			1 = vertical or horizontal retrace in progress
	     bit  1 = light pen flip flop set
	     bit  2 = light pen switch activated
	     bit  3 = vertical sync
	     bit  4 = monitor resolution
			0 = high resolution (>200 lines)
			1 = low resolution (<=200 lines)
	     bit  5 = display type
			0 = color
			1 = monochrome
	     bits6,7= diagnostic bits
	CL = current value of Extended Control register (HP Ext BIOS, and only
		if AL=41h)
Note:	bits 0-3 are the same as the EGA/VGA status register bits 0-3

Values for monitor type code (HP Extended BIOS):
 00h	non-HP card with ROM and possibly its own INT 10h driver
 41h	MultiMode video display adapter
 42h-44h reserved
 45h	industry standard monochrome display adapter
 46h	industry standard color display adapter
 51h	reserved
--------V-106F02-----------------------------
INT 10 - VIDEO - HP Vectra EXTENDED BIOS - SET MONITOR INFO
	AX = 6F02h
	BL = new value for extended control register (see below)
Return: nothing
Notes:	this function is only valid when an HP MultiMode Video Display Adapter
	  is installed
	the Extended Control register is at I/O address 3DDh
SeeAlso: AX=6F01h,AX=6F03h

Bitfields for extended control register:
 bit 0	screen resolution (0 = 200 lines, 1 = 400 lines)
 bit 1	underline enable (if set, 'blue' bit of fg color = underl)
 bit 2	font (0 = Standard-8, 1 = HP-Roman-8)
 bit 3	memory disabled for CPU access
 bit 4	allow access to full 32K memory instead of wrapping at 16K
 bit 5	select second 16K page instead of first
 bits 6,7 unused
--------V-106F03-----------------------------
INT 10 - VIDEO - HP Vectra EXTENDED BIOS - MODIFY MONITOR INFO
	AX = 6F03h
	BH = exclude mask (set bits are not modified)
	BL = new values for bits indicated by BH (see AX=6F02h)
Return: nothing
Note:	this function is only valid when an HP MultiMode Video Display Adapter
	  is installed
SeeAlso: AX=6F01h,AX=6F02h
--------V-106F04-----------------------------
INT 10 - VIDEO - Video7 VGA,VEGA VGA,HP Vectra - GET MODE AND SCREEN RESOLUTION
	AX = 6F04h
Return: AL = current video mode (see AX=6F05h)
	BX = horizontal columns (text) or pixels (graphics)
	CX = vertical columns (text) or pixels (graphics)
SeeAlso: AX=6F05h
--------V-106F05-----------------------------
INT 10 - VIDEO - Video7 VGA, VEGA EXTENDED EGA/VGA - SET VIDEO MODE
	AX = 6F05h
	BL = mode (see below)
Notes:	also supported by the HP Vectra Extended BIOS
	on the HP Vectra, this function rather than AH=00h must be used to
	  return to an IBM-standard mode after setting an HP-specified mode
	  from 08h to 0Fh.
SeeAlso: AH=00h,AX=0070h,AX=007Eh,AX=6F04h

Values for video mode:
      text/ text pixel	 pixel	colors	disp	scrn  system
      grph resol  box	resoltn		page	addr
 00h-13h = standard IBM modes (see AH=00h)
 08h = T   80x27	       mono		     HP MultiMode Video
 09h = T   80x27				     HP MultiMode Video
 0Ah = T   40x27	       mono		     HP MultiMode Video
 0Bh = T   40x27				     HP MultiMode Video
 0Ch = Reserved					     HP MultiMode Video
 0Dh = G		640x400			     HP MultiMode Video
 0Eh = G		320x400			     HP MultiMode Video
 0Fh = G		320x400			     HP MultiMode Video
 40h = T   80x43  8x8				     Video7/VEGA VGA
 41h = T  132x25  8x14				     Video7/VEGA VGA
 42h = T  132x43  8x8				     Video7/VEGA VGA
 43h = T   80x60  8x8				     Video7/VEGA VGA
 44h = T  100x60  8x8				     Video7/VEGA VGA
 45h = T  132x28  8x8				     Video7/VEGA VGA
 60h = G		752x410	  16		     Video7 VGA, VEGA VGA
 61h = G		720x540	  16		     Video7 VGA, VEGA VGA
     = G		720x540	  16		     Northgate, Headland 1024i
 62h = G		800x600	  16		     Video7 VGA, VEGA Ext EGA
     = G		800x600	  16		     Headland 1024i
 63h = G	       1024x768	   2		     Video7 VGA
 64h = G	       1024x768	   4		     Video7 VGA
 65h = G	       1024x768	  16		     Video7 VGA, VEGA Ext EGA
     = G	       1024x768	  16		     Headland 1024i
 66h = G		640x400	 256		     Video7 VGA, VEGA Ext VGA
     = G		640x400	 256		     Northgate, Headland 1024i
 67h = G		640x480	 256		     Video7 VGA, VEGA Ext VGA
     = G		640x480	 256		     Headland 1024i
 68h = G		720x540	 256		     Video7 VGA, VEGA Ext VGA
     = G		720x540	 256		     Headland 1024i
 69h = G		800x600	 256		     Video7 VGA, VEGA Ext VGA
     = G		800x600	 256		     Headland 1024i
 70h = G		752x410	  16gray	     Video7 VGA, VEGA VGA
 71h = G		720x540	  16gray	     Video7 VGA, VEGA VGA
 72h = G		800x600	  16gray	     Video7 VGA
 73h = G	       1024x768	   2gray	     Video7 VGA
 74h = G	       1024x768	   4gray	     Video7 VGA
 75h = G	       1024x768	  16gray	     Video7 VGA
 76h = G		640x400	 256gray	     Video7 VGA
 77h = G		640x480	 256gray	     Video7 VGA
 78h = G		720x540	 256gray	     Video7 VGA
 79h = G		800x600	 256gray	     (future)
SeeAlso: AH=00h,AX=0070h,AX=007Eh,AX=6F04h
Index:	video modes
--------V-106F06-----------------------------
INT 10 - VIDEO - Video7 VGA,VEGA VGA - SELECT AUTOSWITCH MODE
	AX = 6F06h
	BL = Autoswitch mode select
	     00h select EGA/VGA-only modes
	     01h select Autoswitched VGA/EGA/CGA/MGA modes
	     02h select 'bootup' CGA/MGA modes
	BH = enable/disable (00h enable, 01h = disable selection)
--------V-106F07-----------------------------
INT 10 - VIDEO -  Video7 VGA,VEGA VGA - GET VIDEO MEMORY CONFIGURATION
	AX = 6F07h
Return: AL = 6Fh
	AH = bits 0-6 = number of 256K blocks of video memory
	     bit 7    = DRAM/VRAM (0: DRAM, 1: VRAM)
	BH = chip revision (SR8F) (S/C Chip in VEGA VGA)
	BL = chip revision (SR8E) (G/A Chip in VEGA VGA)
	CX = 0000h
SeeAlso: AH=12h/BL=10h
--------V-1070-------------------------------
INT 10 - VIDEO - TANDY 2000 only - GET ADDRESS OF VIDEO RAM
	AH = 70h
Return: AX:BX -> WORD containing green plane's offset
	AX:CX -> WORD containing green plane's segment
	AX:DX -> WORD containing segment of red (offset 0) and blue (offset
			4000) planes
SeeAlso: AH=71h
--------V-107000BX0000-----------------------
INT 10 - Everex Extended Video BIOS - RETURN EMULATION STATUS
	AX = 7000h
	BX = 0000h
Return: AL = 70h if Trident-based Everex card
	CL = monitor type (see below)
	CH = feature bits (see below)
	DX = video board info
	    bits 4-15: board ID model
	    bits 0-3:  board ID revision
	DI = BCD BIOS version number
Note:	board models for Trident-based Everex cards:
	    236h Ultragraphics II
	    620h Vision VGA
	    673h EVGA
	    678h Viewpoint
SeeAlso: AX=5F01h,AH=FF"Oak"

Values for monitor type:
 00h	mono
 01h	CGA
 02h	EGA
 03h	digital multifrequency
 04h	IBM PS/2
 05h	IBM 8514
 06h	SuperVGA
 07h	analog multifrequency
 08h	super multifrequency

Bitfields for feature bits:
 bits 7,6  memory size
	00 = 256K
	01 = 512K
	10 = 1024K
	11 = 2048K
 bit 5	special oscillator present
 bit 4	VGA protect enabled
 bit 0	6845 emulation
--------V-107000BX0004-----------------------
INT 10 - Everex Extended Video BIOS - GET PAGING FUNCTION POINTER FOR CURR MODE
	AX = 7000h
	BX = 0004h
Return: ES:DI -> FAR paging function (call with DL = page to set)
Note:	the word preceding ES:DI is the length of the function in bytes, and
	  the last byte of the function is a FAR return instruction.
SeeAlso: AX=4F05h,AX=7000h/BX=0000h,AX=7000h/BX=0005h
--------V-107000BX0005-----------------------
INT 10 - Everex Extended Video BIOS - GET SUPPORTED MODE INFO
	AX = 7000h
	BX = 0005h
	CL = maximum number of modes to get info for
	CH = mode type to get info for (see below)
	DL = monitor type to get info for
	ES:DI -> buffer for mode info (see below)
Return: CL = total number of modes fitting criteria
	CH = size of each info record
SeeAlso: AX=7000h/BX=0000h,AX=7000h/BX=0004h

Values for mode type:
 00h	all modes
 01h	monochrome text modes
 02h	color text modes
 03h	four-color CGA graphics modes
 04h	two-color CGA graphics modes
 05h	16-color graphics modes
 06h	256-color graphics modes

Format of mode information record:
Offset	Size	Description
 00h	BYTE	mode number (bit 7 set if extended mode)
 01h	BYTE	mode type (see above)
 02h	BYTE	info bits
		bits 7,6 reserved
		     5	 monochrome mode
		     4	 interlaced display
		     3	 requires special oscillator
		     2,1 memory required
			 00 = 256K
			 01 = 512K
			 10 = 1024K
			 11 = 2048K
		     0	 reserved
 03h	BYTE	font height
 04h	BYTE	text columns on screen
 05h	BYTE	text rows on screen
 06h	WORD	number of scan lines
 08h	BYTE	color information
		bits 7-4 reserved
		     3-0 bits per pixel
--------V-1071-------------------------------
INT 10 - VIDEO - TANDY 2000 only - GET ADDRESS OF INCRAM
	AH = 71h
Return: AX:BX -> WORD containing segment address of INCRAM
	AX:CX -> WORD containing offset of INCRAM
SeeAlso: AH=70h
--------V-1072-------------------------------
INT 10 - VIDEO - TANDY 2000 only - SCROLL RIGHT PART OR ALL OF SCREEN
	AH = 72h
	AL = number of columns to shift scroll area, 00h to clear entire area
	BH = new attributes for blanked columns at left
	CH,CL = row, column of upper left corner of scroll area
	DH,DL = row, column of lower right corner of scroll area
SeeAlso: AH=06h,AH=07h,AH=73h,INT 15/AH=12h/BH=05h
--------V-1073-------------------------------
INT 10 - VIDEO - TANDY 2000 only - SCROLL LEFT PART OR ALL OF SCREEN
	AH = 73h
	AL = number of columns to shift scroll area, 00h to clear entire area
	BH = new attributes for blanked columns at right
	CH,CL = row, column of upper left corner of scroll area
	DH,DL = row, column of lower right corner of scroll area
SeeAlso: AH=06h,AH=07h,AH=72h,INT 15/AH=12h/BH=05h
--------V-107F00-----------------------------
INT 10 - SOLLEX SuperVGA - GET EXTENSIONS INFO
	AX = 7F00h
Return: AL <> 7Fh if not supported
	AL = 7Fh if supported
	    AH = status
		00h successful
		    ES:DI -> info structure (see below)
		01h failed
Program: the SOLLEX (Smos videO controLLer EXtensions) SuperVGA functions are
	  an extension to the VESA SuperVGA BIOS Extensions (see AX=4F00h) by
	  Seiko Epson Corporation intended to provided a standardized interface
	  to SuperVGA functionality not addressed by the VESA standard
SeeAlso: AX=4F00h

Format of info structure:
Offset	Size	Description
 00h	DWORD	pointer to VESA function dispatch table
 04h	DWORD	pointer to SOLLEX function dispatch table
 08h	DWORD	pointer to VESA SuperVGA info (see AX=4F00h)
 0Ch	DWORD	pointer to mode info structure table, consisting of
		alternating ResInfo (see below) and VESA mode information
		(see AX=4F01h) blocks, terminated with an FFFFh word
 10h	DWORD	pointer to font info structure table (see below)
 14h	WORD	high resolution crystal frequency in Hz (0000h = not present)
 16h	DWORD	pointer to ASCIZ ID string
 1Ah	DWORD	pointer to timeout reset table
		array of bytes, each a multiple of the minimum time increment
 1Eh	WORD	minimum time increment in timer ticks
 20h	BYTE	inverse options supported
		bit 0: inverse supported
		bits 1-7: reserved
 21h	BYTE	normal color value
 22h	BYTE	inverse color value
 23h	WORD	port to be accessed for normal/inverse settings
 25h	WORD	type of interface chip (currently undefined)
 27h	WORD	program operational mode
		bits 1-0: 00 no preference
			  01 terse (minimum detail in program messages)
			  10 verbose
			  11 use menus if supported, verbose mode otherwise
		bits 7-2: reserved
 29h	WORD	SOLLEX specification version
 2Bh	WORD	version of VESA/SOLLEX implementation
 2Dh	DWORD	offset to relocatable portion of SOLLEX extensions (for CONFIG)
 2Eh	DWORD	offset to unused section of the extensions ROM
 31h 16 BYTEs	reserved
Note:	all DWORD pointers initially require segment fixups; if the segment
	  is 0000h, it should be changed to the returned ES, otherwise it
	  may be assumed to be correct

Format of ResInfo:
Offset	Size	Description
 00h	WORD	16-bit mode number
 02h	WORD	adapter type (00h VGA, 01h EGA, 02h CGA, 03h MDA)
 04h	WORD	display info (see AX=7F01h/BL=01h)
 06h	DWORD	pointer to video parameter table
 0Ah	BYTE	replacement entry in master Video Parameter
 0Bh	BYTE	mode requested for mode set by BIOS
 0Ch	DWORD	pointer to LoadReg table
 10h	BYTE	index into table of clock values (see below)

Format of font info table [array] entry:
Offset	Size	Description
 00h	BYTE	required font height
 01h	BYTE	parameter to load text mode font
 02h	BYTE	parameter to load graphics mode font

Values for clock value index:
 00h	25 MHz
 01h	28 MHz
 02h	PCLK
 03h	31.5 MHz (VESA 640x480)
 04h	reserved
 05h	16 MHz (EGA)
 06h	PCLK
 07h	24 MHz (EGA)
 08h	25 MHz
 09h	28 MHz
 0Ah	36 MHz
 0Bh	45 MHz (for 1024x768)
 0Ch	80 MHz
 0Dh	40 MHz
 0Eh	65 MHz
 0Fh	 1 MHz (for powerdown)
--------V-107F01BL00-------------------------
INT 10 - SOLLEX SuperVGA - ADAPTER CONTROL - SET ADAPTER
	AX = 7F01h
	BL = 00h
	CX = adapter request
	    bits 1-0: adapter type (00 VGA, 01 EGA, 10 CGA, 11 MDA)
	    bit 2:    reserved
	    bits 4-3: change displays (00 none, 01 analog 10 digital 11 panel)
	    bits 6-5: desired monitor sense (01 color, 10 mono, 11=8514)
	    bit 7:    lock override
	    bit 8:    alternate adapter mode
	    bits 15-9: reserved
Return: AL = 7Fh if supported
	    AH = status
		00h successful
		01h failed
	AL <> 7Fh if not supported
Note:	initializes video hardware to a particular standard
SeeAlso: AX=7F00h,AX=7F01h/BL=01h,AX=7F01h/BL=02h
--------V-107F01BL01-------------------------
INT 10 - SOLLEX SuperVGA - ADAPTER CONTROL - GET ADAPTER
	AX = 7F01h
	BL = 01h
Return: AL <> 7Fh if not supported
	AL = 7Fh if supported
	    AH = status
		00h successful
		01h failed
	    BX = adapter type (see AX=7F01h/BL=00h)
	    DX = display type (see below)
SeeAlso: AX=7F00h,AX=7F01h/BL=00h,AX=7F01h/BL=02h

Bitfields for display type:
 bits 1-0 monitor sense (00 none, 01 color, 10 mono, 11=8514)
 bit 2	multi-frequency analog monitor active
 bit 3	LCD panel active
 bit 4	plasma/electroluminescent panel active
 bit 5	PS/2-type monitor active
 bit 6	multi-frequency digital monitor active
 bit 7	Enhanced Color Display monitor active
 bit 8	alternate display active
 bits 15-9 reserved
--------V-107F01BL02-------------------------
INT 10 - SOLLEX SuperVGA - ADAPTER CONTROL - DETERMINE ADAPTER SUPPORT
	AX = 7F01h
	BL = 02h
	CX = adapter request (see AX=7F01h/BL=00h)
Return: AL <> 7Fh if not supported
	AL = 7Fh if supported
	    AH = status
		00h requested setting can successfully be made
		01h requested setting not available in this configuration
SeeAlso: AX=7F00h,AX=7F01h/BL=00h
--------V-107F02BL00-------------------------
INT 10 - SOLLEX SuperVGA - DISPLAY OUTPUT CONTROL - SET DISPLAY OUTPUT
	AX = 7F02h
	BL = 00h
	CX = display output setting (see below)
Return: AL <> 7Fh if not supported
	AL = 7Fh if supported
	    AH = status
		00h successful
		01h failed
SeeAlso: AX=7F00h,AX=7F02h/BL=00h

Bitfields for display output setting:
 bit 0	CRTC control in bits 2,1 valid
 bit 1	enable digital output
 bit 2	enable analog output
 bit 3	panel control in bits 5,4 valid
 bit 4	enable LCD output
 bit 5	enable plasma/EL output
 bit 6	inverse control in bit 7 valid
 bit 7	0=normal, 1=inverse
 bits 15-8 reserved
--------V-107F02BL01-------------------------
INT 10 - SOLLEX SuperVGA - DISPLAY OUTPUT CONTROL - GET DISPLAY OUTPUT
	AX = 7F02h
	BL = 01h
Return: AL <> 7Fh if not supported
	AL = 7Fh if supported
	    AH = status
		00h successful
		    BX = display output setting (see AX=7F02h/BL=00h)
		    CX = displays attached (see below)
		01h failed
SeeAlso: AX=7F00h,AX=7F02h/BL=00h

Bitfields for displays attached:
 bit 0	PS/2 display on analog output
 bit 1	multi-frequency monitor on analog output
 bit 2	LCD panel attached
 bit 3	plasma/electroluminescent panel attached
 bit 4	multi-frequency monitor on digital output
 bit 5	Enhanced Color Display attached to digital outpt
 bit 6	alternate display
 bits 15-7 reserved
--------V-107F03BL00-------------------------
INT 10 - SOLLEX SuperVGA - VIDEO SUPPORT CONTROL - GET SUPPORT INFO
	AX = 7F03h
	BL = 00h
	CX = support type
		0000h VGA, 0001h EGA, 0002h CGA, 0003h MDA, 0004h extensions,
		0005h-0012h reserved for SOLLEX, 0013h Hercules,
		0014h-001Fh reserved for SOLLEX, 0020h-00FFh reserved for OEM
Return: AL <> 7Fh if not supported
	AL = 7Fh if supported
	    AH = status
		00h successful
		    CX = size of video support code
		    DX = segment of physical video support (0000h if no ROM)
		    ES = segment of active video support
		    ES:DI -> information block (DI = 0000h if none available)
		01h failed
SeeAlso: AX=7F03h/BL=01h
--------V-107F03BL01-------------------------
INT 10 - SOLLEX SuperVGA - VIDEO SUPPORT CONTROL - INITIALIZE VIDEO SUPPORT
	AX = 7F03h
	BL = 01h
	CX = support request
	ES = segment of support code
Return: AL <> 7Fh if not supported
	AL = 7Fh if supported
	    AH = status
		00h successful
		01h failed
Note:	initializes the indicated video support by calling ES:0003h; this
	  function may be used to switch the active video support back to
	  ROM after AX=7F03h/BL=02h
SeeAlso: AX=7F03h/BL=00h
--------V-107F03BL02-------------------------
INT 10 - SOLLEX SuperVGA - VIDEO SUPPORT CONTROL - GO RAM RESIDENT
	AX = 7F03h
	BL = 02h
	CX = support request
	ES = destination segment
Return: AL <> 7Fh if not supported
	AL = 7Fh if supported
	    AH = status
		00h successful
		01h failed
SeeAlso: AX=7F00h,AX=7F03h/BL=01h
--------V-107F04BL00-------------------------
INT 10 - SOLLEX SuperVGA - POWER CONTROL - SET POWER STATE
	AX = 7F04h
	BL = 00h
	CX = new power state
Return: AL <> 7Fh if not supported
	AL = 7Fh if supported
	    AH = status
		00h successful
		01h failed
Note:	higher values progressively reduce the operations available on the
	  video adapter while yielding increasing power savings
SeeAlso: AX=7F00h,AX=7F04h/BL=01h
--------V-107F04BL01-------------------------
INT 10 - SOLLEX SuperVGA - POWER CONTROL - GET POWER STATE
	AX = 7F04h
	BL = 01h
Return: AL <> 7Fh if not supported
	AL = 7Fh if supported
	    AH = status
		00h successful
		    CX = current power state
		    DX = maximum state
		01h failed
SeeAlso: AX=7F00h,AX=7F04h/BL=00h
--------V-107F04BL02-------------------------
INT 10 - SOLLEX SuperVGA - POWER CONTROL - SET TIMEOUT RESET
	AX = 7F04h
	BL = 02h
	CX = timeout reset
Return: AL <> 7Fh if not supported
	AL = 7Fh if supported
	    AH = status
		00h successful
		01h failed
SeeAlso: AX=7F00h,AX=7F04h/BL=03h
--------V-107F04BL03-------------------------
INT 10 - SOLLEX SuperVGA - POWER CONTROL - GET TIMEOUT RESET
	AX = 7F04h
	BL = 03h
Return: AL <> 7Fh if not supported
	AL = 7Fh if supported
	    AH = status
		00h successful
		    BX = time increment
		    CX = current timeout reset
		    DX = maximum timeout reset
		    ES:DI -> timeout reset table (array of bytes)
		01h failed
Note:	the timeout period is computed as (BYTE ES:[DI+CX]) * BX timer ticks
SeeAlso: AX=7F00h,AX=7F04h/BL=02h
--------V-107F05-----------------------------
INT 10 - SOLLEX SuperVGA - LOAD REGISTER
	AX = 7F05h
	ES:DI -> register value table (see below)
Return: AL <> 7Fh if not supported
	AL = 7Fh if supported
	    AH = status
		00h successful
		01h failed
SeeAlso: AH=F1h,AH=F3h,AH=F5h

Format of register value table:
Offset	Size	Description
 00h	WORD	base I/O register (FFFFh = end of list)
 02h 2N BYTEs	pairs of values to be written to the base I/O register as an
		index value and the following register as a data byte
 2N+2	WORD	FFFFh (end of data list)
	... (repeats until FFFFh base address)
--------V-107F06-----------------------------
INT 10 - SOLLEX SuperVGA - MULTIPLE FONT CONTROL
	AX = 7F06h
	BL = subfunction
	    00h set multiple font state
		CX = new state (00h off, 01h on)
	    01h get multiple font state
		Return: BL = current state (00h off, 01h on)
Return: AL <> 7Fh if not supported
	AL = 7Fh if supported
	    AH = status
		00h successful
		01h failed
SeeAlso: AH=11h
--------V-107F07-----------------------------
INT 10 - SOLLEX SuperVGA - FILL VIDEO RAM
	AX = 7F07h
	BL = how much to fill
	   00h regen size
	   01h all video memory
	CX = pattern to write (normally 0720h for text modes and 0000h for gr)
Return: AL <> 7Fh if not supported
	AL = 7Fh if supported
	    AH = status
		00h successful
		01h failed
SeeAlso: AH=06h
--------A-1080-------------------------------
INT 10 - CU Writer v1.4 - GET OPTION
	AH = 80h
	AL = desired option
Return: ???
Program: CU Writer is a public-domain Thai-English word processor from
	  Chulalongkorn University, Bangkok
SeeAlso: AH=81h"CU Writer"
--------Q-1080--DX4456-----------------------
INT 10 U - VIDEO - DESQview 2.0x only - internal - SET ??? HANDLER
	AH = 80h
	DX = 4456h ('DV')
	ES:DI -> FAR subroutine to be called on ???
Return: DS = segment of DESQview data structure for video buffer
Note:	this function is probably meant for internal use only, due to the magic
	  value required in DX
	the subroutine seems to be called when the DESQview menu is accessed;
	  on entry, AL = 03h or 04h
--------A-1081-------------------------------
INT 10 - CU Writer v1.4 - SET OPTION
	AH = 81h
	???
Return: ???
SeeAlso: AH=80h"CU Writer"
--------Q-1081--DX4456-----------------------
INT 10 U - VIDEO - DESQview 2.0x only - internal - GET ???
	AH = 81h
	DX = 4456h ('DV')
Return: ES = segment of DESQview data structure for video buffer
	    BYTE ES:[0] = current window number in DV 2.0x
Note:	this function is probably meant for internal use only, due to the magic
	  value required in DX
SeeAlso: AH=82h"DESQview"
--------Q-1082--DX4456-----------------------
INT 10 U - VIDEO - DESQview 2.0x only - internal - GET CURRENT WINDOW INFO
	AH = 82h
	DX = 4456h ('DV')
Return: DS = segment in DESQview for data structure
	     in DV 2.00,
		  BYTE DS:[0] = window number
		  WORD DS:[1] = segment of other data structure
		  WORD DS:[3] = segment of window's object handle
	ES = segment of DESQview data structure for video buffer
	AL = current window number
	AH = ???
	BL = direct screen writes
	    00h program does not do direct writes
	    01h program does direct writes, so shadow buffer not usable
	BH = ???
	CL = current video mode
	CH = ???
Note:	this function is probably meant for internal use only, due to the magic
	  value required in DX
SeeAlso: AH=81h"DESQview"
--------J-108200-----------------------------
INT 10 - VIDEO - AX PC - GET/SET SCROLL MODE
	AX = 8200h
	BL = new scroll mode or FFh to get current mode
	    00h dynamic, 01h software
Return: AL = scroll mode (current mode if BL=FFh, previous mode otherwise)
SeeAlso: AH=06h,AH=07h
--------J-108300-----------------------------
INT 10 - VIDEO - AX PC - GET VIDEO RAM ADDRESS
	AX = 8300h
Return: AX = offset of video RAM
	ES:BX -> virtual text RAM buffer
SeeAlso: AX=5201h
--------N-108B-------------------------------
INT 10 - Alloy MW386 - FORCE WORKSTATION SCREEN UPDATE
	AH = 8Bh
SeeAlso: AH=92h,AH=93h
--------N-1090-------------------------------
INT 10 - Alloy MW386 - GET PHYSICAL WORKSTATION DISPLAY MODE
	AH = 90h
Return: AL = current video mode (see AH=00h)
SeeAlso: AH=91h
--------N-1091-------------------------------
INT 10 - Alloy MW386 - GET PHYSICAL WORKSTATION ADAPTER TYPE
	AH = 91h
Return: AL = video adapter type (see below)
Note:	types less than 80h do not imply that the current user is on the host
SeeAlso: AH=90h

Values for video adapter type:
 00h	monochrome
 01h	Hercules monochrome graphics
 02h	CGA
 03h	EGA
 04h	VGA
 80h	monochrome text terminal
 81h	Hercules graphics terminal
 82h	color graphics terminal
--------N-1092-------------------------------
INT 10 - Alloy MW386 - INHIBIT WORKSTATION SCREEN UPDATES
	AH = 92h
Note:	the terminal will be updated even when screen updates are inhibited if
	  TTY output is used
SeeAlso: AH=8Bh
--------N-1093-------------------------------
INT 10 - Alloy MW386 - REDRAW SCREEN
	AH = 93h
SeeAlso: AH=8Bh,AH=FFh
--------A-10A0-------------------------------
INT 10 - CU Writer v1.4 - SET PIXEL WRITE MODE
	AH = A0h
	???
Return: ???
Program: CU Writer is a public-domain Thai-English word processor from
	  Chulalongkorn University, Bangkok
SeeAlso: AH=80h"CU Writer",AH=B0h
--------A-10B0-------------------------------
INT 10 - CU Writer v1.4 - PUT PIXEL
	AH = B0h
	???
Return: ???
SeeAlso: AH=A0h"CU Writer",AH=B1h,AH=B2h,AH=B3h,AH=B4h,AH=B5h,AH=D0h
--------A-10B1-------------------------------
INT 10 - CU Writer v1.4 - MOVE TO
	AH = B1h
	???
Return: ???
SeeAlso: AH=B0h,AH=B2h,AH=C0h"CU Writer"
--------A-10B2-------------------------------
INT 10 - CU Writer v1.4 - DRAW LINE TO
	AH = B2h
	???
Return: ???
SeeAlso: AH=B0h,AH=B1h,AH=B3h,AH=B4h,AH=B5h
--------A-10B3-------------------------------
INT 10 - CU Writer v1.4 - FLOOD FILL
	AH = B3h
	???
Return: ???
SeeAlso: AH=B2h,AH=B5h
--------A-10B4-------------------------------
INT 10 - CU Writer v1.4 - DRAW RECTANGLE
	AH = B4h
	???
Return: ???
SeeAlso: AH=B0h,AH=B2h,AH=B3h,AH=B5h
--------A-10B5-------------------------------
INT 10 - CU Writer v1.4 - DRAW FILLED RECTANGLE
	AH = B5h
	???
Return: ???
SeeAlso: AH=B0h,AH=B2h,AH=B3h,AH=B4h
--------b-10BF00-----------------------------
INT 10 - VIDEO - Compaq Portable Extensions - SELECT EXTERNAL MONITOR
	AX = BF00h
Desc:	specify that the external monitor become the active monitor
Note:	all registers preserved and the internal monitor is blanked
SeeAlso: AX=BF01h
--------b-10BF01-----------------------------
INT 10 - VIDEO - Compaq Portable Extensions - SELECT INTERNAL MONITOR
	AX = BF01h
Desc:	specify that the internal monitor become the active monitor
Note:	all registers preserved and the external monitor is blanked
SeeAlso: AX=BF00h
--------b-10BF02-----------------------------
INT 10 - VIDEO - Compaq Portable Extensions - SET MASTER MODE OF CURRENT CTRLR
	AX = BF02h
	BH = master mode
	    04h CGA
	    05h EGA
	    07h MDA
SeeAlso: AX=BF03h
--------b-10BF03BX0000-----------------------
INT 10 - VIDEO - Compaq Portable/Systempro Extensions - GET ENVIRONMENT
	AX = BF03h
	BX = 0000h
Return: BH = active monitor
	    00h = external
	    01h = internal
	BL = master mode
	    00h = switchable VDU not present
	    04h = CGA
	    05h = EGA
	    07h = MDA
	    08h = switchable LCD controller present
	CH = 00h (reserved)
	CL = switchable VDU mode supported
	    bit	 0   = CGA supported
	    bits 1,2 = reserved (1)
	    bit	 3   = MDA supported
	    bits 4-7 = reserved (1)
	DH = internal monitor type (see below)
	DL = external monitor type (see below)
SeeAlso: AH=1Ah,AX=BF00h,AX=BF01h,AX=BF02h

Values for monitor type:
 00h	none
 01h	dual-mode monitor
 02h	5153 RGB monitor
 03h	Compaq Color monitor
 04h	640x400 flat panel
 05h	VGC monochrome
 06h	VGC color
 07h	LCD VGA
--------b-10BF04-----------------------------
INT 10 - VIDEO - Compaq Portable Extensions - SET MODE SWITCH DELAY
	AX = BF04h
	BH = new state of delay
	    00h enabled
	    01h disabled
SeeAlso: AX=BF05h
--------b-10BF05-----------------------------
INT 10 - VIDEO - Compaq Systempro Extensions - ENABLE/DISABLE DISPLAY
	AX = BF05h
	BH = new state of video
	    00h off
	    01h on
SeeAlso: AH=12h/BL=36h,AX=BF04h
--------b-10BF06-----------------------------
INT 10 - VIDEO - Compaq SLT/286 - READ GRAY SCALE TABLE
	AX = BF06h
	CL = address to be read from gray scale table
Return: AL = bit 3-0 - Value read from gray scale table
	CL = address to be read from gray scale table
SeeAlso: AH=12h/BL=33h,AX=BF07h
--------b-10BF07-----------------------------
INT 10 - VIDEO - Compaq SLT/286 - WRITE GRAY SCALE TABLE
	AX = BF07h
	CH = value to write to gray scale table
	CL = address to be written to gray scale table
SeeAlso: AX=BF06h,AX=BF08h
--------b-10BF08-----------------------------
INT 10 - VIDEO - Compaq SLT/286 - WRITE COLOR MIX REGISTERS
	AX = BF08h
	CH = bits 7-4 green weight
	     bits 3-0 blue weight
	CL = bits 7-4 unused
	     bits 3-0 red weight
SeeAlso: AH=12h/BH=33h,AX=BF07h
--------V-10BFA0BXADAD-----------------------
INT 10 - VIDEO - Compaq ADAPT.COM - INSTALLATION CHECK
	AX = BFA0h
	BX = ADADh
Return: AX = BDBDh if newer ADAPT.COM installed
	    BX = BCD version (BH = major, BL = minor)
	    CL = ???
	    CH = ???
	    DL = ???
	AX = ADADh if older version of ADAPT.COM installed
Program: ADAPT is Compaq's Advanced Display Attribute Programming Tool, an
	  optionally-resident utility for setting display colors and cursor
	  size; when resident, it also includes a screen blanker
SeeAlso: AX=BFA1h,AX=BFA2h,AX=DFA5h
Index:	screen saver;ADAPT
--------V-10BFA1-----------------------------
INT 10 - VIDEO - Compaq ADAPT.COM - GET ???
	AX = BFA1h
Return: AX = BDBEh if supported
	    CH = current value of ???
	    DL = current value of ???
SeeAlso: AX=BFA0h,AX=BFA2h
--------V-10BFA2-----------------------------
INT 10 - VIDEO - Compaq ADAPT.COM - SET ???
	AX = BFA2h
	CH = new value for ???
	DL = new value for ???
Return: AX = BDBEh if supported
SeeAlso: AX=BFA0h,AX=BFA1h
--------A-10C0-------------------------------
INT 10 - CU Writer v1.4 - GO TO TEXT ROW AND COLUMN
	AH = C0h
	???
Return: ???
SeeAlso: AH=B1h,AH=C1h,AH=C2h,AH=C3h,AH=C4h
--------A-10C1-------------------------------
INT 10 - CU Writer v1.4 - OUTPUT TEXT
	AH = C1h
	???
Return: ???
SeeAlso: AH=C0h,AH=C2h,AH=C3h,AH=C4h
--------A-10C2-------------------------------
INT 10 - CU Writer v1.4 - REVERSE TEXT
	AH = C2h
	???
Return: ???
SeeAlso: AH=C0h,AH=C1h,AH=C3h,AH=C4h
--------A-10C3-------------------------------
INT 10 - CU Writer v1.4 - TEXT BAR
	AH = C3h
	???
Return: ???
SeeAlso: AH=C0h,AH=C1h,AH=C4h
--------A-10C4-------------------------------
INT 10 - CU Writer v1.4 - TEXT MENU
	AH = C4h
	???
Return: ???
SeeAlso: AH=C0h,AH=C1h,AH=C3h,AH=D0h
--------V-10CC00SI0000-----------------------
INT 10 - VIDEO - UltraVision - GET STATUS (INSTALLATION CHECK)
	AX = CC00h
	SI = 0000h (if checking version)
Return: CX = ABCDh
	AL = Ultravision extensions
	    00h enabled
	    FFh disabled
	AH = card designator
	BX:00F0h -> palette values (for compatibility with NEWFONT)
	DX = support for high resolution modes
	    00h not active
	    01h active
	SI = UltraVision version number (v1.2+), high byte=major,low byte=minor
	   = unchanged for versions <1.2
SeeAlso: AX=CC01h,AX=CC02h
--------V-10CC01-----------------------------
INT 10 - VIDEO - UltraVision - DISABLE EXTENSIONS
	AX = CC01h
Notes:	subsequent BIOS calls will be passed through to previous handler
	should be followed immediately by mode set to restore normal EGA/VGA
	  state
SeeAlso: AX=CC02h
--------V-10CC02-----------------------------
INT 10 - VIDEO - UltraVision - ENABLE EXTENSIONS
	AX = CC02h
Note:	should be followed immediately by mode set to restore previous
	  UltraVision state
SeeAlso: AX=CC01h
--------V-10CD00-----------------------------
INT 10 - VIDEO - UltraVision - LOAD ULTRAVISION PALETTE (color EGA,VGA)
	AX = CD00h
	CL = palette table number (01h-07h for v1.x, 01h-0Fh for v2+)
	DS:DX -> 16-byte palette register list (colors for registers 00h-0Fh)
Notes:	if palette locking is in effect for the current mode, the new colors
	  will be displayed immediately; otherwise, the system reverts to the
	  default palette
	palette table 0 is reserved for the default palette and cannot be set
	UltraVision always sets the border color to black
SeeAlso: AX=CD01h,AX=CD02h
--------V-10CD01-----------------------------
INT 10 - VIDEO - UltraVision - SET PALETTE LOCKING STATUS (color EGA,VGA)
	AX = CD01h
	CL = palette locking value
	    00h none
	    01h text modes only (02h,03h)
	    FFh all modes (all standard color text and graphics modes)
Notes:	intended for video modes with 16 or fewer colors
SeeAlso: AX=1000h,AX=1002h,AX=CD00h,AX=CD03h
--------V-10CD02-----------------------------
INT 10 - VIDEO - UltraVision - GET ULTRAVISION PALETTE (EGA,VGA)
	AX = CD02h
Return: CL = palette table number
	DS:DX -> 17-byte palette register list
	DS:SI -> current font names table (see below)
Note:	only the font names are valid on monochrome EGA systems
SeeAlso: AX=1009h,AX=CD00h

Format of palette register list:
Offset	Size	Description
 00h 16 BYTEs	colors for palette registers 00h through 0Fh
 10h	BYTE	border color

Format of current font names table (v2+):
Offset	Size	standard EGA	HiRes EGA	VGA
 00h  8 BYTEs	N/A		F19 font	F20 font
 08h  8 BYTEs	F14 font	F14 font	F14 font
 10h  8 BYTEs	N/A		F11 font	F10 font
 18h  8 BYTEs	F8 font		F8 font		F8 font

Format of current font names table (v1.x):
Offset	Size	HiRes EGA
 00h  8 BYTEs	F19/F14 font
 08h  8 BYTEs	F11/F8 font
--------V-10CD03-----------------------------
INT 10 - VIDEO - UltraVision - GET PALETTE LOCKING STATUS (color EGA,VGA)
	AX = CD03h
Return: CL = palette locking value
	    00h none
	    01h text modes only
	    FFh all modes
SeeAlso: AX=CD01h
--------V-10CD04-----------------------------
INT 10 - VIDEO - UltraVision - GET UltraVision TEXT MODE (EGA,VGA)
	AX = CD04h
Return: AL = mode number (see below)
SeeAlso: AH=0Fh,AX=CC00h,AH=CDh

Values for video mode number:
 11h	80x25
 12h	80x43, 80x50
 13h	80x34, 80x36
 14h	80x60, 80x63
 19h	94x25
 1Ah	94x43, 94x50
 1Bh	94x36
 1Ch	94x63
 21h	108x25
 22h	108x43, 108x50
 23h	107x34, 108x36
 24h	108x60, 108x63
 31h	120x25
 32h	120x43, 120x50
 33h	132x25
 34h	132x44, 132x50
 39h	120x36
 3Ah	120x63
 3Bh	132x36
 3Ch	132x60
Index:	video modes
--------V-10CD05-----------------------------
INT 10 - VIDEO - UltraVision - SET CURSOR TYPE (EGA,VGA)
	AX = CD05h
	CL = type
	    00h line cursor
	    FFh box cursor
Note:	sets default cursor type for text-based programs
SeeAlso: AH=01h,AX=CD06h
--------V-10CD06-----------------------------
INT 10 - VIDEO - UltraVision - GET CURSOR TYPE (EGA,VGA)
	AX = CD06h
Return: CL = type
	    00h line cursor
	    FFh box cursor
SeeAlso: AH=03h,AX=CD05h
--------V-10CD07-----------------------------
INT 10 - VIDEO - UltraVision v1.2+ - SET UNDERLINE STATUS (EGA,VGA)
	AX = CD07h
	CL = hardware underline status
	    00h off (color systems only)
	    01h underline below characters
	    02h strike through characters
	BL = foreground color for normal text (FFh = current)
	BH = foreground color for bright text (FFh = current)
Return: CL = hardware underline status
	BL = current foreground color for normal text
	BH = current foreground color for bright text
Notes:	when underline or strikeout is enabled in color text modes, the
	  specified colors will be assigned temporarily to colors 01h and 09h,
	  allowing affected text to match non-underlined text.	The color
	  remapping uses values from the current onscreen palette regardless
	  of the palette locking status (see AX=CD01h)
	specify the standard colors (BL=01h,BH=09h) to enable underline or
	  strikeout without color remapping
SeeAlso: AX=CD08h
--------V-10CD08-----------------------------
INT 10 - VIDEO - UltraVision v1.2+ - GET UNDERLINE STATUS (EGA,VGA)
	AX = CD08h
Return: CL = hardware underline status (see AX=CD07h)
	BL = foreground color for normal text
	BH = foreground color for bright text
Note:	only CL is valid on monochrome EGA systems
SeeAlso: AX=CD07h
--------V-10CD10-----------------------------
INT 10 - VIDEO - UltraVision - LOAD USER FONT (EGA,VGA)
	AX = CD10h
	BH = bytes per character (08h,0Ah,0Bh,0Eh,13h,14h)
	CX = ABCDh load 9xN alternate font (v2+)
	   else number of characters to load
		DX = character offset into font table
		DS:SI -> 8-byte ASCII font name
	ES:BP -> font definitions
Return: AX = FFFFh if invalid font parameters
Notes:	loads the designated characters into UltraVision's resident font area
	should be followed by a video mode set to reload character generator
SeeAlso: AX=1100h
--------V-10CD-------------------------------
INT 10 - VIDEO - UltraVision - SET ULTRAVISION TEXT MODE (EGA,VGA)
	AH = CDh
	AL = text mode number (see AX=CD04h)
Return: AX = CDCDh if invalid mode
SeeAlso: AX=CD04h
--------A-10D0-------------------------------
INT 10 - CU Writer v1.4 - LOAD PICTURE
	AH = D0h
	???
Return: ???
SeeAlso: AH=B0h"CU Writer",AH=C4h
--------V-10D5-------------------------------
INT 10 - Netroom SCRNCLK - ???
	AH = D5h
	???
Return: ???
Program: SCRNCLK is a "cloaked" screen accelerator included with Netroom
--------V-10DFA5-----------------------------
INT 10 U - VIDEO - Compaq ADAPT.COM - GET ??? DATA AREA
	AX = DFA5h
Return: AX = BDBFh if supported
	    ES:DI -> ??? data area
	    BX = ES
SeeAlso: AX=BFA0h
--------V-10EF-------------------------------
INT 10 - VIDEO - MSHERC.COM - GET VIDEO ADAPTER TYPE AND MODE
	AH = EFh
Return: DL = video adapter type
	    00h original Hercules
	    01h Hercules Plus
	    02h Hercules InColor???
	DH = memory mode byte
	    01h "half" mode
	    03h "full" mode
Program: MSHERC.COM is a support program for the Microsoft Quick languages which
	  makes their graphics libraries compatible with a Hercules card by
	  adding video modes 08h and 88h, and supporting text in the new
	  graphics modes.
Notes:	while in mode 08h or 88h, INT 10 supports the Hercules card much like
	  a CGA.
	MSHERC performs an installation check by setting DL=FFh and testing
	  whether it has been changed on return
Index:	installation check;MSHERC
--------V-10F0-------------------------------
INT 10 - EGA Register Interface Library - READ ONE REGISTER
	AH = F0h
	BL = register number
	BH = 00h
	DX = group index
	    Pointer/data chips
	       00h CRT Controller (25 reg) 3B4h mono modes, 3D4h color modes
	       08h Sequencer (5 registers) 3C4h
	       10h Graphics Controller (9 registers) 3CEh
	       18h Attribute Controller (20 registers) 3C0h
	    Single registers
	       20h Miscellaneous Output register 3C2h
	       28h Feature Control register (3BAh mono modes, 3DAh color modes)
	       30h Graphics 1 Position register 3CCh
	       38h Graphics 2 Position register 3CAh
Return: BL = data
Note:	the RIL is provided by EGA.SYS, the Microsoft Mouse driver, the OS/2
	  compatibility box, and others
SeeAlso: AH=F1h,AH=F2h,INT 2F/AX=BC00h
--------V-10F1-------------------------------
INT 10 - EGA Register Interface Library - WRITE ONE REGISTER
	AH = F1h
	DX = group index (see AH=F0h)
	    if single register:
		BL = value to write
	    otherwise
		BL = register number
		BH = value to write
Return: BL = data
Note:	the RIL is provided by EGA.SYS, the Microsoft Mouse driver, the OS/2
	  compatibility box, and others
SeeAlso: AX=7F05h,AH=F0h,AH=F3h
--------V-10F2-------------------------------
INT 10 - EGA Register Interface Library - READ REGISTER RANGE
	AH = F2h
	CH = starting register number
	CL = Number of registers (>1)
	DX = group index
	     00h CRTC (3B4h mono modes, 3D4h color modes)
	     08h Sequencer 3C4h
	     10h Graphics Controller 3CEh
	     18h Attribute Controller 3C0h
	ES:BX -> buffer, CL bytes
Note:	the RIL is provided by EGA.SYS, the Microsoft Mouse driver, the OS/2
	  compatibility box, and others
SeeAlso: AH=F0h,AH=F3h
--------V-10F3-------------------------------
INT 10 - EGA Register Interface Library - WRITE REGISTER RANGE
	AH = F3h
	CH = starting register
	CL = number of registers (>1)
	DX = group index (see AH=F2h)
	ES:BX -> buffer, CL bytes
Note:	the RIL is provided by EGA.SYS, the Microsoft Mouse driver, the OS/2
	  compatibility box, and others
SeeAlso: AX=7F05h,AH=F1h,AH=F2h
--------V-10F4-------------------------------
INT 10 - EGA Register Interface Library - READ REGISTER SET
	AH = F4h
	CX = number of registers to read (>1)
	ES:BX -> table of records (see below)
Return: register values in table filled in
Note:	the RIL is provided by EGA.SYS, the Microsoft Mouse driver, the OS/2
	  compatibility box, and others
SeeAlso: AH=F0h,AH=F2h,AH=F5h

Format of entries in table of register records:
Offset	Size	Description
 00h	WORD	group index
		Pointer/data chips
		   00h CRTC (3B4h mono modes, 3D4h color modes)
		   08h Sequencer 3C4h
		   10h Graphics Controller 3CEh
		   18h Attribute Controller 3C0h
		Single registers
		   20h Miscellaneous Output register 3C2h
		   28h Feature Control register (3BAh mono modes, 3DAh color)
		   30h Graphics 1 Position register 3CCh
		   38h Graphics 2 Position register 3CAh
 02h	BYTE	register number (0 for single registers)
 03h	BYTE	register value
--------V-10F5-------------------------------
INT 10 - EGA Register Interface Library - WRITE REGISTER SET
	AH = F5h
	CX = number of registers to write (>1)
	ES:BX -> table of records (see AH=F4h)
Note:	the RIL is provided by EGA.SYS, the Microsoft Mouse driver, the OS/2
	  compatibility box, and others
SeeAlso: AX=7F05h,AH=F1h,AH=F3h,AH=F4h
--------V-10F6-------------------------------
INT 10 - EGA Register Interface Library - REVERT TO DEFAULT REGISTERS
	AH = F6h
Note:	provided by the Microsoft Mouse driver, OS/2 compatibility box, and
	  others
SeeAlso: AH=F7h
--------V-10F7-------------------------------
INT 10 - EGA Register Interface Library - DEFINE DEFAULT REGISTER TABLE
	AH = F7h
	DX = port number
	   Pointer/data chips
	      00h CRTC (3B4h mono modes, 3D4h color modes)
	      08h Sequencer 3C4h
	      10h Graphics Controller 3CEh
	      18h Attribute Controller 3C0h
	   Single registers
	      20h Miscellaneous Output register 3C2h
	      28h Feature Control register (3BAh mono modes, 3DAh color modes)
	      30h Graphics 1 Position register 3CCh
	      38h Graphics 2 Position register 3CAh
	ES:BX -> table of one-byte entries, one byte to be written to each
		 register
Note:	the RIL is provided by EGA.SYS, the Microsoft Mouse driver, the OS/2
	  compatibility box, and others
SeeAlso: AH=F6h
--------V-10FA--BX0000-----------------------
INT 10 - EGA Register Interface Library - INTERROGATE DRIVER
	AH = FAh
	BX = 0000h
Return: BX = 0000h if RIL driver not present
	ES:BX -> EGA Register Interface version number, if present:
	    byte 0 = major release number
	    byte 1 = minor release number
Note:	the RIL is provided by EGA.SYS, the Microsoft Mouse driver, the OS/2
	  compatibility box, and others
SeeAlso: AH=F6h,INT 2F/AX=BC00h
--------K-10FA-------------------------------
INT 10 - FASTBUFF.COM - INSTALLATION CHECK
	AH = FAh
Return: AX = 00FAh if installed
	    ES = segment of resident code
Program: FASTBUFF.COM is a keyboard speedup/screen blanking utility by David
	  Steiner
Index:	screen saver;FASTBUFF
--------V-10FE-------------------------------
INT 10 - TopView - GET SHADOW BUFFER
	AH = FEh
	ES:DI -> assumed video buffer
		B800h:0000h color text/CGA graphics, B000h:0000h mono text,
		  or A000h:0000h EGA/VGA graphics (RSIS environments only)
Return: ES:DI -> actual video buffer for calling process
Desc:	Determine the address of the virtual screen to which the program
	  should write instead of the actual video memory; this permits
	  programs to be multitasked without interfering with each other's
	  output, and allows memory managers to move the video memory to
	  permit larger programs to be loaded.
Notes:	if no multitasker or RSIS-compliant environment is installed, ES:DI is
	  returned unchanged; RSIS is the Relocated Screen Interface
	  Specification
	for display pages other than 0, use AH=05h and AH=0Fh to determine
	  whether a particular page exists
	TopView requires a call to AH=FFh to notify it that the screen has
	  changed; DESQview will check for changes itself until the first call
	  to AH=FFh
SeeAlso: AH=05h,AX=5201h,AH=FFh,INT 15/AX=1024h,INT 21/AH=2Bh"DESQview"
SeeAlso: INT 21/AH=ECh"DoubleDOS"
--------V-10FF-------------------------------
INT 10 - TopView - UPDATE SCREEN FROM SHADOW BUFFER
	AH = FFh
	CX = number of consecutive changed characters
	ES:DI -> first changed character in shadow buffer
Notes:	avoid CX=0000h
	DESQview will discontinue the automatic screen updating initiated by
	  AH=FEh after this call
	not supported (ignored) by DESQview/X 1.0x
SeeAlso: AH=93h,AH=FEh
--------E-10FF-------------------------------
INT 10 - DJ GO32.EXE 80386+ DOS extender - VIDEO EXTENSIONS
	AH = FFh
	AL = video mode (see below)
Program: GO32.EXE is a DOS extender included as part of the 80386 port of the
	  GNU C/C++ compiler by DJ Delorie and distributed as DJGPP
SeeAlso: AH=00h,INT 21/AH=FFh"GO32"

Values for video mode number:
 00h	80x25 text
 01h	default text
 02h	CXxDX text
 03h	biggest text
 04h	320x200 graphics
 05h	default graphics
 06h	CXxDX graphics
 07h	biggest non-interlaced graphics
 08h	biggest graphics
Index:	video modes
--------V-10FF-------------------------------
INT 10 - VIDEO - Oak VGA BIOS v1.02+ - SET EMULATION
	AH = FFh
	AL = emulation
	    43h ('C') CGA emulation
	    45h ('E') EGA emulation
	    4Dh ('M') Hercules emulation
	    56h ('V') VGA emulation
	ES:DI -> 'Calamity'
Return: VGA switched to suggested mode
SeeAlso: AH=00h,AX=007Fh,AX=5F01h
--------R-10FF00-----------------------------
INT 10 - CARBON COPY PLUS v5.0 - CHECK IF CC CONNECTED TO CCHELP
	AX = FF00h
Return: BL = 00h not connected
	   = 01h connected
SeeAlso: AX=FF01h,AX=FF02h
--------R-10FF01-----------------------------
INT 10 - CARBON COPY PLUS v5.0 - DISCONNECT AND RESET LINE
	AX = FF01h
SeeAlso: AX=FF00h,AX=FF02h
--------R-10FF02-----------------------------
INT 10 - CARBON COPY PLUS v5.0 - GET LAST PHONE NUMBER DIALED
	AX = FF02h
Return: ES:DI -> ASCIZ phone number
SeeAlso: AX=FF00h,AX=FF01h
--------C-11---------------------------------
INT 11 - CPU-generated (80486+) - ALIGNMENT CHECK
Desc:	automatically generated by the CPU when the AC flag is set, the current
	  privilege level is 3, and a misaligned memory access (WORD not on an
	  even address or DWORD not on a multiple of 4) is made
Note:	not all V86 monitors allow the AC flag to be set, such as Turbo
	  Debugger 386
--------B-11---------------------------------
INT 11 - BIOS - GET EQUIPMENT LIST
Return: AX = BIOS equipment list word
	    bits
	    0	  floppy disk(s) installed (see bits 6-7)
	    1	  80x87 coprocessor installed
	    2,3	  number of 16K banks of RAM on motherboard (PC only)
		  number of 64K banks of RAM on motherboard (XT only)
	    2	  pointing device installed (PS)
	    3	  unused (PS)
	    4-5	  initial video mode
		  00 EGA, VGA, or PGA
		  01 40x25 color
		  10 80x25 color
		  11 80x25 monochrome
	    6-7	  number of floppies installed less 1 (if bit 0 set)
	    8	  DMA support installed (PCjr, some Tandy 1000s, 1400LT)
	    9-11  number of serial ports installed
	    12	  game port installed
	    13	  serial printer attached (PCjr)
		  internal modem installed (PC/Convertible)
	    14-15 number of parallel ports installed
---Compaq and many other 386/486 machines--
	EAX bit 23: page tables set so that Weitek coprocessor addressable in
			real mode
	    bit 24: Weitek math coprocessor present
---Compaq Systempro
	EAX bit 25: internal DMA parallel port available
		26: IRQ for internal DMA parallel port (if bit 25 set)
		    0 = IRQ5
		    1 = IRQ7
	     27,28: parallel port DMA channel
		    00 DMA channel 0
		    01 DMA channel 0 ???
		    10 reserved
		    11 DMA channel 3
SeeAlso: INT 12
--------d-11----SI6A6A-----------------------
INT 11 - Columbia Data Products Standard Device Level Protocol (SDLP) 1.6
	SI = 6A6Ah
	AH = command (see below)
	AL = SCSI Addressing
	    bits 2-0 SCSI Target LUN (logical unit number)
	    bits 5-3 SCSI Target ID
	    bits 7-6 Host Adapter
Return: CF clear if successful
	    DI = 6A6Ah if AH=01h on entry (maybe for all functions???)
	    AH = ??? for command 01h
	CF set on error
	    AL = error code
SeeAlso: INT 21/AX=4402h"ASPI"

Values for SDLP command:
 00h	SDLP initialization
 01h	SDLP System Identify
 02h	simple read sectors
 03h	simple write sectors
 04h	simple verify sectors/seek to sector
 05h	get device size/type
 06h	ready unit
 07h	format unit
 08h	diagnostics
 09h	rewind
 0Ah	erase
 0Bh	write filemarks
 0Ch	space
 0Dh	prevent/allow media removal
 0Eh	load/unload media
 0Fh	reserved - returns good status
 10h	set block size
 11h	write setmark
 12h	set error level
 13h	get address of Request Sense Buffer
 14h	get SDLP error via Request Sense
 F0h	Vendor Unique Function (WD7000-FASST2 only)
 FDh	reset current SCSI HAC
 FEh	get/set current SCSI HAC
 FFh	execute SCSI command
----------110225BX6900-----------------------
INT 11 - Blank-It Screen Blanker - INSTALLATION CHECK
	AX = 0225h
	BX = 6900h
Return: BL = 23h
	ES:DI -> ASCIIZ "BLNKIT"
Program: Blank-It is a resident screen blanker by Rhode Island Soft Systems,
	  Inc.
SeeAlso: AX=0225h/BX=6902h,AX=0225h/BX=6908h,AX=0225h/BX=6909h
Index:	screen saver;Blank-It
----------110225BX6901-----------------------
INT 11 - Blank-It Screen Blanker - SET TIMEOUT FOR SCREEN BLANKING
	AX = 0225h
	BX = 6901h
	CX = timeout in timer ticks (18.2/second) or 0000h to disable timeout
	     largest value is 59 minutes (FBACh or 64428)
Return: CF clear if successful
	    DI = 6A6Ah (possibly also 6A6Ah for all following functions)
	    AH = ???
	CF set on error
	    AL = error code
SeeAlso: AX=0225h/BX=6900h,AX=0252h/BX=6904h
Index:	screen saver;Blank-It
----------110225BX6902-----------------------
INT 11 - Blank-It Screen Blanker - ENABLE THE SOFTWARE
	AX = 0225h
	BX = 6902h
Return: CF clear if successful
	CF set on error
	    AL = error code
SeeAlso: AX=0225h/BX=6900h,AX=0252h/BX=6903h
Index:	screen saver;Blank-It
----------110225BX6903-----------------------
INT 11 - Blank-It Screen Blanker - DISABLE THE SOFTWARE
	AX = 0225h
	BX = 6903h
Return: CF clear if successful
	CF set on error
	    AL = error code
SeeAlso: AX=0225h/BX=6900h,AX=0252h/BX=6902h
Index:	screen saver;Blank-It
----------110225BX6904-----------------------
INT 11 - Blank-It Screen Blanker - GET BLANKING TIMEOUT
	AX = 0225h
	BX = 6904h
Return: CF clear if successful
	    BX = timeout (see BX=6901h)
	CF set on error
	    AL = error code
SeeAlso: AX=0225h/BX=6900h,AX=0252h/BX=6901h
Index:	screen saver;Blank-It
----------110225BX6905-----------------------
INT 11 - Blank-It Screen Blanker - ENABLE WINDOWS COMPATIBILITY MODE
	AX = 0225h
	BX = 6905h
Return: CF clear if successful
	CF set on error
	    AL = error code
SeeAlso: AX=0225h/BX=6900h,AX=0252h/BX=6906h
Index:	screen saver;Blank-It
----------110225BX6906-----------------------
INT 11 - Blank-It Screen Blanker - DISABLE WINDOWS COMPATIBILITY MODE
	AX = 0225h
	BX = 6906h
Return: CF clear if successful
	CF set on error
	    AL = error code
Program: Blank-It is a resident screen blanker by Rhode Island Soft Systems,
	  Inc.
SeeAlso: AX=0225h/BX=6900h,AX=0252h/BX=6905h
Index:	screen saver;Blank-It
----------110225BX6907-----------------------
INT 11 - Blank-It Screen Blanker - UNBLANK THE SCREEN
	AX = 0225h
	BX = 6907h
Return: CF clear if successful
	CF set on error
	    AL = error code
SeeAlso: AX=0225h/BX=6900h,AX=0252h/BX=6908h
Index:	screen saver;Blank-It
----------110225BX6908-----------------------
INT 11 - Blank-It Screen Blanker - BLANK THE SCREEN
	AX = 0225h
	BX = 6908h
Return: CF clear if successful
	CF set on error
	    AL = error code
SeeAlso: AX=0225h/BX=6900h,AX=0252h/BX=6907h
Index:	screen saver;Blank-It
----------110225BX6909-----------------------
INT 11 - Blank-It Screen Blanker - SET HOTKEY FOR MANUAL BLANKING
	AX = 0225h
	BX = 6909h
	CL = key scan code (see below)
Return: CF clear if successful
	CF set on error
	    AL = error code
Program: Blank-It is a resident screen blanker by Rhode Island Soft Systems,
	  Inc.
SeeAlso: AX=0225h/BX=6900h
Index:	screen saver;Blank-It|hotkeys;Blank-It

Values for key scan code:
 00h	No hot key
 1Dh	Left CTRL
 2Ah	Left Shift
 36h	Right Shift
 57h	F11
 58h	F12
----------1105D7-----------------------------
INT 11 CU - Borland C++ IDE - INSTALLED CALLOUT
	AX = 05D7h
	BX = product ID (0088h)
Note:	called by the BC++ IDE when an application calls
	  INT 12/AX=05D7h/BX=05D7h
SeeAlso: INT 12/AX=05D7h/BX=05D7h
Index:	installation check;Borland C++ IDE
--------F-1177-------------------------------
INT 11 - RainbowFAX v1.3 - SFENGINE API - OPERATIONAL CONTROL
	AH = 77h
	AL = subfunction
	    01h request SFENGINE start
		Return: AX = 0001h
	    02h check if SFENGINE started
		Return: AX = 0000h or 0001h
	    03h request SFENGINE stop
		Return: AX = 0001h
	    04h check if SFENGINE stopped
		Return: AX = 0000h or 0001h
	    05h installation check
		Return: AX = 0001h
	    06h uninstall???
		BX:DX -> return address for successful uninstall???
		Return: (at caller's address)
			AX = 0000h
	    else
		Return: AX = FFFFh
Return: ES:DX -> ASCIZ signature string "SFAX ENGINE V1.0"
		followed by internal data area???
SeeAlso: AH=78h,AH=79h,AH=7Ah,AH=7Ch
Index:	installation check;RainboxFAX|installation check;SFENGINE
Index:	uninstall;RainboxFAX|uninstall;SFENGINE
--------F-1178-------------------------------
INT 11 - RainboxFAX v1.3 - SFENGINE API - ???
	AH = 78h
	AL = subfunction
	    7801h set ???
		BX = new state for ???
		    0000h ???
		    else ???
		Return: AX = 0001h
	    7802h set ???
		BX = ???
		CX = ???
		Return: AX = 0001h
	    7803h set ???
		BX = new state for ???
		    0000h ???
		    else ???
		Return: AX = 0001h
	    78XXh invalid subfunction
		Return: AX = FFFFh
SeeAlso: AH=77h,AH=79h,AH=7Ah,AH=7Ch
--------F-1179-------------------------------
INT 11 - RainboxFAX v1.3 - SFENGINE API - ???
	AH = 79h
	AL = subfunction
	    01h set ??? flag
		Return: AX = previous state (0000h already set, 0001h clear)
	    02h clear ??? flag (see subfunc 01h)
		Return: AX = 0001h
	    03h set ??? flag (different from subfn 02h or 04h)
		Return: AX = 0001h
	    04h clear ??? flag (different from subfn 02h or 03h)
		Return: AX = 0001h
	    else
		Return: AX = FFFFh
SeeAlso: AH=77h,AH=78h,AH=7Ah,AH=7Ch
--------F-117A-------------------------------
INT 11 - RainboxFAX v1.3 - SFENGINE API - ???
	AH = 7Ah
	AL = subfunction
	    01h set ??? flag
		Return: AX = previous state (0000h already set, 0001h clear)
	    02h clear ??? flag
		Return: AX = 0001h
	    03h set ??? flag (different from subfn 02h)
		Return: AX = 0001h
	    else
		Return: AX = FFFFh
SeeAlso: AH=77h,AH=78h,AH=79h,AH=7Ch
--------F-117C-------------------------------
INT 11 - RainboxFAX v1.3 - SFENGINE API - ???
	AH = 7Ch
	AL = subfunction
	    01h set ??? flag (see also subfn 02h)
		Return: AX = 0001h
	    02h clear ??? flag (see also subfn 01h)
		Return: AX = 0001h
	    else
		Return: AX = FFFFh
SeeAlso: AH=77h,AH=78h,AH=79h,AH=7Ah
--------S-11BC--DX1954-----------------------
INT 11 - BNU FOSSIL - INSTALLATION CHECK
	AH = BCh
	DX = 1954h
Return: AX = 1954h
	ES:DX -> entry point of driver (instead of INT 14)
SeeAlso: INT 14/AH=04h"FOSSIL"
--------d-11FF--SI6A6A-----------------------
INT 11 - WD7000 SDLP interface - EXECUTE GENERIC SCSI COMMAND
	AH = FFh
	SI = 6A6Ah
	AL = SCSI Addressing
	    bits 2-0 SCSI Target LUN (logical unit number)
	    bits 5-3 SCSI Target ID
	    bit 7    write flag, set for write operations, clear otherwise
	CX = bytes of data to be transmitted (max FFF0h)
	DH = 00h
	DL = length of SCSI Command Descriptor Block
	DS:DI -> SCSI Command Descriptor Block
	ES:BX -> data buffer
Return: CF set on error
	    AL = error code
	CF clear if successful
Note:	because of busmaster operations with WD7000FASST avoid accessing
	  video memory directly; check 386 memory manager for VDS support.
	  The WD7000XTAT works with programmed IO and does not have this
	  limitation.
SeeAlso: INT 21/AX=4402h"ASPI",INT 2F/AX=7F01h
--------T-11FFFECXFFFE-----------------------
INT 11 - BACK&FORTH (before v1.62) API
	AX = FFFEh
	CX = FFFEh
	BX = function
	    00h installation check
		Return: AX = 0001h BNFHIGH and BNFLOW both loaded
			   = 0003h only BNFHIGH loaded
			   else neither loaded
	    01h ???
		Return: DX:AX -> ???
	    02h ???
	    03h ???
	    04h ???
	    05h ??? switches current PSP segment and stack if BNFLOW has not
		    yet announced itself installed
	    06h ???
		Return: AX = ???
SeeAlso: INT 12/AX=FFFEh
Index:	installation check;BACK&FORTH
--------B-12---------------------------------
INT 12 - BIOS - GET MEMORY SIZE
Return: AX = kilobytes of contiguous memory starting at absolute address 00000h
Note:	this call returns the contents of the word at 0040h:0013h; in PC and
	  XT, this value is set from the switches on the motherboard
SeeAlso: INT 11,INT 2F/AX=4A06h
--------K-12----CX1806-----------------------
INT 12 - KEYBUI v2.0+ - INSTALLATION CHECK
	CX = 1806h
Return: AX = kilobytes of contiguous memory starting at absolute address 00000h
	CX = 1960h if installed
Program: KEYBUI is a resident keyboard driver by Johan Zwiekhorst which allows
	  accented characters and box drawing on standard QWERTY keyboards; it
	  also provides break-to-DOS and screen blanking capabilities
Index:	screen saver;KEYBUI
--------d-12----CX1807-----------------------
INT 12 - PARKER v2.0+ - INSTALLATION CHECK
	CX = 1807h
Return: AX = kilobytes of contiguous memory starting at absolute address 00000h
	CX = 1961h if installed
Program: PARKER is an optionally-resident hard disk parking program by Johan
	  Zwiekhorst
----------1205D7BX05D7-----------------------
INT 12 U - Borland C++ IDE - INSTALLATION CHECK
	AX = 05D7h (1495d)
	BX = 05D7h
Note:	the BC++ IDE will call INT 11/AX=05D7h/BX=0088h if it is loaded
SeeAlso: INT 11/AX=05D7h/BX=0088h
--------T-12FFFECXFFFE-----------------------
INT 12 - Back&Forth v1.62+ - API
	AX = FFFEh
	CX = FFFEh
	BX = function
	    00h installation check
		Return: AX = 0001h installed
			     else  not loaded
	    02h build program ID list
		ES:DI -> buffer of at least 100 bytes, to be filled with words
		Return: AX = number of programs defined
			ES:DI buffer filled with AX words
	    03h switch to specified task (task need not be open yet)
		DX = two-letter program ID
		Return: AX = 0000h if task undefined
	    04h ???
	    05h ???
	    06h get version (undoc)
		Return: AX = version * 100 (v1.71 = 00ABh)
	    07h ???
	    08h get open tasks (undoc)
		ES:DI -> task info buffer (see below)
		Return: AX = number of open tasks (max 20)
	    09h ???
Program: Back & Forth is a task switcher by Progressive Solutions, Inc.
SeeAlso: INT 11/AX=FFFEh
Index:	installation check;BACK&FORTH

Format of task info buffer:
Offset	Size	Description
 00h 21 BYTEs	ASCIZ task name
 15h	BYTE	hotkey shift state (as for INT 16/AH=02h)
 16h	WORD	hotkey scan code
 18h	WORD	program ID
Index:	hotkeys;Back&Forth
--------B-1300-------------------------------
INT 13 - DISK - RESET DISK SYSTEM
	AH = 00h
	DL = drive (if bit 7 is set both hard disks and floppy disks reset)
Return: AH = status (see AH=01h)
	CF clear if successful (returned AH=00h)
	CF set on error
Note:	forces controller to recalibrate drive heads (seek to track 0)
SeeAlso: AH=0Dh,AH=11h,INT 21/AH=0Dh,INT 4E"TI Professional"
--------B-1301-------------------------------
INT 13 - DISK - GET STATUS OF LAST OPERATION
	AH = 01h
	DL = drive (bit 7 set for hard disk)
Return: CF clear if successful (returned status 00h)
	CF set on error
	AH = status of previous operation (see below)
Note:	some BIOSes return the status in AL; the PS/2 Model 30/286 returns the
	  status in both AH and AL

Values for status:
 00h	successful completion
 01h	invalid function in AH or invalid parameter
 02h	address mark not found
 03h	disk write-protected
 04h	sector not found/read error
 05h	reset failed (hard disk)
 06h	disk changed (floppy)
 07h	drive parameter activity failed (hard disk)
 08h	DMA overrun
 09h	attempted DMA across 64K boundary
 0Ah	bad sector detected (hard disk)
 0Bh	bad track detected (hard disk)
 0Ch	unsupported track or invalid media
 0Dh	invalid number of sectors on format (hard disk)
 0Eh	control data address mark detected (hard disk)
 0Fh	DMA arbitration level out of range (hard disk)
 10h	uncorrectable CRC or ECC error on read
 11h	data ECC corrected (hard disk)
 20h	controller failure
 40h	seek failed
 80h	timeout (not ready)
 AAh	drive not ready (hard disk)
 BBh	undefined error (hard disk)
 CCh	write fault (hard disk)
 E0h	status register error (hard disk)
 FFh	sense operation failed (hard disk)
--------B-1302-------------------------------
INT 13 - DISK - READ SECTOR(S) INTO MEMORY
	AH = 02h
	AL = number of sectors to read (must be nonzero)
	CH = low eight bits of cylinder number
	CL = sector number 1-63 (bits 0-5)
	     high two bits of cylinder (bits 6-7, hard disk only)
	DH = head number
	DL = drive number (bit 7 set for hard disk)
	ES:BX -> data buffer
Return: CF set on error
	    if AH = 11h (corrected ECC error), AL = burst length
	CF clear if successful
	AH = status (see AH=01h)
	AL = number of sectors transferred
Notes:	errors on a floppy may be due to the motor failing to spin up quickly
	  enough; the read should be retried at least three times, resetting
	  the disk with AH=00h between attempts
	the IBM AT BIOS and many other BIOSes use only the low four bits of
	  DH (head number) since the WD-1003 controller which is the standard
	  AT controller (and the controller that IDE emulates) only supports
	  16 heads
	AWARD AT BIOS and AMI 386sx BIOS have been extended to handle more
	  than 1024 cylinders by placing bits 10 and 11 of the cylinder number
	  into bits 6 and 7 of DH
SeeAlso: AH=03h,AH=0Ah
--------B-1303-------------------------------
INT 13 - DISK - WRITE DISK SECTOR(S)
	AH = 03h
	AL = number of sectors to write (must be nonzero)
	CH = low eight bits of cylinder number
	CL = sector number 1-63 (bits 0-5)
	     high two bits of cylinder (bits 6-7, hard disk only)
	DH = head number
	DL = drive number (bit 7 set for hard disk)
	ES:BX -> data buffer
Return: CF set on error
	CF clear if successful
	AH = status (see AH=01h)
	AL = number of sectors transferred
Notes:	errors on a floppy may be due to the motor failing to spin up quickly
	  enough; the write should be retried at least three times, resetting
	  the disk with AH=00h between attempts
	the IBM AT BIOS and many other BIOSes use only the low four bits of
	  DH (head number) since the WD-1003 controller which is the standard
	  AT controller (and the controller that IDE emulates) only supports
	  16 heads
	AWARD AT BIOS and AMI 386sx BIOS have been extended to handle more
	  than 1024 cylinders by placing bits 10 and 11 of the cylinder number
	  into bits 6 and 7 of DH
SeeAlso: AH=02h,AH=0Bh
--------B-1304-------------------------------
INT 13 - DISK - VERIFY DISK SECTOR(S)
	AH = 04h
	AL = number of sectors to verify (must be nonzero)
	CH = low eight bits of cylinder number
	CL = sector number 1-63 (bits 0-5)
	     high two bits of cylinder (bits 6-7, hard disk only)
	DH = head number
	DL = drive number (bit 7 set for hard disk)
	ES:BX -> data buffer (PC,XT,AT with BIOS prior to 11/15/85)
Return: CF set on error
	CF clear if successful
	AH = status (see AH=01h)
	AL = number of sectors verified
Notes:	errors on a floppy may be due to the motor failing to spin up quickly
	  enough; the write should be retried at least three times, resetting
	  the disk with AH=00h between attempts
	this function does not compare the disk with memory, it merely
	  checks whether the sector's stored CRC matches the data's actual CRC
	the IBM AT BIOS and many other BIOSes use only the low four bits of
	  DH (head number) since the WD-1003 controller which is the standard
	  AT controller (and the controller that IDE emulates) only supports
	  16 heads
	AWARD AT BIOS and AMI 386sx BIOS have been extended to handle more
	  than 1024 cylinders by placing bits 10 and 11 of the cylinder number
	  into bits 6 and 7 of DH
SeeAlso: AH=02h
--------B-1305-------------------------------
INT 13 - FLOPPY - FORMAT TRACK
	AH = 05h
	AL = number of sectors to format
	CH = track number
	DH = head number
	DL = drive number
	ES:BX -> address field buffer (see below)
Return: CF set on error
	CF clear if successful
	AH = status (see AH=01h)
Notes:	on AT or higher, call AH=17h first
	the number of sectors per track is read from the diskette parameter
	  table pointed at by INT 1E
SeeAlso: AH=05h"FIXED",AH=17h,AH=18h,INT 1E

Format of address field buffer entry (one per sector in track):
Offset	Size	Description
 00h	BYTE	track number
 01h	BYTE	head number (0-based)
 02h	BYTE	sector number
 03h	BYTE	sector size (00h=128 bytes, 01h=256 bytes, 02h=512, 03h=1024)
--------B-1305-------------------------------
INT 13 - FIXED DISK - FORMAT TRACK
	AH = 05h
	AL = interleave value (XT-type controllers only)
	ES:BX -> 512-byte format buffer
		the first 2*(sectors/track) bytes contain F,N for each sector
		   F = 00h for good sector, 80h for bad sector
		   N = sector number
	CH = cylinder number (bits 8,9 in high bits of CL)
	CL = high bits of cylinder number (bits 7,6)
	DH = head
	DL = drive
Return: AH = status code (see AH=01h)
Notes:	AWARD AT BIOS and AMI 386sx BIOS have been extended to handle more
	  than 1024 cylinders by placing bits 10 and 11 of the cylinder number
	  into bits 6 and 7 of DH
	for XT-type controllers on an AT or higher, AH=0Fh should be called
	  first
	the IBM AT BIOS and many other BIOSes use only the low four bits of
	  DH (head number) since the WD-1003 controller which is the standard
	  AT controller (and the controller that IDE emulates) only supports
	  16 heads
SeeAlso: AH=05h"FLOPPY",AH=06h"FIXED",AH=07h"FIXED",AH=0Fh,AH=18h,AH=1Ah
--------d-1305-------------------------------
INT 13 - Future Domain SCSI BIOS - SEND SCSI MODE SELECT COMMAND
	AH = 05h
	DL = hard drive ID
	ES:BX -> mode select data (see below)
Return: CF set on error
	AH = status code (see AH=01h)
Notes:	this function can be called before AH=07h"SCSI" or AH=06h"SCSI" to
	  format a SCSI disk with the desired parameters
	the mode select data below is from the SCSI-1 specification
	the TMC-950 does not support any Future Domain BIOS calls; instead,
	  it provides a full CAM implementation (see INT 4F/AX=8100h)
SeeAlso: AH=06h"SCSI",AH=07h"SCSI",INT 4F/AX=8100h

Format of mode select data:
Offset	Size	Description
 00h	BYTE	number of bytes of remaining data (12 + vendor unique length)
 01h	BYTE	reserved (0)
 02h	BYTE	medium type (0 for hard disk)
 03h	BYTE	reserved (0)
 04h	BYTE	block descriptor length (8)
 05h	BYTE	density code (0 for hard disk)
 06h  3 BYTEs	(big-endian) number of blocks (000000h for entire disk)
 09h	BYTE	reserved (0)
 0Ah  3 BYTEs	(big-endian) block length (512 standard, or 256)
 0Dh	???	vendor-specific parameter bytes (optional)
--------B-1306-------------------------------
INT 13 - FIXED DISK - FORMAT TRACK AND SET BAD SECTOR FLAGS (XT,PORT)
	AH = 06h
	AL = interleave value
	CH = cylinder number (bits 8,9 in high bits of CL)
	CL = sector number
	DH = head
	DL = drive
Return: AH = status code (see AH=01h)
Note:	AWARD AT BIOS and AMI 386sx BIOS have been extended to handle more
	  than 1024 cylinders by placing bits 10 and 11 of the cylinder number
	  into bits 6 and 7 of DH
SeeAlso: AH=05h"FIXED",AH=07h"FIXED"
--------d-1306-------------------------------
INT 13 - Future Domain SCSI BIOS - FORMAT DRIVE WITH BAD SECTOR MAPPING
	AH = 06h
	AL = interleave
	     (0 = default, 1 = consecutive sectors, 2 - 255 = vendor unique)
	DL = hard drive ID
	DH = bits 7-5 drive LUN
	     bit 4    defect list is available
	     bit 3    defect list is complete (erase drive's defect list)
	     bits 2-0 defect table format
		      (000=use defect table A, 100=use defect table B,
		      101=use defect table C)
	ES:BX ->  defect table A, B or C (see below)
Return: CF set on error
	AH = status code (see AH=01h)
Notes:	block addresses must be in ascending order (for table B, cylinder is
	  most significant, byte from index least significant; for table C,
	  cylinder is most significant, sector number least significant)
	table B defect bytes from index of FFFFFFFFh indicates that the entire
	  track shall be reassigned
	table C defect sector number of FFFFFFFFh indicates that the entire
	  track shall be reassigned
	the TMC-950 does not support any Future Domain BIOS calls; instead,
	  it provides a full CAM implementation (see INT 4F/AX=8100h)
SeeAlso: AH=05h"SCSI",AH=06h"FIXED",AH=07h"SCSI"

Format of defect table A:
Offset	Size	Description
 00h	WORD	number of bytes remaining in table
 02h	BYTE	reserved (0)
 03h	BYTE	reserved (0)
 04h	WORD	(big-endian) defect list length (4*number of defects)
 06h  4 DWORDs	(big-endian) defect block addresses

Format of defect table B:
Offset	Size	Description
 00h	WORD	number of bytes remaining in table
 02h	BYTE	reserved (0)
 03h	BYTE	reserved (0)
 04h	WORD	(big-endian) defect list length (8*number of defects)
 06h 8N BYTEs	defect list [array] (see below)

Format of defect table C:
Offset	Size	Description
 00h	WORD	number of bytes remaining in table
 02h	BYTE	reserved (0)
 03h	BYTE	reserved (0)
 04h	WORD	(big-endian) defect list length (8*number of defects)
 06h 8N BYTEs	defect list [array] (see below)

Format of defect list entry:
Offset	Size	Description
 00h  3 BYTEs	(big-endian) cylinder number of defect
 03h	BYTE	head number of defect
 04h	DWORD	(big-endian) defect bytes from index
--------d-1306-------------------------------
INT 13 - Adaptec AHA-154xA/Bustek BT-542 BIOS - IDENTIFY SCSI DEVICES
	AH = 06h
Return: AH = status code (see AH=01h)
	CF clear if successful
	    AL = first drive supported
		(80h nonconcurrent operation, 81h concurrent operation)
	CF set on error
Desc:	determine the number of the first supported SCSI drive
Note:	the return value is 80h when two SCSI drives are supported, 81h if
	  only one SCSI drive is installed
SeeAlso: AH=08h
--------B-1307-------------------------------
INT 13 - FIXED DISK - FORMAT DRIVE STARTING AT GIVEN TRACK (XT,PORT)
	AH = 07h
	AL = interleave value (XT only)
	ES:BX = 512-byte format buffer (see AH=05h)
	CH = cylinder number (bits 8,9 in high bits of CL)
	CL = sector number
	DH = head
	DL = drive
Return: AH = status code (see AH=01h)
Note:	AWARD AT BIOS and AMI 386sx BIOS have been extended to handle more
	  than 1024 cylinders by placing bits 10 and 11 of the cylinder number
	  into bits 6 and 7 of DH
SeeAlso: AH=05h"FIXED",AH=06h"FIXED",AH=1Ah
--------d-1307-------------------------------
INT 13 - Future Domain SCSI BIOS - FORMAT DRIVE
	AH = 07h
	AL = interleave (0 = default, 1 = consecutive sectors,
	       2 - 255 = vendor unique)
	DL = hard drive ID
Return: CF set on error
	AH = status code (see AH=01h)
SeeAlso: AH=05h"SCSI",AH=06h"SCSI",AH=07h"FIXED"
--------B-1308-------------------------------
INT 13 - DISK - GET DRIVE PARAMETERS (PC,XT286,CONV,PS,ESDI,SCSI)
	AH = 08h
	DL = drive (bit 7 set for hard disk)
Return: CF set on error
	    AH = status (07h) (see AH=01h)
	CF clear if successful
	    AH = 00h
	    BL = drive type (AT/PS2 floppies only) (see below)
	    CH = low eight bits of maximum cylinder number
	    CL = maximum sector number (bits 5-0)
		 high two bits of maximum cylinder number (bits 7-6)
	    DH = maximum head number
	    DL = number of drives
	    ES:DI -> drive parameter table (floppies only)
Notes:	may return successful even though specified drive is greater than the
	  number of attached drives of that type (floppy/hard); check DL to
	  ensure validity
	for systems predating the IBM AT, this call is only valid for hard
	  disks, as it is implemented by the hard disk BIOS rather than the
	  ROM BIOS
	Toshiba laptops with HardRAM return DL=02h when called with DL=80h,
	  but fail on DL=81h.  The BIOS data at 40h:75h correctly reports 01h.
SeeAlso: AH=06h"Adaptec",AH=15h,INT 1E,INT 41

Values for drive type:
 01h	360K
 02h	1.2M
 03h	720K
 04h	1.44M
 05h	??? (reportedly an obscure drive type shipped on some IBM machines)
	2.88M on some machines (at least AMI 486 BIOS)
 06h	2.88M
--------B-1309-------------------------------
INT 13 - HARD DISK - INITIALIZE CONTROLLER WITH DRIVE PARAMETERS (AT,PS)
	AH = 09h
	DL = drive (80h for first, 81h for second)
Return: CF clear if successful
	CF set on error
	AH = status (see AH=01h)
Notes:	on the PC and XT, this function uses the parameter table pointed at by
	  INT 41
	on the AT and later, this function uses the parameter table pointed at
	  by INT 41 if DL=80h, and the parameter table pointed at by INT 46 if
	  DL=81h
SeeAlso: INT 41,INT 46
--------B-130A-------------------------------
INT 13 - HARD DISK - READ LONG SECTOR(S) (AT and later)
	AH = 0Ah
	AL = number of sectors
	CH = low eight bits of cylinder number
	CL = sector number (bits 5-0)
	     high two bits of cylinder number (bits 7-6)
	DH = head number
	DL = drive number (80h = first, 81h = second)
	ES:BX -> data buffer
Return: CF clear if successful
	CF set on error
	AH = status (see AH=01h)
	AL = number of sectors transferred
Notes:	this function reads in four to seven bytes of error-correcting code
	  along with each sector's worth of information
	data errors are not automatically corrected, and the read is aborted
	  after the first sector with an ECC error
	used for diagnostics only on PS/2 systems
SeeAlso: AH=02h,AH=0Bh
--------B-130B-------------------------------
INT 13 - HARD DISK - WRITE LONG SECTOR(S) (AT and later)
	AH = 0Bh
	AL = number of sectors
	CH = low eight bits of cylinder number
	CL = sector number (bits 5-0)
	     high two bits of cylinder number (bits 7-6)
	DH = head number
	DL = drive number (80h = first, 81h = second)
	ES:BX -> data buffer
Return: CF clear if successful
	CF set on error
	AH = status (see AH=01h)
	AL = number of sectors transferred
Notes:	each sector's worth of data must be followed by four to seven bytes of
	  error-correction information
	used for diagnostics only on PS/2 systems
SeeAlso: AH=03h,AH=0Ah
--------B-130C-------------------------------
INT 13 - HARD DISK - SEEK TO CYLINDER
	AH = 0Ch
	CH = low eight bits of cylinder number
	CL = sector number (bits 5-0)
	     high two bits of cylinder number (bits 7-6)
	DH = head number
	DL = drive number (80h = first, 81h = second hard disk)
Return: CF set on error
	CF clear if successful
	AH = status (see AH=01h)
SeeAlso: AH=00h,AH=02h,AH=0Ah
--------d-130D-------------------------------
INT 13 - HARD DISK - RESET HARD DISKS
	AH = 0Dh
	DL = drive number (80h = first, 81h = second hard disk)
Return: CF set on error
	CF clear if successful
	AH = status (see AH=01h)
Notes:	reinitializes the hard disk controller, resets the specified drive's
	  parameters, and recalibrates the drive's heads (seek to track 0)
	not for PS/2 ESDI drives
SeeAlso: AH=00h,INT 21/AH=0Dh
--------B-130E-------------------------------
INT 13 - HARD DISK - READ SECTOR BUFFER (XT only)
	AH = 0Eh
	DL = drive number (80h = first, 81h = second hard disk)
	ES:BX -> buffer
Return: CF set on error
	CF clear if successful
	AH = status code (see AH=01h)
Notes:	transfers controller's sector buffer.  No data is read from the drive
	used for diagnostics only on PS/2 systems
SeeAlso: AH=0Ah
--------B-130F-------------------------------
INT 13 - HARD DISK - WRITE SECTOR BUFFER (XT only)
	AH = 0Fh
	DL = drive number (80h = first, 81h = second hard disk)
	ES:BX -> buffer
Return: CF set on error
	CF clear if successful
	AH = status code (see AH=01h)
Notes:	does not write data to the drive
	should be called before formatting to initialize an XT-type
	  controller's sector buffer
	used for diagnostics only on PS/2 systems
SeeAlso: AH=0Bh
--------B-1310-------------------------------
INT 13 - HARD DISK - CHECK IF DRIVE READY
	AH = 10h
	DL = drive number (80h = first, 81h = second hard disk)
Return: CF set on error
	CF clear if successful
	AH = status (see AH=01h)
--------B-1311-------------------------------
INT 13 - HARD DISK - RECALIBRATE DRIVE
	AH = 11h
	DL = drive number (80h = first, 81h = second hard disk)
Return: CF set on error
	CF clear if successful
	AH = status (see AH=01h)
Note:	causes hard disk controller to seek the specified drive to cylinder 0
SeeAlso: AH=00h,AH=0Ch,AH=19h"FIXED DISK"
--------B-1312-------------------------------
INT 13 - HARD DISK - CONTROLLER RAM DIAGNOSTIC (XT,PS)
	AH = 12h
	DL = drive number (80h = first, 81h = second hard disk)
Return: CF set on error
	CF clear if successful
	AH = status code (see AH=01h)
SeeAlso: AH=13h,AH=14h
--------d-1312-------------------------------
INT 13 - Future Domain SCSI CONTROLLER - STOP SCSI DISK
	AH = 12h
	DL = hard drive ID
Return: CF set on error
	AH = status code (see AH=01h)
Notes:	available at least on the TMC-870 8-bit SCSI controller BIOS v6.0A
	if the given drive is a SCSI device, the SCSI Stop Unit command is sent
	  and either "Disk prepared for shipping" or "Disk Stop command failed"
	  is displayed
	the TMC-950 does not support any Future Domain BIOS calls; instead,
	  it provides a full CAM implementation (see INT 4F/AX=8100h)
--------B-1313-------------------------------
INT 13 - HARD DISK - DRIVE DIAGNOSTIC (XT,PS)
	AH = 13h
	DL = drive number (80h = first, 81h = second hard disk)
Return: CF set on error
	CF clear if successful
	AH = status code (see AH=01h)
SeeAlso: AH=12h,AH=14h
--------B-1314-------------------------------
INT 13 - HARD DISK - CONTROLLER INTERNAL DIAGNOSTIC
	AH = 14h
Return: CF set on error
	CF clear if successful
	AH = status code (see AH=01h)
SeeAlso: AH=12h,AH=13h
--------B-1315-------------------------------
INT 13 - DISK - GET DISK TYPE (XT 1/10/86 or later,XT286,AT,PS)
	AH = 15h
	DL = drive number (bit 7 set for hard disk)
Return: CF clear if successful
	    AH = type code
		00h no such drive
		01h floppy without change-line support
		02h floppy with change-line support
		03h hard disk
		    CX:DX = number of 512-byte sectors
	CF set on error
	    AH = status (see AH=01h)
SeeAlso: AH=08h,AH=16h,AH=17h,AH=19h"SCSI"
--------B-1316-------------------------------
INT 13 - FLOPPY DISK - DETECT DISK CHANGE (XT 1/10/86 or later,XT286,AT,PS)
	AH = 16h
	DL = drive number
Return: CF clear if change line inactive
	    AH = 00h (disk not changed)
	CF set if change line active
	    AH = status
		06h change line active or not supported
		80h drive not ready or not present
Note:	call AH=15h first to determine whether the drive supports a change
	  line
SeeAlso: AH=15h
--------B-1317-------------------------------
INT 13 - FLOPPY DISK - SET DISK TYPE FOR FORMAT (AT,PS)
	AH = 17h
	AL = format type
	    01h = 320/360K disk in 360K drive
	    02h = 320/360K disk in 1.2M drive
	    03h = 1.2M disk in 1.2M drive
	    04h = 720K disk in 720K drive
	DL = drive number
Return: CF set on error
	CF clear if successful
	AH = status (see AH=01h)
Note:	this function does not handle 1.44M drives; use AH=18h instead
SeeAlso: AH=15h,AH=18h
--------d-131700-----------------------------
INT 13 - Future Domain SCSI CONTROLLER - GET INQUIRY INFO FROM SCSI DEVICE
	AX = 1700h
	CL = length of buffer
	DL = hard drive ID
	ES:BX -> buffer for info
Return: CF clear if successful
	    CH = number of bytes returned in buffer???
	CF set on error
	    AH = status code (see AH=01h)
Notes:	this function is not available with 8-bit controller ROM versions < 7.0
	information block bytes 5-n are vendor-specific in older SCSI devices
	the TMC-950 does not support any Future Domain BIOS calls; instead,
	  it provides a full CAM implementation (see INT 4F/AX=8100h)
SeeAlso: AH=18h"SCSI",AH=1Bh"SCSI"

Format of SCSI inquiry information block:
Offset	Size	Description
 00h	BYTE	device type
		bits 0-4: peripheral device type (see below)
		bits 5-7: peripheral qualifier (see below)
 01h	BYTE	device type modifier
		bits 0-6: device type modifier
		bit 7: removable medium
 02h	BYTE	SCSI version
		bits 0-2: ANSI-approved version
			  000 device might or might not comply to ANSI standard
			  001 device complies to ANSI SCSI-1
			  010 device complies to ANSI SCSI-2
			  other reserved
		bits 3-5: ECMA version
		bits 6,7: ISO version
 03h	BYTE	data format/capabilities
		bits 0-2: response data format
			  000 information block is as specified in SCSI-1
			  001 information block is as specified in CCS
			  010 information block is as specified in SCSI-2
			  other reserved
		bits 4,5: reserved
		bit 6: terminate I/O process supported
		bit 7: asynchronous event notification supported
 04h	BYTE	additional data length (total remaining bytes)
 05h  2 BYTEs	reserved
 07h	BYTE	device capabilities (see below)
 08h  8 BYTEs	vendor identification (space-padded ASCII)
 10h  8 BYTEs	product identification (space-padded ASCII)
 20h  4 BYTEs	product revision level (space-padded ASCII)
 24h 20 BYTEs	vendor specific
 38h 40 BYTEs	reserved
 60h	var	vendor specific parameters

Values for peripheral device type:
 00h	direct-access device (e.g., magnetic disk)
 01h	sequential-access device (e.g., magnetic tape)
 02h	printer device
 03h	processor device
 04h	write-once device (e.g., some optical disks)
 05h	CD-ROM device
 06h	scanner device
 07h	optical memory device (e.g., some optical disks)
 08h	medium changer device (e.g., jukeboxes)
 09h	communications device
 0Ah	(defined by ASC IT8)
 0Bh	(defined by ASC IT8)
 0Ch-1Eh reserved
 1Fh	unknown or no device type

Values for peripheral qualifier:
 000b	device is currently connected to this logical unit and available
 001b	target is capable of supporting the specified peripheral, but the
	  physical device is not currently connected to this logical unit
 010b	reserved
 011b	target can't support a physical device on this logical unit
 1xxb	vendor specific

Bitfields for device capabilities:
 bit 0	device responds to RESET with a hard RESET
 bit 1	tagged command queuing supported
 bit 2	reserved
 bit 3	linked commands supported
 bit 4	synchronous data transfer supported
 bit 5	16-bit transfers supported
 bit 6	32-bit transfers supported
 bit 7	relative addressing supported
--------B-1318-------------------------------
INT 13 - DISK - SET MEDIA TYPE FOR FORMAT (AT model 3x9,XT2,XT286,PS)
	AH = 18h
	DL = drive number
	CH = lower 8 bits of highest cylinder number (number of cylinders - 1)
	CL = sectors per track (bits 0-5)
	     top 2 bits of highest cylinder number (bits 6,7)
Return: AH = status
	    00h requested combination supported
	    01h function not available
	    0Ch not supported or drive type unknown
	    80h there is no disk in the drive
	ES:DI -> 11-byte parameter table
SeeAlso: AH=05h,AH=07h,AH=17h
--------d-1318-------------------------------
INT 13 - Future Domain SCSI BIOS - GET SCSI CONTROLLER INFORMATION
	AH = 18h
	DL = hard drive ID
Return: CF set on error
	    AH = status code (see AH=01h)
	CF clear if successful
	    AX = 4321h (magic number)
	    CX = controller family code (see below)
	    ---if family code=0200h
		DH = number of exclusively ROM-controlled SCSI devices
		DL = canonical SCSI device number for specified drive
	    ---if family code <> 0200h
		BH = number of exclusively ROM-controlled SCSI devices
		BL = canonical SCSI device number for specified drive
Notes:	also sets an internal flag (non-resettable) which prevents some
	  controller messages from being displayed, allows writes to
	  removable devices (use caution!), and enables the INT 13 interface
	  for more than one drive (i.e. DL >= 81h) in at least some ROM
	  versions
	the TMC-950 does not support any Future Domain BIOS calls; instead,
	  it provides a full CAM implementation (see INT 4F/AX=8100h)
SeeAlso: AH=05h"SCSI",AX=1700h"SCSI",AH=1Bh"SCSI",INT 4F/AX=8100h

Values for controller family code:
 0200h	TMC-1680/? (ROM 3.0)
 0203h	TMC-1650/1660/1670/1680 (ROM 2.0)
 040Ah	TMC-820/830/840/850/860/870/875/880/885 (ROM <= 6.0A)
 050Dh	TMC-840/841/880/881 (ROM 5.2D)
 0700h	TMC-830/850/860/875/885 (ROM 7.0)
--------B-1319-------------------------------
INT 13 - FIXED DISK - PARK HEADS (XT286,PS)
	AH = 19h
	DL = drive
Return: CF set on error
	AH = status (see AH=01h)
SeeAlso: AH=11h
--------d-1319-------------------------------
INT 13 - Future Domain SCSI CONTROLLER - REINITIALIZE DRIVE
	AH = 19h
	DL = hard drive ID
Return: CF set on error
	    AH = status code (see AH=01h)
	CF clear if successful
	    AH = disk type (03h = fixed disk)
	    CX:DX = number of 512-byte sectors
Notes:	sends SCSI Read Capacity command to get number of logical blocks and
	  adjusts the result for 512-byte sectors
	displays either "Error in Read Capacity Command" or "nnn Bytes per
	  sector" (nnn=256 or 512, the only sizes supported in the translation
	  code)
	should probably be called when a removable device has its media changed
	returns the same values as AH=15h
	the TMC-950 does not support any Future Domain BIOS calls; instead,
	  it provides a full CAM implementation (see INT 4F/AX=8100h)
SeeAlso: AH=15h,AH=1Ah,INT 4F/AX=8100h
--------d-131A-------------------------------
INT 13 - ESDI FIXED DISK - FORMAT UNIT (PS)
	AH = 1Ah
	AL = defect table count
	CL = format modifiers (see below)
	DL = drive
	ES:BX -> defect table
Return: CF set on error
	AH = status (see AH=01h)
Note:	if periodic interrupt selected, INT 15/AH=0Fh is called after each
	  cylinder is formatted
SeeAlso: AH=07h,INT 15/AH=0Fh

Bitfields for format modifiers:
 bit 4	generate periodic interrupt
 bit 3	perform surface analysis
 bit 2	update secondary defect map
 bit 1	ignore secondary defect map
 bit 0	ignore primary defect map
--------d-131A-------------------------------
INT 13 - Future Domain SCSI CONTROLLER - GET SCSI PARTIAL MEDIUM CAPACITY
	AH = 1Ah
	CH = track (bits 8,9 in high bits of CL)
	CL = sector (01h to number of sectors/track for drive)
	DH = head
	DL = hard drive ID
Return: CF set on error
	AH = status code (see AH=01h)
	CX:DX = logical block number of last quickly-accessible block after
		given block
Notes:	sends SCSI Read Capacity command with the PMI bit set to obtain the
	  logical block address of the last block after which a substantial
	  delay in data transfer will be encountered (usually the last block
	  on the current cylinder).  No translation to 512 byte sectors is
	  performed on the result if data is stored on the disk in other than
	  512 byte sectors.
	the TMC-950 does not support any Future Domain BIOS calls; instead,
	  it provides a full CAM implementation (see INT 4F/AX=8100h)
SeeAlso: AH=15h,AH=19h"SCSI"
--------d-131B-------------------------------
INT 13 - ESDI FIXED DISK - GET MANUFACTURING HEADER
	AH = 1Bh
	AL = number of record
	DL = drive
	ES:BX -> buffer for manufacturing header (defect list)
Return: CF set on error
	    AH = status
Note:	manufacturing header format (Defect Map Record format) can be found
	  in IBM 70MB, 115MB Fixed Disk Drives Technical Reference
--------d-131B-------------------------------
INT 13 - Future Domain SCSI CONTROLLER - GET POINTER TO SCSI DISK INFO BLOCK
	AH = 1Bh
	DL = hard drive ID
Return: CF set on error
	    AH = status code (see AH=01h)
	CF clear if successful
	    ES:BX -> SCSI disk information block
Notes:	also sets a non-resettable flag which prevents some controller messages
	  from being displayed
	the TMC-950 does not support any Future Domain BIOS calls; instead,
	  it provides a full CAM implementation (see INT 4F/AX=8100h)
SeeAlso: AH=18h"SCSI",AH=1Ch"SCSI"

Format of SCSI disk information block:
Offset	Size	Description
 00h	BYTE	drive physical information (see below)
 01h	WORD	translated number of cylinders
 03h	BYTE	translated number of heads
 04h	BYTE	translated number of sectors per track (17, 34, or 63)
 05h	BYTE	drive address
		bits 0-2: logical unit number
		bits 3-5: device number
 06h	BYTE	01h at initialization
 07h	BYTE	sense code byte 00h, or extended sense code byte 0Ch
 08h	BYTE	00h
 09h	BYTE	00h or extended sense code byte 02h (sense key)
 0Ah	BYTE	00h
 0Bh 10 BYTEs	copy of Command Descriptor Block (CDB)
 15h	DWORD	translated number of sectors on device

Bitfields for device physical information:
 bit 0	???
 bit 1	device uses parity
 bit 2	256 bytes per sector instead of 512
 bit 3	don't have capacity yet???
 bit 4	disk is removable
 bit 5	logical unit number is not present
--------d-131C-------------------------------
INT 13 - Future Domain SCSI CONTROLLER - GET POINTER TO FREE CONTROLLER RAM
	AH = 1Ch
	DL = hard drive ID (any valid SCSI hard disk)
Return: CF set on error
	    AH = status code (see AH=01h)
	CF clear if successful
	    ES:BX -> first byte of free RAM on controller
Notes:	the Future Domain TMC-870 contains 1024 bytes of RAM at offsets 1800h
	  to 1BFFh on-bard the controller for storing drive information and
	  controller status; ES:BX points to the first byte available for other
	  uses
	ES contains the segment at which the controller resides; the
	  controller's two memory-mapped I/O ports are at offsets 1C00h, 1E00h
SeeAlso: AH=1Bh"SCSI"
--------d-131C0A-----------------------------
INT 13 - ESDI FIXED DISK - GET DEVICE CONFIGURATION
	AX = 1C0Ah
	DL = drive
	ES:BX -> buffer for device configuration (drive physical parameter)
Return: CF set on error
	    AH = status
Note:	device configuration format can be found in IBM ESDI Fixed Disk Drive
	  Adapter/A Technical Reference
--------d-131C0B-----------------------------
INT 13 - ESDI FIXED DISK - GET ADAPTER CONFIGURATION
	AX = 1C0Bh
	ES:BX -> buffer for adapter configuration
Return: CF set on error
	    AH = status
SeeAlso: AX=1C0Ch
--------d-131C0C-----------------------------
INT 13 - ESDI FIXED DISK - GET POS INFORMATION
	AX = 1C0Ch
	ES:BX -> POS information
Return: CF set on error
	    AH = status
SeeAlso: AX=1C0Bh
--------d-131C0E-----------------------------
INT 13 - ESDI FIXED DISK - TRANSLATE RBA TO ABA
	AX = 1C0Eh
	CH = low 8 bits of cylinder number
	CL = sector number, high two bits of cylinder number in bits 6 and 7
	DH = head number
	DL = drive number
	ES:BX -> ABA number
Return: CF set on error
	    AH = status
Note:	ABA (absolute block address) format can be found in IBM ESDI Adapter
	  Technical Reference by using its Device Configuration Status Block
--------c-131D-------------------------------
INT 13 - IBMCACHE.SYS - CACHE STATUS
	AH = 1Dh
	AL = subfunction
	    01h get status record
		DL = drive???
		Return: ES:BX -> status record
			CF set on error
			    AH = error code
	    02h set cache status
		ES:BX -> status record
		DL = drive???
		Return: CF set on error

Format of status record:
Offset	Size	Description
 00h	DWORD	total number of read requests
 04h	DWORD	total number of hits
 08h	DWORD	number of physical disk reads
 0Ch	DWORD	total number of sectors requested by physical disk reads
 10h  6 bytes	???
 16h	DWORD	pointer to start of error list
 1Ah	DWORD	pointer to end of error list
 1Eh	WORD	???
 20h	BYTE	using extended memory if nonzero
 21h	BYTE	???
 22h  4 BYTEs	ASCII version number
 26h	WORD	cache size in KB
 28h	WORD	sectors per page

Format of error list:
Offset	Size	Description
 00h	DWORD	relative block address of bad page
 04h	BYTE	drive
 05h	BYTE	sector bit-map
 06h	WORD	next error
--------d-1320-------------------------------
INT 13 - DISK - ??? (Western Digital "Super BIOS")
	AH = 20h
	???
Return: ???
Note:	returns some kind of status related to whether the drive contains its
	  default media type
--------c-1320-------------------------------
INT 13 u - QUICKCACHE II v4.20 - DISMOUNT
	AH = 20h
	AL = drive (00h = A:, etc. or 7Fh for all removable drives???
				   or FFh for all drives)
Return: AX = status (0000h successful)
Program: QUICKCACHE II is a shareware disk cache by P.R. Glassel and
	  Associates, Inc.
Desc:	flush any dirty buffers for the specified drive(s) and then discard
	  those sector buffers
SeeAlso: AH=21h,AH=22h,AH=28h
--------c-1321-------------------------------
INT 13 u - QUICKCACHE II v4.20 - FLUSH CACHE
	AH = 21h
Return: AX = status (0000h successful)
Desc:	immediately write all dirty sectors back to disk
SeeAlso: AH=25h,AH=2Eh,AH=2Fh
--------c-1322-------------------------------
INT 13 u - QUICKCACHE II v4.20 - ENABLE/DISABLE CACHE
	AH = 22h
	AL = new state (00h disabled, 01h enabled)
Return: AX = status (0000h successful)
Note:	enables/disables caching of all drives
SeeAlso: AH=2Ch,AH=2Dh,AH=32h,AH=33h,AH=A3h,AH=A4h
--------c-1323-------------------------------
INT 13 U - QUICKCACHE II v4.20 - GET ??? ADDRESS
	AH = 23h
Return: AX = status (0000h successful)
	ES = segment of ??? data
--------c-1324-------------------------------
INT 13 u - QUICKCACHE II v4.20 - SET SECTORS
	AH = 24h
	BX = new number of sector buffers in cache
Return: AX = status
	    0000h successful
	    0001h failed--size adjusted
	    8000h cache cannot be resized while enabled
SeeAlso: AH=36h
--------c-1325-------------------------------
INT 13 u - QUICKCACHE II v4.20 - SET FLUSH INTERVAL
	AH = 25h
	BX = interval
Return: AX = status (0000h successful)
Desc:	specify how often the cache should write dirty buffers to disk when
	  buffered writes are enabled
SeeAlso: AH=21h,AH=2Ch,AH=2Eh
--------c-1326-------------------------------
INT 13 U - QUICKCACHE II v4.20 - UNINSTALL
	AH = 26h
Return: AX = status
	    0000h successful
	    0001h-00FFh interrupt vector which was hooked by another TSR
SeeAlso: AH=27h
--------c-1327--BX0000-----------------------
INT 13 u - QUICKCACHE II v4.20 - INSTALLATION CHECK
	AH = 27h
	BX = 0000h
Return: AX = 0000h if installed
	BX nonzero if installed
	    BH = major version
	    BL = binary minor version
Program: QUICKCACHE II is a shareware disk cache by P.R. Glassel and
	  Associates, Inc.
SeeAlso: AH=26h,AH=A0h,INT 16/AX=FFA5h/CX=1111h
--------c-1328-------------------------------
INT 13 U - QUICKCACHE II v4.20 - SET AUTOMATIC DISMOUNT
	AH = 28h
	AL = new state (00h disabled, 01h enabled)
Return: AX = status (0000h successful)
SeeAlso: AH=20h"QUICKCACHE"
--------c-1329-------------------------------
INT 13 U - QUICKCACHE II v4.20 - NOP
	AH = 29h
Return: AX = 0000h
--------c-132A-------------------------------
INT 13 u - QUICKCACHE II v4.20 - SET BUFFER SIZE
	AH = 2Ah
	AL = buffer size (1-30)
Return: AX = status (0000h successful)
Desc:	specify the number of cache sector buffers to dedicate to buffered read
	  and write operations
SeeAlso: AH=2Ch,AH=2Dh,AH=39h,AH=3Ah
--------c-132B-------------------------------
INT 13 U - QUICKCACHE II v4.20 - DRIVE ACCESS SOUNDS
	AH = 2Bh
	AL = new state (00h disabled, 01h enabled)
Return: AX = status (0000h successful)
--------c-132C-------------------------------
INT 13 u - QUICKCACHE II v4.20 - SET BUFFERED WRITES
	AH = 2Ch
	AL = new state (00h disabled, 01h enabled)
Return: AX = status (0000h successful)
Desc:	specify whether the cache should delay disk writes
Note:	this function enables or disables delayed writes for all drives; use
	  AH=38h to change a single drive
SeeAlso: AH=25h,AH=2Dh,AH=2Eh,AH=38h
--------c-132D-------------------------------
INT 13 u - QUICKCACHE II v4.20 - SET BUFFERED READ
	AH = 2Dh
	AL = new state (00h disabled, 01h enabled)
Return: AX = status (0000h succesful)
Desc:	specify whether the cache should attempt to read ahead of actual
	  requests
Note:	this function enables or disables read-ahead for all drives; use AH=37h
	  to change a single drive
SeeAlso: AH=2Ch,AH=37h
--------c-132E-------------------------------
INT 13 u - QUICKCACHE II v4.20 - SET FLUSH COUNT
	AH = 2Eh
	BX = flush count
Return: AX = status (0000h successful)
Desc:	specify how many dirty sectors the cache should write after each flush
	  interval (see AH=25h) when buffered writes are enabled
SeeAlso: AH=21h,AH=25h,AH=2Ch
--------c-132F-------------------------------
INT 13 - QUICKCACHE II v4.20 - FORCE IMMEDIATE INCREMENTAL FLUSH
	AH = 2Fh
Return: AX = status (0000h successful)
Desc:	immediately flush up to "flushcount" dirty sectors to disk as if the
	  flush interval had expired
SeeAlso: AH=21h
--------c-1330-------------------------------
INT 13 u - QUICKCACHE II v4.20 - GET INFO
	AH = 30h
	AL = what to get
	    00h system info (see below)
	    01h drive info (see below)
	    02h access frequency (array of 30 words)
	    03h drive index
		(array of 32 bytes indicating BIOS drive for DOS drive)
	DS:DX -> buffer for info
Return: AX = status (0000h successful, 8000h invalid info specifier)
Program: QUICKCACHE II is a shareware disk cache by P.R. Glassel and
	  Associates, Inc.

Format of system info:
Offset	Size	Description
 00h	BYTE	flag: cache enabled
 01h	BYTE	flag: buffered writes enabled
 02h	BYTE	flag: buffered reads enabled
 03h	BYTE	flag: sounds enabled
 04h	BYTE	flag: autodismount enabled
 05h	BYTE	???
 06h	BYTE	flag: ???
 07h	BYTE	flag: ???
 08h	BYTE	flag: "em_assigned"
 09h	BYTE	flag: emulated EMS
 0Ah	BYTE	single sector bonus
 0Bh	BYTE	"sticky_max"
 0Ch	BYTE	write sector bonus
 0Dh	BYTE	bonus threshold
 0Eh	WORD	flush interval
 10h	WORD	flush count
 12h	WORD	reserve pool size
 14h	WORD	remaining space in reserve pool
 16h	WORD	required free memory
 18h	WORD	total cache sectors
 1Ah	WORD	dirty cache sectors
 1Ch	BYTE	trace buffer size
 1Dh	BYTE	reserved (padding)

Format of drive info [16-element array, one element]:
Offset	Size	Description
 00h	BYTE	DOS drive number
 01h	BYTE	BIOS drive number
 02h	BYTE	maximum sector number
 03h	BYTE	maximum head number
 04h	BYTE	read buffer size
 05h	BYTE	write buffer size
 06h	BYTE	last status
 07h	BYTE	flag: enabled
 08h	BYTE	flag: buffered write enabled
 09h	BYTE	flag: buffered read enabled
 0Ah	BYTE	flag: in use (drive info is valid)
 0Bh	BYTE	flag: cylinder flush
 0Ch	BYTE	reserved (padding)
 0Dh	BYTE	sectors per track
 0Eh	WORD	sector size
 10h	WORD	sectors assigned
 12h	WORD	dirty sectors
 14h	WORD	reserved sectors
 16h	WORD	number of read errors
 18h	WORD	number of write errors
 1Ah	DWORD	"rio_count"
 1Eh	DWORD	number of cache misses
 22h	DWORD	"wio_count"
 26h	DWORD	"dio_count"
--------c-1331-------------------------------
INT 13 U - QUICKCACHE II v4.20 - RESERVE MEMORY
	AH = 31h
	BX = number of paragraphs of conventional memory to reserve for apps
Return: AX = status (0000h successful)
--------c-1332-------------------------------
INT 13 U - QUICKCACHE II v4.20 - ENABLE CACHING FOR SPECIFIC DRIVE
	AH = 32h
	AL = drive number (00h=A:)
Return: AX = status (0000h successful)
SeeAlso: AH=22h,AH=33h
--------c-1333-------------------------------
INT 13 U - QUICKCACHE II v4.20 - DISABLE CACHING FOR SPECIFIC DRIVE
	AH = 33h
	AL = drive number (00h=A:)
Return: AX = status (0000h successful)
SeeAlso: AH=22h,AH=32h
--------c-1334-------------------------------
INT 13 U - QUICKCACHE II v4.20 - SECTOR LOCKING
	AH = 34h
	AL = function
	    00h end sector locking/unlocking
	    01h lock all accessed sectors into cache
	    02h unlock all accessed sectors and discard from cache
Return: AX = status (0000h successful)
SeeAlso: AH=20h,AH=35h
--------c-1335-------------------------------
INT 13 U - QUICKCACHE II v4.20 - SET LOCK POOL SIZE
	AH = 35h
	BX = number of sectors in lock pool
Return: AX = status (0000h successful)
Desc:	specify the number of cache sector buffers which may be dedicated to
	  data locked into the cache
SeeAlso: AH=34h
--------c-1336-------------------------------
INT 13 U - QUICKCACHE II v4.20 - SET TRACE BUFFER SIZE
	AH = 36h
	AL = new size of trace buffer
Return: AX = status (0000h successful)
Note:	called with AL=05h during an INT 13/AH=24h call
SeeAlso: AH=24h
--------c-1337-------------------------------
INT 13 U - QUICKCACHE II v4.20 - SET BUFFERED READS FOR SPECIFIC DRIVE
	AH = 37h
	AL = new state (00h disabled, else enabled)
	DL = drive number (00h = A:)
Return: AX = status (0000h successful)
SeeAlso: AH=2Dh,AH=38h
--------c-1338-------------------------------
INT 13 U - QUICKCACHE II v4.20 - SET BUFFERED WRITES FOR SPECIFIC DRIVE
	AH = 38h
	AL = new state (00h disabled, else enabled)
	DL = drive number (00h = A:)
Return: AX = status (0000h successful)
SeeAlso: AH=2Ch,AH=37h
--------c-1339-------------------------------
INT 13 U - QUICKCACHE II v4.20 - SET READ BUFFER SIZE FOR SPECIFIC DRIVE
	AH = 39h
	AL = new size of read buffer
	DL = drive number (00h = A:)
Return: AX = status (0000h successful)
Program: QUICKCACHE II is a shareware disk cache by P.R. Glassel and
	  Associates, Inc.
SeeAlso: AH=2Ah,AH=3Ah
--------c-133A-------------------------------
INT 13 U - QUICKCACHE II v4.20 - SET WRITE BUFFER SIZE FOR SPECIFIC DRIVE
	AH = 3Ah
	AL = new size of write buffer
	DL = drive number (00h = A:)
Return: AX = status (0000h successful)
SeeAlso: AH=2Ah,AH=39h
--------c-133B-------------------------------
INT 13 U - QUICKCACHE II v4.20 - ENABLE/DISABLE ???
	AH = 3Bh
	AL = new state of ??? (01h enabled, else disabled)
Return: AX = status (0000h successful)
Note:	is affected by the flag reported at offset 05h of the system info
	  returned by AH=30h, and sets the flag at offset 06h
SeeAlso: AH=3Ch
--------c-133C-------------------------------
INT 13 U - QUICKCACHE II v4.20 - ENABLE/DISABLE ???
	AH = 3Ch
	AL = new state of ??? (01h enabled, else disabled)
Return: AX = status (0000h successful)
Note:	is affected by the flag reported at offset 05h of the system info
	  returned by AH=30h, and sets the flag at offset 07h
SeeAlso: AH=3Bh
--------c-133D-------------------------------
INT 13 U - QUICKCACHE II v4.20 - ENABLE/DISABLE CYLINDER FLUSH FOR DRIVE
	AH = 3Dh
	AL = new state (01h enabled, else disabled)
	DL = drive number (00h = A:)
Return: AX = status (0000h successful)
--------c-133E-------------------------------
INT 13 U - QUICKCACHE II v4.20 - SET SINGLE-SECTOR BONUS
	AH = 3Eh
	AL = new value for bonus
Return: AX = status (0000h successful)
Desc:	specify the bonus score to give to single-sector transfers in order to
	  keep those sectors in the cache longer
--------c-133F-------------------------------
INT 13 U - QUICKCACHE II v4.20 - SET BONUS THRESHOLD
	AH = 3Fh
	AL = new value for bonus threshold
Return: AX = status (0000h successful)
--------c-1340-------------------------------
INT 13 U - QUICKCACHE II v4.20 - SET "sticky_max"
	AH = 40h
	AL = new value for "sticky_max"
Return: AX = status (0000h successful)
--------c-1341-------------------------------
INT 13 U - QUICKCACHE II v4.20 - SAVE/RESTORE ???
	AH = 41h
	AL = direction
	    01h save to file
	    else restore from file
	ES:DI -> 1024-byte buffer for ???
Return: AX = status (0000h successful, 8000h failed)
Program: QUICKCACHE II is a shareware disk cache by P.R. Glassel and
	  Associates, Inc.
--------N-134257DX1234-----------------------
INT 13 U - Beame&Whiteside BWLPD - INSTALLATION CHECK
	AX = 4257h ("BW")
	DX = 1234h
Return: BX = 414Ch if installed
Program: BWLPD is the printer daemon from the BW-NFS package
SeeAlso: INT 62"BW-TCP"
--------v-135342CX0001-----------------------
INT 13 - ScanBoot - INSTALLATION CHECK
	AX = 5342h ("SB")
	CX = 0001h
	DX = 0000h
Return: CF clear if ScanBoot installed
	   AX = 0000h
	   CX = serial number ("SW" if shareware release)
	   DX = version
	   BX,SI,ES destroyed
Program: ScanBoot is a virus-detection TSR by PanSoft
--------d-135504-----------------------------
INT 13 - Seagate - GET CONTROLLER TYPE???
	AX = 5504h
	DX = drive (bit 7 set for hard disk)
Return: CF clear if successful
	    AX = 4321h,4322h if Seagate controller
	CF set on error
SeeAlso: AX=5505h,AX=5514h
--------d-135505-----------------------------
INT 13 - Seagate - PARK HEADS???
	AX = 5505h
	DX = drive (bit 7 set for hard disk)
Return: CF clear if successful
	CF set on error
SeeAlso: AX=5504h,AX=5515h
--------d-135514-----------------------------
INT 13 - Seagate - ???
	AX = 5514h
	DX = drive (bit 7 set for hard disk)
Return: CF clear if successful
	CF set on error
	AX = return value (FEBEh,FEBFh,FEDAh,FEDBh)
SeeAlso: AX=5504h,AX=5515h
--------d-135515-----------------------------
INT 13 - Seagate - PARK HEADS???
	AX = 5515h
	DX = drive (bit 7 set for hard disk)
Return: CF clear if successful
	CF set on error
Note:	appears to be identical to AX=5505h
SeeAlso: AX=5504h,AX=5505h
--------d-1370-------------------------------
INT 13 - Priam EDVR.SYS DISK PARTITIONING SOFTWARE???
	AH = 70h
	???
Return: ???
Note:	Priam's EDISK.EXE (FDISK replacement) and EFMT.EXE (low-level
	  formatting program) make this call, presumably to EDVR.SYS (the
	  partitioning driver)
SeeAlso: AH=ADh
----------1375-------------------------------
INT 13 - ???
	AH = 75h
	???
Return: AH = ???
	???
Note:	intercepted by PC-Cache (v5.1 only)
----------1376-------------------------------
INT 13 - ???
	AH = 76h
	???
Return: AH = ???
	???
Note:	intercepted by PC-Cache (v5.1 only)
--------c-137B00-----------------------------
INT 13 - NOW! v3.05 - GET INFORMATION
	AX = 7B00h
	CX:DX -> 1F8h-byte buffer for information record (see below)
Return: AX = 0000h
	BX = segment of main resident code
	ES = ???
Program: NOW! is a disk cache by Vertisoft Systems, Inc.
SeeAlso: AX=7B02h,AH=EFh

Format of information record:
Offset	Size	Description
 00h 80 BYTEs	name of directory from which NOW! was started
 50h 424 BYTEs	???
 81h  ? BYTEs	array of bytes for ???
 F7h 250 BYTEs	array of 25 entries, one per drive???
	Offset	Size	Description
	 00h  2 BYTEs	???
	 02h	WORD	???
	 04h	WORD	???
	 06h  4 BYTEs	???
1F1h  7 BYTEs	???
--------c-137B01-----------------------------
INT 13 - NOW! v3.05 - ???
	AX = 7B01h
Return: DX = segment of ???
SeeAlso: AX=7B00h
--------c-137B02-----------------------------
INT 13 - NOW! v3.05 - SET INFORMATION
	AX = 7B02h
	BX = segment of ??? (10h above a PSP)
	CX:DX -> 1F8h-byte information record (see AX=7B00h)
Return: ???
Program: NOW! is a disk cache by Vertisoft Systems, Inc.
Note:	NOW! grabs the INT 24h value from the PSP reached via the segment in
	  BX
SeeAlso: AX=7B00h
--------c-137B03-----------------------------
INT 13 - NOW! v3.05 - ???
	AX = 7B03h
	???
Return: ???
SeeAlso: AX=7B00h,AX=7B04h
--------c-137B04-----------------------------
INT 13 - NOW! v3.05 - ???
	AX = 7B04h
	???
Return: ???
SeeAlso: AX=7B03h
--------c-137B05-----------------------------
INT 13 - NOW! v3.05 - GET DISK ACCESSES???
	AX = 7B05h
Return: BX:AX = number of physical accesses???
	DX:CX = total disk accesses???
SeeAlso: AX=7B00h,AX=7B06h
--------c-137B06-----------------------------
INT 13 - NOW! v3.05 - GET ???
	AX = 7B06h
	BX = ???
Return: AX = 0000h
	BX = ???
SeeAlso: AX=7B05h,AX=7B07h
--------c-137B07-----------------------------
INT 13 - NOW! v3.05 - GET ???
	AX = 7B07h
Return: AX = ???
	BX = ???
	CX = ???
	DX = ???
SeeAlso: AX=7B06h
--------c-137B08-----------------------------
INT 13 - NOW! v3.05 - ???
	AX = 7B08h
	CX = ??? (default 00h)
Return: ???
SeeAlso: AX=7B00h
--------c-1380--CX6572-----------------------
INT 13 - FAST! v4.02+ - API
	AH = 80h
	CX = 6572h
	DX = 1970h
	ES:BX -> request packet (see below)
	AL = function
	    01h get cache information (see separate entry)
	    04h disable cache
	    05h enable cache and reset statistics
	    06h installation check (see separate entry)
	    07h unhook interrupts (see separate entry)
	    09h flush cache
	    0Ah (v4.02+) enable staged writes
	    0Bh (v4.02+) disable staged writes
	    0Ch (v4.02+) enable beep on flush
	    0Dh (v4.02+) disable beep on flush
	    0Eh ???
	    0Fh ???
	    10h (v4.12+) enable hotkeys
	    11h (v4.12+) disable hotkeys
	    12h (v4.13+) set idle delay
	    13h (v4.13+) set flush dirty percentage
	    14h (v5.00+) enable mouse checks
	    15h (v5.00+) disable mouse checks
	    16h (v5.00d+) reduce cache size to minimum
	    17h (v5.00d+) increase cache size to maximum
Return: AH = status (except function 06h)
	    00h if successful
	    01h invalid function
	    05h not supported by the installed variant
	CF clear if successful
	CF set on error
	AL may be destroyed
Program: FAST! is a disk cache by Future Computing Systems and marketed by BLOC
	  Publishing Corp.
SeeAlso: AX=8001h,AX=8006h,AX=8007h
Index:	hotkeys;FAST!

Format of request packet:
Offset	Size	Description
 00h	DWORD	pointer to 19-byte signature string (see below)
 04h	DWORD	pointer to buffer for data (if needed by function)

Values for v4.04-v5.03 signature string:
 13h 07h 06h 08h 11h 18h 0Fh 0Eh 02h 18h 13h 08h 0Bh 08h 01h 00h 04h 08h 15h
--------c-138001CX6572-----------------------
INT 13 - FAST! v4.02+ - GET CACHE INFORMATION
	AX = 8001h
	CX = 6572h
	DX = 1970h
	ES:BX -> request packet (see below)
Return: AH = 00h if successful
SeeAlso: AH=80h,AX=8006h

Format of request packet:
Offset	Size	Description
 00h	DWORD	-> 19-byte signature string (see AH=80h)
 04h	DWORD	-> buffer for cache information (see below)

Format of cache information (v5.00-5.03):
Offset	Size	Description
 00h	WORD	binary version number of FAST! (v5.00 = 01F4h)
 02h	BYTE	revision letter (61h = X.XXa, 62h = X.XXb, etc.)
 03h	BYTE	FAST! variant
		(01h = FASTE, 02h = FASTX BIOS, 04h = FASTC, 20h = FASTX XMS)
 04h	DWORD	total number of read requests
 08h	DWORD	number of physical disk reads
 0Ch	DWORD	grabbed hash buckets
 10h	DWORD	"st_386mem"
 14h	DWORD	total number of writes (only counted when staging enabled)
 18h	DWORD	number of physical disk writes (only when staging enabled)
 1Ch	DWORD	number of write errors while flushing cache
 20h	WORD	flags
		bit 0: beep on flush
		bit 3: hotkeys enabled
		bit 4: mouse idle check enabled
		bit 8: caching enabled
		bit 13: ???
 22h	WORD	flags
		bit 0: ???
		bit 1: staged writes enabled
 24h	WORD	???
 26h	WORD	maximum cache size in KB
 28h	WORD	minimum cache size in KB
 2Ah	WORD	segment of first cache buffer (FASTC)
		segment of EMS page frame (FASTE)
		XMS handle (FASTX XMS)
 2Ch	WORD	number of hash buckets containing no entries
 2Eh	WORD	number of hash buckets containing one entry
 30h	WORD	number of hash buckets containing two entries
 32h	WORD	number of hash buckets containing three entries
 34h	WORD	number of hash buckets containing four entries
 36h	WORD	number of hash buckets containing five entries
 38h	WORD	maximum contiguous sectors
 3Ah	WORD	hash factor
 3Ch	WORD	number of paragraphs of memory used below 1M
 3Eh	WORD	entries per hash bucket
 40h	WORD	idle delay in seconds
 42h  2 BYTEs	???
 44h	WORD	staged write threshold percentage
 46h  2 BYTEs	???
 48h	WORD	number of dirty sectors
 4Ah	WORD	number of staged write buffers
 4Ch	WORD	current cache size in KB
 4Eh	WORD	beep frequency in Hz
 50h	WORD	???
 52h	WORD	???
--------c-138006CX6572-----------------------
INT 13 - FAST! v4.02+ - INSTALLATION CHECK
	AX = 8006h
	CX = 6572h
	DX = 1970h
	ES:BX -> request packet (see below)
Return: AX = 1965h if installed
SeeAlso: AH=80h,AX=8001h,AX=8007h

Format of request packet:
Offset	Size	Description
 00h	DWORD	-> 19-byte signature string (see AH=80h)
--------c-138007CX6572-----------------------
INT 13 - FAST! v4.02+ - UNHOOK INTERRUPTS
	AX = 8007h
	CX = 6572h
	DX = 1970h
	ES:BX -> request packet (see below)
Return: AX = 1965h if installed
SeeAlso: AH=80h,AX=8006h
Index:	uninstall;FAST!

Format of request packet:
Offset	Size	Description
 00h	DWORD	-> 19-byte signature string (see AH=80h)
--------c-1381--SI4358-----------------------
INT 13 - Super PC-Kwik v3.20+ - ???
	AH = 81h
	SI = 4358h
	???
Return: ???
Note:	PC Tools PC-Cache 5.x and Qualitas Qcache 4.00 are OEM versions of
	  Super PC-Kwik, and thus support this call (PC-Cache v5.1 corresponds
	  to PC-Kwik v3.20 and PC-Cache v5.5 to PC-Kwik v3.27)
	returns immediately in PC-Cache v5.x
Index:	PC-Cache|Qualitas Qcache
--------c-1382--SI4358-----------------------
INT 13 - Super PC-Kwik v3.20+ - ???
	AH = 82h
	SI = 4358h
	???
Return: AL = ???
Note:	PC Tools PC-Cache 5.x and Qualitas Qcache 4.00 are OEM versions of
	  Super PC-Kwik, and thus support this call
SeeAlso: AH=84h
Index:	PC-Cache|Qualitas Qcache
--------c-1383--SI4358-----------------------
INT 13 - Super PC-Kwik v3.20+ - ???
	AH = 83h
	SI = 4358h
	AL = ???
	ES:BX -> ???
	???
Return: ???
Note:	PC Tools PC-Cache 5.x and Qualitas Qcache 4.00 are OEM versions of
	  Super PC-Kwik, and thus support this call
SeeAlso: AH=85h
Index:	PC-Cache|Qualitas Qcache
--------c-1384--SI4358-----------------------
INT 13 - Super PC-Kwik v3.20+ - ???
	AH = 84h
	SI = 4358h
	AL = ???
	???
Return: AL = ???
Note:	PC Tools PC-Cache 5.x and Qualitas Qcache 4.00 are OEM versions of
	  Super PC-Kwik, and thus support this call
SeeAlso: AH=82h
Index:	PC-Cache|Qualitas Qcache
--------c-1385--SI4358-----------------------
INT 13 - Super PC-Kwik v3.20+ - ???
	AH = 85h
	SI = 4358h
	AL = ???
	DL = ???
	???
Return: ???
Note:	PC Tools PC-Cache 5.x and Qualitas Qcache 4.00 are OEM versions of
	  Super PC-Kwik, and thus support this call (PC-Cache v5.1 corresponds
	  to PC-Kwik v3.20)
SeeAlso: AH=83h
Index:	PC-Cache|Qualitas Qcache
--------c-1386--SI4358-----------------------
INT 13 - Super PC-Kwik v4.00+ - ???
	AH = 86h
	SI = 4358h
	???
Return: ???
Note:	Qualitas Qcache v4.00 is an OEM version of Super PC-Kwik v4.00, and
	  thus supports this call
Index:	Qualitas Qcache
--------c-1387--SI4358-----------------------
INT 13 - Super PC-Kwik v4.00+ - ???
	AH = 87h
	SI = 4358h
	???
Return: AH = status??? (00h)
	CX = ???
	DX = ??? (0000h)
Note:	Qualitas Qcache v4.00 is an OEM version of Super PC-Kwik v4.00, and
	  thus supports this call
Index:	Qualitas Qcache
--------c-1388--SI4358-----------------------
INT 13 - Super PC-Kwik v4.00+ - ???
	AH = 88h
	SI = 4358h
	???
Return: AH = status??? (00h)
	CX = ???
	DX = ??? (0000h)
Note:	Qualitas Qcache v4.00 is an OEM version of Super PC-Kwik v4.00, and
	  thus supports this call
Index:	Qualitas Qcache
--------c-1389--SI4358-----------------------
INT 13 - Super PC-Kwik v5.10+ - ???
	AH = 89h
	SI = 4358h
	???
Return: ???
--------c-138A--SI4358-----------------------
INT 13 - Super PC-Kwik v5.10+ - ???
	AH = 8Ah
	SI = 4358h
	???
Return: ???
--------c-138EED-----------------------------
INT 13 - HyperDisk v4.01+ - ???
	AX = 8EEDh
	???
Return: ???
Program: HyperDisk is a shareware disk cache by HyperWare (Roger Cross)
SeeAlso: AX=8EEEh,AX=8EEFh,AH=EEh,INT 2F/AH=DFh
--------c-138EEE-----------------------------
INT 13 - HyperDisk v4.01+ - ???
	AX = 8EEEh
Return: CF set
	AX = CS of HyperDisk resident code
	???
Note:	identical to AX=8EEFh in HYPERDKX v4.21-4.30
SeeAlso: AX=8EEDh,AX=8EEFh,AH=EEh
--------c-138EEF-----------------------------
INT 13 - HyperDisk v4.01+ - ???
	AX = 8EEFh
Return: CF set
	AX = CS of HyperDisk resident code
	???
Note:	identical to AX=8EEEh in HYPERDKX v4.21-4.30
SeeAlso: AX=8EEDh,AX=8EEEh,AH=EEh
--------c-1392--SI4358-----------------------
INT 13 - Super PC-Kwik v5.10+ - ???
	AH = 92h
	SI = 4358h
	???
Return: AH = status??? (00h)
	DL = ???
SeeAlso: AH=93h
--------c-1393--SI4358-----------------------
INT 13 - Super PC-Kwik v5.10+ - ???
	AH = 93h
	SI = 4358h
	???
Return: AH = status??? (00h)
	AL = ???
SeeAlso: AH=92h
--------c-1394--SI4358-----------------------
INT 13 - Super PC-Kwik v5.10+ - ???
	AH = 94h
	SI = 4358h
	???
Return: ???
--------c-1395--SI4358-----------------------
INT 13 - Super PC-Kwik v5.10+ - ???
	AH = 95h
	SI = 4358h
	???
Return: AH = status??? (00h)
	DX = ???
--------c-1396--SI4358-----------------------
INT 13 - Super PC-Kwik v5.10+ - ???
	AH = 96h
	SI = 4358h
	AL = ??? (01h)
	BX = ??? (0790h)
	DL = ???
Return: AH = status??? (00h)
	DX = ???
--------c-1397--SI4358-----------------------
INT 13 - Super PC-Kwik v5.10+ - ???
	AH = 97h
	SI = 4358h
	???
Return: ???
--------c-1398--SI4358-----------------------
INT 13 - Super PC-Kwik v5.10+ - ???
	AH = 98h
	SI = 4358h
	???
Return: ???
--------c-1399--SI4358-----------------------
INT 13 - Super PC-Kwik v5.10+ - ???
	AH = 99h
	SI = 4358h
	???
Return: ???
--------c-139A--SI4358-----------------------
INT 13 - Super PC-Kwik v5.10+ - ???
	AH = 9Ah
	SI = 4358h
	???
Return: ???
--------c-139B--SI4358-----------------------
INT 13 - Super PC-Kwik v5.10+ - ???
	AH = 9Bh
	SI = 4358h
	???
Return: ???
--------c-139C--SI4358-----------------------
INT 13 - Super PC-Kwik v5.10+ - ???
	AH = 9Ch
	SI = 4358h
	???
Return: ???
Note:	functions 9Ch and 9Dh are the only ones which are fully reentrant; all
	  other PC-Kwik API calls (INT 13/81h-B0h) return AX=0200h and CF clear
	  if a previous call is still in progress
--------c-139D--SI4358-----------------------
INT 13 - Super PC-Kwik v5.10+ - ???
	AH = 9Dh
	SI = 4358h
	???
Return: ???
--------c-13A0--SI4358-----------------------
INT 13 - Super PC-Kwik v3.20+ - GET RESIDENT CODE SEGMENT
	AH = A0h
	SI = 4358h
Return: AX = segment of resident code
Note:	PC Tools PC-Cache 5.x and Qualitas Qcache 4.00 are OEM versions of
	  Super PC-Kwik, and thus support this call (note that PC-Cache v5.5
	  corresponds to PC-Kwik v3.27)
SeeAlso: INT 16/AX=FFA5h/CX=1111h
Index:	PC-Cache|Qualitas Qcache
--------c-13A1--SI4358-----------------------
INT 13 - Super PC-Kwik v3.20+ - FLUSH CACHE
	AH = A1h
	SI = 4358h
Return: CF clear
	AH = 00h (v5.10)
Note:	PC Tools PC-Cache 5.x and Qualitas Qcache 4.00 are OEM versions of
	  Super PC-Kwik, and thus support this call (note that PC-Cache v5.1
	  corresponds to PC-Kwik v3.20)
SeeAlso: INT 16/AX=FFA5h/CX=FFFFh
Index:	PC-Cache|Qualitas Qcache
--------c-13A2--SI4358-----------------------
INT 13 - Super PC-Kwik v3.20+ - ???
	AH = A2h
	SI = 4358h
	???
Return: ???
Note:	PC Tools PC-Cache 5.x and Qualitas Qcache 4.00 are OEM versions of
	  Super PC-Kwik, and thus support this call (note that PC-Cache v5.1
	  corresponds to PC-Kwik v3.20)
Index:	PC-Cache|Qualitas Qcache
--------c-13A3--SI4358-----------------------
INT 13 U - Super PC-Kwik v5.10+ - DISABLE CACHE
	AH = A3h
	SI = 4358h
Return: CF clear
SeeAlso: AH=A4h
--------c-13A4--SI4358-----------------------
INT 13 U - Super PC-Kwik v5.10+ - ENABLE CACHE
	AH = A4h
	SI = 4358h
Return: CF clear
SeeAlso: AH=A3h
--------c-13A5--SI4358-----------------------
INT 13 CU - Super PC-Kwik v5.10+ - PROGRAM TERMINATION NOTIFICATION
	AH = A5h
	SI = 4358h
Return: AX = ???
	SI = ???
Notes:	called and used internally by Super PC-Kwik when a program terminates
	  via INT 21/AH=00h, INT 21/AH=31h, or INT 21/AH=4Ch
	this call is not supported by Qualitas Qcache 4.00
Index:	PC-Cache
SeeAlso: AH=A6h,AH=A9h,INT 21/AH=00h,INT 21/AH=31h,INT 21/AH=4Ch
--------c-13A6--SI4358-----------------------
INT 13 CU - Super PC-Kwik v5.10+ - PROGRAM LOAD NOTIFICATION
	AH = A6h
	SI = 4358h
	DS:DX -> ASCIZ program name
	ES:BX -> EXEC data block (see INT 21/AH=4Bh)
Return: ???
Note:	called and used internally by Super PC-Kwik when a program is loaded
	  with INT 21/AX=4B00h
SeeAlso: AH=A5h,AH=A9h,INT 21/AH=4Bh
--------c-13A7--SI4358-----------------------
INT 13 CU - Super PC-Kwik 5.1 - ???
	AH = A7h
	SI = 4358h
Return: ???
Note:	called and used internally by Super PC-Kwik on some INT 21 calls
SeeAlso: AH=A5h,AH=A6h,AH=A8h
--------c-13A8--SI4358-----------------------
INT 13 CU - Super PC-Kwik 5.1 - ???
	AH = A8h
	SI = 4358h
Return: ???
Note:	called and used internally by Super PC-Kwik on some INT 21 calls
SeeAlso: AH=A5h,AH=A6h,AH=A7h
--------c-13A9--SI4358-----------------------
INT 13 CU - Super PC-Kwik 5.1 - EXITCODE RETRIEVAL NOTIFICATION
	AH = A9h
	SI = 4358h
Return: ???
Note:	called and used internally by Super PC-Kwik when an application issues
	  INT 21/AH=4Dh
SeeAlso: AH=A5h,AH=A6h,INT 21/AH=4Dh
--------c-13AA--SI4358-----------------------
INT 13 - Super PC-Kwik v4+ - ???
	AH = AAh
	SI = 4358h
	???
Return: ???
Note:	Qualitas Qcache is an OEM version of Super PC-Kwik, and thus supports
	  this call
--------c-13AB--SI4358-----------------------
INT 13 - Super PC-Kwik v4+ - ???
	AH = ABh
	SI = 4358h
	???
Return: ???
Note:	Qualitas Qcache is an OEM version of Super PC-Kwik, and thus supports
	  this call
--------c-13AC--SI4358-----------------------
INT 13 - Super PC-Kwik v4+ - ???
	AH = ACh
	SI = 4358h
	???
Return: ???
Note:	Qualitas Qcache is an OEM version of Super PC-Kwik, and thus supports
	  this call
--------d-13AD-------------------------------
INT 13 - Priam HARD DISK CONTROLLER???
	AH = ADh
	???
Return: ???
Note:	this call is made from Priam's EFMT.EXE (low-level formatter), probably
	  to check the ROM type on the controller for their hard disk kits
SeeAlso: AH=70h
--------c-13AD--SI4358-----------------------
INT 13 - Super PC-Kwik v4+ - ???
	AH = ADh
	SI = 4358h
	???
Return: ???
Note:	Qualitas Qcache is an OEM version of Super PC-Kwik, and thus supports
	  this call
--------c-13AE--SI4358-----------------------
INT 13 - Super PC-Kwik v5.10+ - ???
	AH = AEh
	SI = 4358h
	???
Return: ???
--------c-13B0--SI4358-----------------------
INT 13 - Super PC-Kwik v3.20+ - ???
	AH = B0h
	SI = 4358h
	???
Return: ???
Note:	PC Tools PC-Cache 5.x is an OEM version of Super PC-Kwik, and thus
	  supports this call; Qualitas Qcache does not support it
Index:	PC-Cache
--------d-13EE-------------------------------
INT 13 - SWBIOS - SET 1024 CYLINDER FLAG
	AH = EEh
	DL = drive number (80h, 81h)
Return: CF clear
	   AH = 00h
Program: SWBIOS is a TSR by Ontrack Computer Systems
Notes:	the following INT 13 call will interpret the cylinder number as 1024
	  less than the desired cylinder
	flag cleared by all INT 13 calls except AH=EEh
	Disk Manager also supports these calls
	also supported by HyperDisk v4.01+ and PC-Cache v5.5+, in order to
	  allow caching of drives using SWBIOS to access more than 1024
	  cylinders
SeeAlso: AH=F9h,AH=FEh,INT 16/AX=FFA5h/CX=1111h,INT 2F/AH=DFh
Index:	PC-Cache;huge disks|Disk Manager
--------c-13EF-------------------------------
INT 13 - NOW! - ???
	AH = EFh
	CX = ???
	DL = ???
	???
Return: ???
SeeAlso: AX=7B00h
--------d-13F9-------------------------------
INT 13 - SWBIOS - INSTALLATION CHECK
	AH = F9h
	DL = drive number (80h,81h)
Return: CF clear
	    DX = configuration word
		bit 15 set if other SWBIOS extensions available
	CF set on error
Program: SWBIOS is a TSR by Ontrack Computer Systems
Note:	Disk Manager also supports these calls
SeeAlso: AH=EEh
Index:	Disk Manager
--------v-13FA--DX5945-----------------------
INT 13 - PC Tools v8+ VSAFE, VWATCH - API
	AH = FAh
	DX = 5945h
	AL = function (00h-07h)
Return: varies by function
Note:	this API is identical to the ones on INT 16/AH=FAh and INT 21/AH=FAh,
	  so it is listed in its entirety under INT 16/AX=FA00h and following
SeeAlso: INT 16/AX=FA00h
--------d-13FE-------------------------------
INT 13 - SWBIOS - GET EXTENDED CYLINDER COUNT
	AH = FEh
	DL = drive number (80h, 81h)
Return: CF clear
	DX = number of cylinders beyond 1024 on drive
Program: SWBIOS is a TSR by Ontrack Computer Systems
Notes:	standard INT 13/AH=08h will return a cylinder count truncated to 1024
	BIOS without this extension would return count modulo 1024
	Disk Manager also supports these calls
SeeAlso: AH=EEh
--------S-14---------------------------------
INT 14 - SERIAL - Digiboard DigiCHANNEL PC/X* Extender INT 14 (XAPCM232.SYS)
Note:	the installation check for this driver is to determine whether the
	  "~DOSXAM~" character device exists
Index:	installation check;Digiboard DigiCHANNEL
--------S-1400-------------------------------
INT 14 - SERIAL - INITIALIZE PORT
	AH = 00h
	AL = port parameters
	    bits 7-5 data rate (110,150,300,600,1200,2400,4800,9600 bps)
	    bits 4-3 parity (00 or 10 = none, 01 = odd, 11 = even)
	    bit 2    stop bits (set = 2, clear = 1)
	    bits 1-0 data bits (00 = 5, 01 = 6, 10 = 7, 11 = 8)
	DX = port number (00h-03h) (04h-43h for Digiboard XAPCM232.SYS)
Return: AH = line status (see AH=03h)
	    FFh if error on Digiboard XAPCM232.SYS
	AL = modem status (see AH=03h)
Notes:	default handler is at F000h:E739h in IBM PC and 100% compatible BIOSes
	since the PCjr supports a maximum of 4800 bps, attempting to set 9600
	  bps will result in 4800 bps
	various network and serial-port drivers support the standard BIOS
	  functions with interrupt-driven I/O instead of the BIOS's polled I/O
SeeAlso: AH=04h"SERIAL",AH=04h"MultiDOS",AH=05h"SERIAL",AX=8000h"ARTICOM"
SeeAlso: AH=81h"COMM-DRV",AH=82h"COURIERS",AH=8Ch
--------S-1400-------------------------------
INT 14 - FOSSIL (Fido/Opus/Seadog Standard Interface Level) - INITIALIZE
	AH = 00h
	AL = initializing parameters
	    7 - 6 - 5	   4 - 3     2	  1 - 0
	    -BAUD RATE-	   PARITY   STOP   WORD
				    BITS  LENGTH
	    000 19200 bd   00 none  0: 1  00: 5
	    001 38400 bd   01 odd   1: 2  01: 6
	    010	  300 bd   11 even	  10: 7
	    011	  600 bd		  11: 8
	    100	 1200 bd
	    101	 2400 bd
	    110	 4800 bd
	    111	 9600 bd (4800 on PCjr)
	DX = port number (0-3 or FFh if only performing non-I/O setup)
Return: AH = RS-232 status code bits
	    bit 0: RDA - input data is available in buffer
	    bit 1: OVRN - data has been lost
	    bit 5: THRE - room is available in output buffer
	    bit 6: TSRE - output buffer empty
	AL = modem status bits
	    bit 3: always 1
	    bit 7: DCD - carrier detect
SeeAlso: AH=05h"FOSSIL",AH=81h"COMM-DRV",AH=82h"COURIERS"
--------S-1400-------------------------------
INT 14 - MBBIOS - INITIALIZE PORT
	AH = 00h
	AL = port parameters
	    bits 7-5 data rate
			(normally 110,150,300,600,1200,2400,4800,9600 bps;
			9600,14400,19200,28800,38400,57600,115200,330400 bps
			if the high-speed option is set)
	    bits 4-3 parity (00 or 10 = none, 01 = odd, 11 = even)
	    bit 2    stop bits (set = 2, clear = 1)
	    bits 1-0 data bits (00 = 5, 01 = 6, 10 = 7, 11 = 8)
	DX = port number
Return: AH = line status (see AH=03h)
	AL = modem status (see AH=03h)
Note:	MBBIOS was written by H. Roy Engehausen
SeeAlso: AH=04h"MBBIOS",AH=05h"MBBIOS"
--------S-1401-------------------------------
INT 14 - SERIAL - WRITE CHARACTER TO PORT
	AH = 01h
	AL = character to write
	DX = port number (00h-03h) (04h-43h for Digiboard XAPCM232.SYS)
Return: AH bit 7 clear if successful
	AH bit 7 set on error
	AH bits 6-0 = port status (see AH=03h)
Note:	various network and serial-port drivers support the standard BIOS
	  functions with interrupt-driven I/O instead of the BIOS's polled I/O
SeeAlso: AH=02h,AH=0Bh"FOSSIL",AX=8000h"ARTICOM",AH=89h
--------S-1402-------------------------------
INT 14 - SERIAL - READ CHARACTER FROM PORT
	AH = 02h
	AL = 00h (ArtiCom)
	DX = port number (00h-03h (04h-43h for Digiboard XAPCM232.SYS))
Return: AH = line status (see AH=03h)
	AL = received character if AH bit 7 clear
Notes:	will timeout if DSR is not asserted, even if function 03h returns
	  data ready
	various network and serial-port drivers support the standard BIOS
	  functions with interrupt-driven I/O instead of the BIOS's polled I/O
SeeAlso: AH=01h,AH=02h"FOSSIL",AH=84h,AH=FCh
--------S-1402-------------------------------
INT 14 - FOSSIL - RECEIVE CHARACTER WITH WAIT
	AH = 02h
	DX = port number (0-3)
Return: AL = character received
	AH = 00h
SeeAlso: AH=01h,AH=02h"SERIAL"
--------S-1403-------------------------------
INT 14 - SERIAL - GET PORT STATUS
	AH = 03h
	AL = 00h (ArtiCom)
	DX = port number (00h-03h) (04h-43h for Digiboard XAPCM232.SYS)
Return: AH = line status (see below)
	AL = modem status (see below)
	AX = 9E00h if disconnected (ArtiCom)
SeeAlso: AH=00h,AH=07h"MultiDOS",AX=8000h"ARTICOM",AH=81h"COURIERS",AX=FD02h

Bitfields for line status:
 bit 7	timeout
 bit 6	transmit shift register empty
 bit 5	transmit holding register empty
 bit 4	break detected
 bit 3	framing error
 bit 2	parity error
 bit 1	overrun error
 bit 0	receive data ready

Bitfields for modem status:
 bit 7	carrier detect
 bit 6	ring indicator
 bit 5	data set ready
 bit 4	clear to send
 bit 3	delta carrier detect
 bit 2	trailing edge of ring indicator
 bit 1	delta data set ready
 bit 0	delta clear to send
--------S-1404-------------------------------
INT 14 - SERIAL - EXTENDED INITIALIZE (CONVERTIBLE,PS)
	AH = 04h
	AL = break status
	    00h if break
	    01h if no break
	BH = parity (see below)
	BL = number of stop bits
	    00h one stop bit
	    01h two stop bits (1.5 if 5 bit word length)
	CH = word length (see below)
	CL = bps rate (see below)
	DX = port number
Return: AX = port status code (see AH=00h)
SeeAlso: AH=00h,AH=1Eh,AX=8000h"ARTICOM"

Values for parity:
 00h	no parity
 01h	odd parity
 02h	even parity
 03h	stick parity odd
 04h	stick parity even

Values for word length:
 00h	5 bits
 01h	6 bits
 02h	7 bits
 03h	8 bits

Values for bps rate:
 00h	110
 01h	150
 02h	300
 03h	600
 04h	1200
 05h	2400
 06h	4800
 07h	9600
 08h	19200
--------S-1404-------------------------------
INT 14 - FOSSIL - INITIALIZE DRIVER
	AH = 04h
	DX = port number
	optionally BX=4F50h
		   ES:CX -> byte to be set upon ^C
Return: AX = 1954h (if successful)
	BL = maximum function number supported (excluding 7Eh and above)
	BH = revision of FOSSIL specification supported
	DTR is raised
Note:	the word at offset 6 in the interrupt handler contains 1954h, and the
	  following byte contains the maximum function number supported; this
	  can serve as an installation check
SeeAlso: AH=05h"FOSSIL",AH=1Ch,INT 11/AH=BCh
Index:	installation check;FOSSIL
--------S-1404-------------------------------
INT 14 - MultiDOS Plus IODRV - INITIALIZE PORT
	AH = 04h
Return: port initialized; if Hayes-compatible modem, a connection has been
	  established
Note:	the port number is stored at offset BEh in the Task Control Block
	  (see INT 15/AH=13h"MultiDOS")
SeeAlso: AH=00h,AH=05h"MultiDOS",AH=20h"MultiDOS",INT 15/AH=13h"MultiDOS"
--------S-1404-------------------------------
INT 14 - Digiboard DigiCHANNEL PC/X* - CHANGE BAUD RATE
	AH = 04h
	AL = initializing parameters
	    bits 7-5 unused
	    bits 4,3: parity (00 none, 01 odd, 11 even)
	    bit 2: stop bits (0 = one, 1 = two)
	    bits 1,0: data bits (00 = five, 01 = six, 10 = seven, 11 = eight)
	BX = baud rate
	DX = port number (00h-03h) (04h-43h for XAPCM232.SYS)
Return: AH = status
	    00h successful
	    FFh error
SeeAlso: AH=05h"Digiboard"
--------S-1404-------------------------------
INT 14 - MBBIOS - INQUIRY
	AH = 04h
Return: AH = AAh
	AL = 55h
SeeAlso: AH=00h"MBBIOS",AH=09h"MBBIOS"
--------S-140400-----------------------------
INT 14 - Microsoft Systems Journal TSRCOMM INT14 - INSTALLATION CHECK
	AX = 0400h
Return: AX = 0FF0h
SeeAlso: AX=0401h,AX=0408h
--------S-140401-----------------------------
INT 14 - Microsoft Systems Journal TSRCOMM INT14 - INITIALIZE MODE
	AX = 0401h
	CX = mode
SeeAlso: AX=0400h,AX=0402h
--------S-140402-----------------------------
INT 14 - Microsoft Systems Journal TSRCOMM INT14 - EXTENDED INITIALIZE
	AX = 0402h
	CL = parameters
SeeAlso: AX=0400h,AX=0401h
--------S-140403-----------------------------
INT 14 - Microsoft Systems Journal TSRCOMM INT14 - SET TIMEOUT
	AX = 0403h
	CX = timeout
SeeAlso: AX=0400h
--------S-140404-----------------------------
INT 14 - Microsoft Systems Journal TSRCOMM INT14 - CLEAR THE RECEIVE BUFFER
	AX = 0404h
SeeAlso: AX=0400h,AX=0405h,AX=0406h
--------S-140405-----------------------------
INT 14 - Microsoft Systems Journal TSRCOMM INT14 - GET RECEIVE BUFFER COUNT
	AX = 0405h
Return: AX = number of characters in buffer
SeeAlso: AX=0400h,AX=0404h,AX=0407h
--------S-140406-----------------------------
INT 14 - Microsoft Systems Journal TSRCOMM INT14 - CLEAR THE TRANSMIT BUFFER
	AX = 0406h
SeeAlso: AX=0400h,AX=0404h,AX=0407h
--------S-140407-----------------------------
INT 14 - Microsoft Systems Journal TSRCOMM INT14 - GET TRANSMIT BUFFER COUNT
	AX = 0407h
Return: AX = number of characters in the buffer
SeeAlso: AX=0400h,AX=0405h,AX=0406h
--------S-140408-----------------------------
INT 14 - Microsoft Systems Journal TSRCOMM INT14 - UNINSTALL
	AX = 0408h
SeeAlso: AX=0400h
--------S-1405-------------------------------
INT 14 - SERIAL - EXTENDED COMMUNICATION PORT CONTROL (CONVERTIBLE,PS)
	AH = 05h
	AL = function
	    00h read modem control register
	      Return: BL = modem control register (see below)
		      AH = status
	    01h write modem control register
	      BL = modem control register (see below)
	      Return: AX = status
	DX = port number
Note:	also supported by ArtiCom
SeeAlso: AH=00h,AH=1Fh,AX=8000h"ARTICOM",AH=FBh

Bitfields for modem control register:
 bit 0	data terminal ready
 bit 1	request to send
 bit 2	OUT1
 bit 3	OUT2
 bit 4	LOOP
 bits 5-7 reserved
--------S-1405-------------------------------
INT 14 - FOSSIL - DEINITIALIZE DRIVER
	AH = 05h
	DX = port number
Return: none
	DTR is not affected
SeeAlso: AH=00h,AH=04h"FOSSIL",AH=1Dh,AH=8Dh
--------S-1405-------------------------------
INT 14 - MultiDOS Plus IODRV - READ CHARACTER FROM PORT
	AH = 05h
	AL = timeout in seconds (00h = never)
Return: AL = status
	    00h successful
		AH = character read
	    01h read error
	    02h timed out
	    other modem status (CTS, DSR) changed
Note:	the port number is stored at offset BEh in the Task Control Block
SeeAlso: AH=02h,AH=04h"MultiDOS",AH=06h"MultiDOS",AH=22h"MultiDOS"
SeeAlso: INT 15/AH=13h"MultiDOS"
--------S-1405-------------------------------
INT 14 - Digiboard DigiCHANNEL PC/X* - CHANGE PROTOCOL
	AH = 05h
	AL = protocol
	    bits 7-4 unused
	    bit 3: RTS/CTS
	    bit 2: DSR
	    bits 1,0: XON/XOFF
	BH = new XOFF character (00h = current)
	BL = new XON character (00h = current)
	DX = port number (00h-03h) (04h-43h for XAPCM232.SYS)
Return: AH = status
	    00h successful
	    FFh error
SeeAlso: AH=04h"Digiboard"
--------S-1405-------------------------------
INT 14 - MBBIOS - DROP DTR AND RTS
	AH = 05h
	DX = port number
Return: none
SeeAlso: AH=00h"MBBIOS",AH=06h"MBBIOS",AH=06h"FOSSIL"
--------S-1405-------------------------------
INT 14 - PC-MOS/386 v5.01 $serial.sys v5.04 - CHANGE PORT PROTOCOL
	AH = 05h
	AL = bit 7: set to enable/disable CD monitoring, clear to set protocol
	     ---bit 7 set---
	     bit 4: CD monitoring enabled
	     bit 5: automatic restart enabled
	     ---bit 7 clear---
	     bit 0: receive XON/XOFF
	     bit 1: transmit XON/XOFF
	     bit 2: DTR/DSR
	     bit 3: RTS/CTS
	BH = new XOFF character
	BL = new XON character
	DX = port number
Return: AH = FFh if invalid protocol
SeeAlso: AH=00h,AH=04h"SERIAL",AH=06h"PC-MOS"
--------S-1406-------------------------------
INT 14 - FOSSIL - RAISE/LOWER DTR
	AH = 06h
	DX = port
	AL = DTR state to be set
	    00h = lower
	    01h = raise
SeeAlso: AH=05h"MBBIOS",AH=1Ah
--------S-1406-------------------------------
INT 14 - MultiDOS Plus IODRV - WRITE CHARACTER TO PORT
	AH = 06h
	AL = character
Return: AL = status
	    00h successful
Notes:	the port number is stored at offset BEh in the Task Control Block
	if output queue is full, the calling task is blocked until the
	  character can be stored
SeeAlso: AH=01h,AH=04h"MultiDOS",AH=05h"MultiDOS",AH=21h"MultiDOS"
SeeAlso: INT 15/AH=13h"MultiDOS"
--------S-1406-------------------------------
INT 14 - MBBIOS - RAISE DTR AND RTS
	AH = 06h
	DX = port number
Return: none
SeeAlso: AH=05h"MBBIOS",AH=07h"MBBIOS"
--------S-1406-------------------------------
INT 14 - PC-MOS/386 v5.01 $serial.sys v5.04 - DRIVER 'ID' FUNCTION
	AH = 06h
	DX = port number
Return: AH bit 7 set
	AL = number of highest function supported by driver
Program: PC-MOS/386 v5.01 is a multitasking, multiuser MS-DOS 5.0-compatible
	  operating system by The Software Link, Inc.
SeeAlso: AH=18h"PC-MOS"
--------N-1406-------------------------------
INT 14 - TelAPI - ???
	AH = 06h
	???
Return: ???
SeeAlso: AH=07h"TelAPI",AH=E0h"TelAPI"
--------S-1407-------------------------------
INT 14 - FOSSIL - RETURN TIMER TICK PARAMETERS
	AH = 07h
Return: AL = timer tick interrupt number
	AH = ticks per second on interrupt number in AL
	DX = approximate number of milliseconds per tick
SeeAlso: AH=16h
--------S-1407-------------------------------
INT 14 - MultiDOS Plus IODRV - GET PORT STATUS
	AH = 07h
Return: CL = modem status (see AH=03h)
	CH = character at head of input queue (if any)
	DX = number of characters in input queue
Note:	the port number is stored at offset BEh in the Task Control Block
SeeAlso: AH=03h,AH=05h"MultiDOS",AH=08h"MultiDOS",AH=09h"MultiDOS"
SeeAlso: AH=23h"MultiDOS",INT 15/AH=13h"MultiDOS"
--------S-1407-------------------------------
INT 14 - MBBIOS - SEND BREAK
	AH = 07h
	DX = port number
Return: none
SeeAlso: AH=06h"MBBIOS"
--------S-1407-------------------------------
INT 14 - PC-MOS/386 v5.01 $serial.sys v5.04 - SEND RS-232 BREAK
	AH = 07h
	BX = duration of break in clock ticks
	DX = port number
Return: nothing
--------N-1407-------------------------------
INT 14 - TelAPI - ???
	AH = 07h
	???
Return: ???
SeeAlso: AH=06h"TelAPI",AH=E0h"TelAPI"
--------S-1408-------------------------------
INT 14 - FOSSIL - FLUSH OUTPUT BUFFER WAITING TILL ALL OUTPUT IS DONE
	AH = 08h
	DX = port number
SeeAlso: AH=09h"FOSSIL"
--------S-1408-------------------------------
INT 14 - MultiDOS Plus 4.0 IODRV - GET AND RESET PORT LINE STATUS
	AH = 08h
Return: AL = line status (see AH=03h)
	AH destroyed
Notes:	the port number is stored at offset BEh in the Task Control Block
	on every line status change, the line status is ORed with the line
	  status accumulator; this function returns the accumulator and clears
	  it
SeeAlso: AH=03h,AH=04h"MultiDOS",AH=07h"MultiDOS",INT 15/AH=13h"MultiDOS"
--------S-1408-------------------------------
INT 14 - Digiboard DigiCHANNEL PC/X* - ALTERNATE STATUS CHECK
	AH = 08h
	DX = port number (00h-03h) (04h-43h for XAPCM232.SYS)
Return: AH = RS232 status bits (see AH=03h)
	ZF set if no characters queued
	ZF clear if character available
	    AL = next character
SeeAlso: AH=03h,AH=08h"PC-MOS",AH=09h"Digiboard"
--------S-1408-------------------------------
INT 14 - MBBIOS - NON-DESTRUCTIVE READ
	AH = 08h
	DX = port number
Return: AL = character
	AH = status (see AH=02h)
SeeAlso: AH=0Bh"MBBIOS",AH=0Ch"FOSSIL"
--------S-1408-------------------------------
INT 14 - PC-MOS/386 v5.01 $serial.sys v5.04 - INPUT STATUS CHECK
	AH = 08h
	DX = port number
Return: CF set if carrier loss detected
	ZF set if input buffer empty
	ZF clear if characters available
	    AL = next character dequeued
--------S-1409-------------------------------
INT 14 - FOSSIL - PURGE OUTPUT BUFFER THROWING AWAY ALL PENDING OUTPUT
	AH = 09h
	DX = port number
SeeAlso: AH=08h"FOSSIL",AH=0Ah"FOSSIL",AH=88h
--------S-1409-------------------------------
INT 14 - MultiDOS Plus IODRV - RESET PORT STATUS
	AH = 09h
Return: modem status byte cleared
Note:	the port number is stored at offset BEh in the Task Control Block
SeeAlso: AH=04h"MultiDOS",AH=07h"MultiDOS",INT 15/AH=13h"MultiDOS"
--------S-1409-------------------------------
INT 14 - Digiboard DigiCHANNEL PC/X* - CLEAR BUFFERS
	AH = 09h
	DX = port number (00h-03h) (04h-43h for XAPCM232.SYS)
Return: AH = status
	    00h successful
	    FFh error
SeeAlso: AH=08h"Digiboard",AH=0Ah"Digiboard",AH=10h"Digiboard"
--------S-1409-------------------------------
INT 14 - MBBIOS - GET/SET OPTIONS
	AH = 09h
	AL = option byte
		00000001b - Transmit Buffering Enabled
		00000101b - Hardware Handshaking Enabled
		00100000b - High Speed Option Enabled
	DX = port number???
Return: AL = old option byte
SeeAlso: AH=04h"MBBIOS",AH=10h"FOSSIL"
--------S-1409-------------------------------
INT 14 - PC-MOS/386 v5.01 $serial.sys v5.04 - RESET I/O BUFFER POINTERS
	AH = 09h
	DX = port number
Return: nothing
SeeAlso: AH=13h"PC-MOS"
--------S-140A-------------------------------
INT 14 - FOSSIL - PURGE INPUT BUFFER THROWING AWAY ALL PENDING INPUT
	AH = 0Ah
	DX = port number
SeeAlso: AH=09h"FOSSIL",AH=85h
--------S-140A-------------------------------
INT 14 - Digiboard DigiCHANNEL PC/X* - INPUT QUEUE CHECK
	AH = 0Ah
	DX = port number (00h-03h) (04h-43h for XAPCM232.SYS)
Return: AX = number of characters available in buffer
Note:	this function is also supported by the PC-MOS/386 v5.01 $serial.sys
SeeAlso: AH=09h"Digiboard",AH=0Dh"Digiboard"
--------S-140A-------------------------------
INT 14 - MBBIOS - WRITE BUFFER
	AH = 0Ah
	CX = count
	ES:DI -> buffer
Return: AX = status (see AH=03h)
	DI = is updated
	CX = unsent character count
SeeAlso: AH=0Bh"MBBIOS",AH=19h"FOSSIL"
--------S-140B-------------------------------
INT 14 - FOSSIL - TRANSMIT NO WAIT
	AH = 0Bh
	AL = character
	DX = port number
Return: AX = 0000h character not accepted
	   = 0001h character accepted
SeeAlso: AH=01h
--------S-140B-------------------------------
INT 14 - MBBIOS - READ BUFFER
	AH = 0Bh
	CX = size of buffer
	ES:DI -> buffer
Return: AH = LSR
	AL = MSR
	CX = count of characters
	DI = is updated
SeeAlso: AH=08h"MBBIOS",AH=0Ah"MBBIOS",AH=18h"FOSSIL"
--------S-140C-------------------------------
INT 14 - FOSSIL - NON-DESTRUCTIVE READ AHEAD
	AH = 0Ch
	DX = port number
Return: AX = FFFFh character not available
	AX = 00xxh character xx available
SeeAlso: AH=08h"MBBIOS",AH=20h"FOSSIL"
--------S-140D-------------------------------
INT 14 - FOSSIL - KEYBOARD READ WITHOUT WAIT
	AH = 0Dh
Return: AX = FFFFh character not available
	   = xxyyh standard IBM-style scan code
SeeAlso: AH=0Eh
--------S-140D-------------------------------
INT 14 - Digiboard DigiCHANNEL PC/X* - GET POINTER TO CH_KEY_RDY FLAG
	AH = 0Dh
	DX = port number (00h-03h) (04h-43h for XAPCM232.SYS)
Return: ES:BX -> CH_KEY_RDY flag
SeeAlso: AH=0Ah"Digiboard"

Values for CH_KEY_RDY flag:
 00h	receive buffer empty
 FFh	characters available
--------S-140E-------------------------------
INT 14 - FOSSIL - KEYBOARD READ WITH WAIT
	AH = 0Eh
Return: AX = xxyyh standard IBM-style scan code
SeeAlso: AH=0Dh"FOSSIL"
--------S-140E-------------------------------
INT 14 - Digiboard DigiCHANNEL PC/X* - WRITE STRING
	AH = 0EH
	CX = number of characters to write
	ES:BX -> string
	DX = port number (00h-03h) (04h-43h for XAPCM232.SYS)
Return: AX = number of characters actually written
	ZF clear if successful
	ZF set on error
SeeAlso: AH=0Fh"Digiboard"
--------S-140F-------------------------------
INT 14 - FOSSIL - ENABLE/DISABLE FLOW CONTROL
	AH = 0Fh
	AL = bit mask describing requested flow control (see below)
	DX = port number
SeeAlso: AH=09h"MBBIOS",AH=10h"FOSSIL"

Bitfields for requested flow control:
 bit 0	XON/XOFF on transmit (watch for XOFF while sending)
 bit 1	CTS/RTS (CTS on transmit/RTS on receive)
 bit 2	reserved
 bit 3	XON/XOFF on receive (send XOFF when buffer near full)
 bit 4-7 all 1
--------S-140F-------------------------------
INT 14 - Digiboard DigiCHANNEL PC/X* - READ STRING
	AH = 0Fh
	CX = number of characters to read
	ES:BX -> buffer
	DX = port number (00h-03h) (04h-43h for XAPCM232.SYS)
Return: AX = number of characters read
	ZF clear if successful
	ZF set on error (line status or wrong number of characters)
SeeAlso: AH=0Eh"Digiboard"
--------S-1410-------------------------------
INT 14 - FOSSIL - EXTENDED ^C/^K CHECKING AND TRANSMIT ON/OFF
	AH = 10h
	AL = bit mask
	    bit 0: enable/disable ^C/^K checking
	    bit 1: enable/disable the transmitter
	DX = port number
SeeAlso: AH=0Fh"FOSSIL"
--------S-1410-------------------------------
INT 14 - Digiboard DigiCHANNEL PC/X* - CLEAR RECEIVE BUFFER
	AH = 10h
	DX = port number (00h-03h) (04h-43h for XAPCM232.SYS)
Return: AH = status
	    00h successful
	    FFh error
SeeAlso: AH=09h"Digiboard",AH=11h"Digiboard"
--------S-1411-------------------------------
INT 14 - FOSSIL - SET CURRENT CURSOR LOCATION
	AH = 11h
	DH = row
	DL = column
Note:	this is the same as INT 10/AH=02h
SeeAlso: AH=12h"FOSSIL"
--------S-1411-------------------------------
INT 14 - Digiboard DigiCHANNEL PC/X* - CLEAR TRANSMIT BUFFER
	AH = 11h
	DX = port number (00h-03h) (04h-43h for XAPCM232.SYS)
Return: AH = status
	    00h successful
	    FFh error
SeeAlso: AH=09h"Digiboard",AH=10h"Digiboard"
----------1411-------------------------------
INT 14 - PC-MOS/386 v5.01 $serial.sys v5.04 - DISABLE PORT
	AH = 11h
	DX = port number
Return: AL = status
	    00h successful
	    01h IRQ for port is shared
	    02h IRQ was reserved
SeeAlso: AH=04h,AH=05h,AH=12h"PC-MOS"
--------S-1412-------------------------------
INT 14 - FOSSIL - READ CURRENT CURSOR LOCATION
	AH = 12h
Return: DH = row
	DL = column
Note:	this is the same as INT 10/AH=03h
SeeAlso: AH=11h"FOSSIL"
--------S-1412-------------------------------
INT 14 - Digiboard DigiCHANNEL PC/X* - GET TRANSMIT BUFFER FREE SPACE
	AH = 12h
	DX = port number (00h-03h) (04h-43h for XAPCM232.SYS)
Return: AX = number of bytes free
SeeAlso: AH=0Ah"Digiboard"
--------S-1412-------------------------------
INT 14 - PC-MOS/386 v5.01 $serial.sys v5.04 - GET CURRENT PORT PARAMETERS
	AH = 12h
	DX = port number
Return: AH = status
	    FFh port number invalid
	AL = line parameters (see AH=00h)
	AH = flow control configuration (see AH=05h"PC-MOS")
	CX:BX = bps rate
	DL = XOFF character or 00h for none
	DH = XON character or 00h for none
--------S-1413-------------------------------
INT 14 - FOSSIL - SINGLE CHARACTER ANSI WRITE TO SCREEN
	AH = 13h
	AL = character
Note:	should not be called if it is unsafe to call DOS
SeeAlso: AH=15h
--------S-1413-------------------------------
INT 14 - PC-MOS/386 v5.01 $serial.sys v5.04 - REGISTER A PORT WITH A TERMINAL
	AH = 13h
	DX = port number
Return: AH = status
	    FFh port number invalid
	    else
		ES:BX -> BYTE flag (00h buffer empty, FFh buffer contains data)
SeeAlso: AH=17h"PC-MOS"
--------S-1414-------------------------------
INT 14 - FOSSIL - ENABLE OR DISABLE WATCHDOG PROCESSING
	AH = 14h
	AL = 01h enable watchdog
	     00h disable watchdog
	DX = port number
--------S-1414-------------------------------
INT 14 - PC-MOS/386 v5.01 $serial.sys v5.04 - OUTPUT STRING
	AH = 14h
	CX = number of characters in string
	DX = port number
	ES:BX -> string to be sent
	SI = timeout in timer ticks or 0000h for default
Return: AX = number of bytes actually sent
	ZF clear if successful
	ZF set on timeout
SeeAlso: AH=01h,AH=15h"PC-MOS"
--------S-1415-------------------------------
INT 14 - FOSSIL - WRITE CHARACTER TO SCREEN USING BIOS SUPPORT ROUTINES
	AH = 15h
	AL = character
SeeAlso: AH=13h"FOSSIL"
--------S-1415-------------------------------
INT 14 - PC-MOS/386 v5.01 $serial.sys v5.04 - INPUT STRING
	AH = 15h
	CX = size of buffer
	DX = port number
	ES:BX -> buffer for received characters
	SI = timeout in clock ticks or 0000h for default
Return: AX = number of characters actually read
	ZF set on timeout (no data available)
SeeAlso: AH=02h,AH=14h"PC-MOS",AH=16h"PC-MOS"
--------S-1416-------------------------------
INT 14 - FOSSIL - INSERT/DELETE FUNCTION FROM TIMER TICK CHAIN
	AH = 16h
	AL = function
	    00h = delete
	    01h = add
	ES:DX -> routine to call
Return: AX = status
	    0000h successful
	    0001h unsuccessful
SeeAlso: AH=07h"FOSSIL"
--------S-1416-------------------------------
INT 14 - Digiboard DigiCHANNEL PC/X* - CCB COMMAND
	AH = 16h
	AL = CCB command number (see below)
	BL = byte 2
	BH = byte 3
	CL = byte 1 (for all channel functions except 4Eh and 4Fh)
	DX = port number (00h-03h) (04h-43h for XAPCM232.SYS)
Return: AH = status
	    00h successful
	    FFh error
SeeAlso: AH=18h"Digiboard"

Values for CCB command number:
 40h	Set Receive Mid Water Mark
 41h	Set Receive High Water Mark
 42h	Flush Receive Buffer
 43h	Flush Transmit Buffer
 44h	Transmit Pause
 45h	Transmit Resume
 46h	Set Interrupt to Host Mask
 47h	Set Baud, Data, Stop and Parity
 48h	Send Break
 49h	Set Modem Lines
 4Ah	Set Break Count
 4Bh	Set Handshake
 4Ch	Set Xon/Xoff Characters
 4Dh	Set Transmit Mid Water Mark
 4Eh	IRQ Polling Timer to Host
 4Fh	Buffer Set All
 50h	Port On
 51h	Port Off
 52h	Receive Pause
 53h	Special Character Interrupt
 54h	RS-422 Enable
--------S-1416-------------------------------
INT 14 - PC-MOS/386 v5.01 $serial.sys v5.04 - LINK TO ANOTHER SERIAL DRIVER
	AH = 16h
	ES:BX -> calling driver's INT 14 entry point
Return: nothing
Program: PC-MOS/386 v5.01 is a multitasking, multiuser MS-DOS 5.0-compatible
	  operating system by The Software Link, Inc.
--------S-1417-------------------------------
INT 14 - FOSSIL - REBOOT SYSTEM
	AH = 17h
	AL = method
	    00h = cold boot
	    01h = warm boot
SeeAlso: INT 19
--------S-1417-------------------------------
INT 14 - PC-MOS/386 v5.01 $serial.sys v5.04 - WRITE MODEM CONTROL REGISTER
	AH = 17h
	AL = new value for UART's modem control register
	DX = port number
Return: nothing
--------S-1418-------------------------------
INT 14 - FOSSIL - READ BLOCK
	AH = 18h
	CX = maximum number of characters to transfer
	DX = port number
	ES:DI -> user buffer
Return: AX = number of characters transferred
SeeAlso: AH=19h"FOSSIL",AH=83h"COURIERS",AX=FF02h,INT 6B/AX=0100h
--------S-1418-------------------------------
INT 14 - Digiboard DigiCHANNEL PC/X* - SEND BIOS COMMAND
	AH = 18h
	ES:BX -> 16-byte command string
	DX = port number (00h-03h) (04h-43h for XAPCM232.SYS)
Return: AH = status
	    00h successful
	    80h timeout
	AL = mailbox status
	    00h no errors
	    8Xh BIOS error
	ES:BX buffer filled in with mailbox string
	ZF clear if no errors
	ZF set if either status byte contains an error code
SeeAlso: AH=16h"Digiboard"
--------S-1418-------------------------------
INT 14 - PC-MOS/386 v5.01 $serial.sys v5.04 - GET DRIVER DESCRIPTION
	AH = 18h
	DX = port number
Return: DS:BX -> 40-byte buffer containing a string identifying the serial
		driver
SeeAlso: AH=06h"PC-MOS"
--------S-1419-------------------------------
INT 14 - FOSSIL - WRITE BLOCK
	AH = 19h
	CX = maximum number of characters to transfer
	DX = port number
	ES:DI -> user buffer
Return: AX = number of characters transferred
SeeAlso: AH=18h"FOSSIL",AH=86h,INT 6B/AX=0000h
--------S-1419-------------------------------
INT 14 - Digiboard DigiCHANNEL PC/X* - SPECIAL CHARACTER INTERRUPT
	AH = 19h
	BL = flag
	    00h disable special character interrupt
	    FFh enable interrupt
	DX = port number (00h-03h) (04h-43h for XAPCM232.SYS)
Return: AH = status
	    00h successful
	    FFh failed
SeeAlso: AH=1Ah"Digiboard"
--------S-1419-------------------------------
INT 14 - PC-MOS/386 v5.01 $serial.sys v5.04 - SELECTIVE BUFFER FLUSH
	AH = 19h
	AL = what to flush
		bit 0: input buffer
		bit 1: output buffer
	DX = port number
Return: nothing
SeeAlso: AH=09h"PC-MOS"
--------S-141A-------------------------------
INT 14 - FOSSIL - BREAK BEGIN OR END
	AH = 1Ah
	AL = 00h stop sending 'break'
	     01h start sending 'break'
	DX = port number
SeeAlso: AH=06h"FOSSIL",AH=8Ah,AH=FAh
--------S-141A-------------------------------
INT 14 - Digiboard DigiCHANNEL PC/X - SPECIAL CHARACTER FLAG/COUNTER
	AH = 1Ah
	BX = subfunction
	    00h return pointer to special character flag byte
	    01h return pointer to special character counter word
	DX = port number (00h-03h) (04h-43h for XAPCM232.SYS)
Return: ES:BX -> special character flag or counter
Notes:	flag is FFh if one or more special characters are in the receive
	  buffer; it is 00h and the counter is invalid if no special characters
	  are in the receive buffer
	counter (if valid) contains the number of characters in the receive
	  buffer up to and including the last-received special character
--------S-141B-------------------------------
INT 14 - FOSSIL - RETURN INFORMATION ABOUT THE DRIVER
	AH = 1Bh
	DX = port number
	CX = size of user buffer
	ES:DI -> user buffer for driver info (see below)
Return: AX = number of characters transferred
	CX = 3058h ("0X") (X00 FOSSIL only)
	DX = 2030h (" 0") (X00 FOSSIL only)

Format of driver info:
Offset	Size	Description
 00h	WORD	size of structure in bytes
 02h	BYTE	FOSSIL spec driver conforms to
 03h	BYTE	revision level of this specific driver
 04h	DWORD	pointer to ASCIZ identification string
 08h	WORD	size of the input buffer
 0Ah	WORD	number of bytes left in buffer
 0Ch	WORD	size of the output buffer
 0Eh	WORD	number of bytes left in buffer
 10h	BYTE	width of screen
 11h	BYTE	length of screen
 12h	BYTE	actual baud rate, computer to modem
--------S-141C-------------------------------
INT 14 - X00 FOSSIL - ACTIVATE PORT
	AH = 1Ch
	DX = port number
Return: AX = 1954h if successful
	BL = maximum function number supported (not including 7Eh and above)
	BH = revision of FOSSIL specification supported
Note:	this is a duplicate of AH=04h, so that AH=04h may be made compatible
	  with the PS/2 BIOS in a future release
SeeAlso: AH=04h"FOSSIL",AH=1Dh
--------S-141D-------------------------------
INT 14 - X00 FOSSIL - DEACTIVATE PORT
	AH = 1Dh
	DX = port number
Return: none
Notes:	this is a duplicate of AH=05h, so that AH=05h may be made compatible
	  with the PS/2 BIOS in a future release
	ignored if the port was never activated with AH=04h or AH=1Ch
SeeAlso: AH=05h"FOSSIL",AH=1Ch
--------S-141E-------------------------------
INT 14 - X00 FOSSIL - EXTENDED LINE CONTROL INITIALIZATION
	AH = 1Eh
	AL = break status
	    00h if break
	    01h if no break
	BH = parity (see below)
	BL = number of stop bits
	    00h one stop bit
	    01h two stop bits (1.5 if 5 bit word length)
	CH = word length (see below)
	CL = bps rate (see below)
	DX = port number
Return: AX = port status code (see AH=00h)
Notes:	this function is intended to exactly emulate the PS/2 BIOS AH=04h call
	if the port was locked at X00 load time, the appropriate parameters are
	  ignored
SeeAlso: AH=00h,AH=04h"SERIAL I/O"

Values for parity:
 00h	no parity
 01h	odd parity
 02h	even parity
 03h	stick parity odd
 04h	stick parity even

Values for word length:
 00h	5 bits
 01h	6 bits
 02h	7 bits
 03h	8 bits

Values for bps rate:
 00h	110
 01h	150
 02h	300
 03h	600
 04h	1200
 05h	2400
 06h	4800
 07h	9600
 08h	19200
--------S-141F-------------------------------
INT 14 - X00 FOSSIL - EXTENDED SERIAL PORT STATUS/CONTROL
	AH = 1Fh
	AL = 00h read modem control register
	      Return: BL = modem control register (see below)
		      AH = status
	AL = 01h write modem control register
	      BL = modem control register (see below)
	      Return: AX = status
	DX = port number
Notes:	this function is intended to exactly emulate the PS/2 BIOS AH=05h call
	X00 forces BL bit 3 set (interrupts cannot be disabled)
SeeAlso: AH=00h,AH=05h"SERIAL I/O"

Bitfields for modem control register:
 bit 0	data terminal ready
 bit 1	request to send
 bit 2	OUT1
 bit 3	OUT2 (interrupts) enabled
 bit 4	LOOP
 bits 5-7 reserved
--------S-1420-------------------------------
INT 14 - X00 FOSSIL - DESTRUCTIVE READ WITH NO WAIT
	AH = 20h
	DX = port number
Return: AH = 00h if character was available
	    AL = next character (removed from receive buffer)
	AX = FFFFh if no character available
SeeAlso: AH=0Ch,AH=21h"X00"
--------S-1420-------------------------------
INT 14 - Alloy MW386 - ATTACH LOGICAL COMMUNICATIONS PORT TO PHYSICAL PORT
	AH = 20h
	AL = logical port (01h COM1, 02h COM2)
	DX = physical port number
Return: AX = status
	    0000h successful
	    FFFFh failed
SeeAlso: AH=21h"Alloy",AH=22h"Alloy",AH=23h"Alloy",INT 17/AH=8Bh"Alloy"
--------S-1420-------------------------------
INT 14 - MultiDOS Plus - INITIALIZE PORT
	AH = 20h
	AL = port parameters (see AH=00h"SERIAL")
	DX = port number (0-3)
Return: AH = status
	    00h successful
	    41h no such port
	    64h monitor mode already active
SeeAlso: AH=00h"SERIAL",AH=04h"MultiDOS",AH=21h"MultiDOS",AH=23h"MultiDOS"
--------S-1420-------------------------------
INT 14 - PC-MOS/386 v5.01 $serial.sys v5.04 - CHECK OUTPUT QUEUE
	AH = 20h
	DX = port number
Return: AX = number of bytes in output buffer
SeeAlso: AH=0Ah"PC-MOS"
--------S-1421-------------------------------
INT 14 - X00 FOSSIL - STUFF RECEIVE BUFFER
	AH = 21h
	AL = character
	DX = port number
Notes:	the given character is inserted at the end of the receive buffer as if
	  it had just arrived from the serial port; all normal receive
	  processing (XON/XOFF, ^C/^K) is performed on the character
	fully re-entrant
SeeAlso: AH=20h"X00"
--------S-1421-------------------------------
INT 14 - Alloy MW386 v1.x only - RELEASE PHYSICAL COMMUNICATIONS PORT
	AH = 21h
	DX = physical port number
Return: AX = status
	    0000h successful
	    FFFFh failed
SeeAlso: AH=20h"Alloy",AH=22h"Alloy"
--------S-1421-------------------------------
INT 14 - MultiDOS Plus - TRANSMIT CHARACTER
	AH = 21h
	AL = character to send
	DX = port number
Return: AH = status (see below)
Note:	monitor mode must have been turned on with AH=24h before calling
SeeAlso: AH=20h"MultiDOS",AH=22h"MultiDOS",AH=24h"MultiDOS"

Values for status:
 00h	successful
 39h	no DSR or CTS
 3Ch	no DSR
 3Bh	no CTS
 41h	no such port
 42h	monitor mode not active
 97h	timed out
--------S-1421-------------------------------
INT 14 - PC-MOS/386 v5.01 $serial.sys v5.04 - OUTPUT CHARACTER, WITH TIMEOUT
	AH = 21h
	AL = char to send
	DX = port number
	SI = timeout in timer ticks (0000h = default)
Program: PC-MOS/386 v5.01 is a multitasking, multiuser MS-DOS 5.0-compatible
	  operating system by The Software Link, Inc.
SeeAlso: AH=01h,AH=0Eh"PC/MOS",AH=22h"PC-MOS"
--------S-1422-------------------------------
INT 14 - Alloy MW386 v2+ - RELEASE LOGICAL COMMUNICATIONS PORT
	AH = 22h
	AL = logical port (01h COM1, 02h COM2)
Return: AX = status (0000h successful)
SeeAlso: AH=20h"Alloy",AH=21h"Alloy"
--------S-1422-------------------------------
INT 14 - MultiDOS Plus - RECEIVE CHARACTER
	AH = 22h
	DX = port number
Return: AH = status (see also AH=21h"MultiDOS")
	    00h successful
		AL = character
	    3Dh framing and parity error
	    3Eh overrun error
	    3Fh framing error
	    40h parity error
	    96h ring buffer overflow
Note:	if no character is available, this function waits until a character
	  arrives or an implementation-dependent timeout elapses
SeeAlso: AH=20h"MultiDOS",AH=21h"MultiDOS",AH=27h
--------S-1422-------------------------------
INT 14 - PC-MOS/386 v5.01 $serial.sys v5.04 - RECEIVE CHARACTER, WITH TIMEOUT
	AH = 22h
	DX = port number
	SI = timeout in timer ticks (0000h = default)
Return: AH = port status (see AH=03h bits 0..6)
	     bit 7 = 1 indicates time-out
	AL = character received
Program: PC-MOS/386 v5.01 is a multitasking, multiuser MS-DOS 5.0-compatible
	  operating system by The Software Link, Inc.
SeeAlso: AH=02h,AH=0Fh"PC-MOS",AH=21h"PC-MOS"
--------S-1423-------------------------------
INT 14 - Alloy MW386 v2+ - GET PORT NUMBER FROM LOGICAL PORT ID
	AH = 23h
	AL = logical port (01h COM1, 02h COM2)
	DH = user ID
	DL = process ID (DH,DL both FFh for current task)
Return: AL = MW386 port mode (see below)
	CX = MW386 port number
	DH = owner's user ID
	DL = owner's task ID
SeeAlso: AH=20h"Alloy",INT 17/AH=8Bh"Alloy"

Bitfields for MW386 port mode:
 bit 0	port is shared (spooler only)
 bit 1	port is spooled instead of direct (spooler only)
 bit 2	port is assigned as logical COM device, not in spooler
 bit 3	port is free
--------S-1423-------------------------------
INT 14 - MultiDOS Plus - GET PORT STATUS
	AH = 23h
	DX = port number
Return: AH = line status (see AH=03h)
	AL = modem status (see AH=03h)
SeeAlso: AH=03h,AH=07h"MultiDOS",AH=20h"MultiDOS"
--------S-1423-------------------------------
INT 14 - PC-MOS/386 v5.01 $serial.sys v5.04 - DECLARE PORT OWNERSHIP
	AH = 23h
	DX = port number
	BX = TCB segment/selector address of owner task
Return: nothing
SeeAlso: AH=0Dh"PC-MOS"
--------S-1424-------------------------------
INT 14 - Alloy MW386 v2+ - CHANGE PHYSICAL PORT PARAMETERS
	AH = 24h
	CX = physical I/O port number
	DS:DX -> configuration table (see below)
Return: AH = 00h
Note:	invalid port numbers are merely ignored
SeeAlso: INT 17/AH=96h

Format of configuration table:
Offset	Size	Description
 00h	BYTE	baud rate (see below)
 01h	BYTE	data bits (00h=5, 01h=6, 02h=7, 03h=8)
 02h	BYTE	parity (00h none, 01h odd, 02h even)
 03h	BYTE	stop bits (00h=1, 01h=2)
 04h	BYTE	receive flow control
		00h none, 01h XON/XOFF, 02h DTR/DSR, 03h XPC, 04h RTS/CTS
 05h	BYTE	transmit flow control (as for receive)

Values for baud rate:
 00h	38400
 01h	19200
 02h	9600
 03h	7200
 04h	4800
 05h	3600
 06h	2400
 07h	2000
 08h	1200
 09h	600
 0Ah	300
 0Bh	150
 0Ch	134.5
--------S-1424-------------------------------
INT 14 - MultiDOS Plus - SET MONITOR MODE
	AH = 24h
	AL = port status storage
	    00h single status for entire receive buffer
	    01h separate status kept for each byte in receive buffer
	DX = port number
Return: AH = status
	    00h successful
	    3Ah invalid status storage specified
	    41h no such port
	    64h monitor mode already active
Note:	in monitor mode, MultiDOS redirects all BIOS video output to a serial
	  port
SeeAlso: AH=20h"MultiDOS",AH=25h
--------S-1424-------------------------------
INT 14 - PC-MOS/386 v5.01 $serial.sys v5.04 - ???
	AH = 24h
Return: ???
Program: PC-MOS/386 v5.01 is a multitasking, multiuser MS-DOS 5.0-compatible
	  operating system by The Software Link, Inc.
--------S-1425-------------------------------
INT 14 - MultiDOS Plus - CLEAR BUFFERS
	AH = 25h
	AL = function
	    00h only clear buffers
	    01h clear buffers and deactivate
	DX = port number
Return: AH = status
	    00h successful
	    3Ah invalid function
	    41h no such port
	    42h monitor mode not active
SeeAlso: AH=20h"MultiDOS",AH=24h"MultiDOS"
--------S-1427-------------------------------
INT 14 - MultiDOS Plus - GET BUFFER CHARACTER COUNT
	AH = 27h
	DX = port number
Return: AH = status
	    00h successful
	    41h no such port
	    42h monitor mode not active
	AL = number of characters in receive buffer
--------S-1456-------------------------------
INT 14 U - BWCOM14 - INSTALLATION CHECK
	AH = 56h
Return: CX = 0001h if installed
Program: BWCOM14 is a network serial port emulator (simulating a Hayes modem
	  connected to the serial port) distributed as part of the
	  Beame&Whiteside BW-NFS package
SeeAlso: AH=57h,AH=58h
--------S-1457-------------------------------
INT 14 U - BWCOM14 - ???
	AH = 57h
	???
Return: AL = ???
	CX = status (0001h,0002h,FFFFh)
SeeAlso: AH=56h
--------S-1458-------------------------------
INT 14 U - BWCOM14 - ???
	AH = 58h
	???
Return: CX = status (0001h,0002h)
	???
--------S-147E-------------------------------
INT 14 - FOSSIL - INSTALL AN EXTERNAL APPLICATION FUNCTION
	AH = 7Eh
	AL = code assigned to external application (80h-BFh)
	    80h reserved for communications FOSSIL
	    81h video FOSSIL
	    82h reserved for keyboard FOSSIL
	    83h reserved for system FOSSIL
	ES:DX -> entry point
Return: AX = 1954h
	BL = code assigned to application (same as input AL)
	DH = 00h failed
	     01h successful
SeeAlso: AH=7Fh,AH=80h"FOSSIL",AX=8100h,AH=82h"FOSSIL",AH=83h"FOSSIL"
--------S-147F-------------------------------
INT 14 - FOSSIL - REMOVE AN EXTERNAL APPLICATION FUNCTION
	AH = 7Fh
	AL = code assigned to external application
	ES:DX -> entry point
Return: AX = 1954h
	BL = code assigned to application (same as input AL)
	DH = 00h failed
	     01h successful
SeeAlso: AH=7Eh
--------S-1480-------------------------------
INT 14 - COMMUNICATIONS FOSSIL
	AH = 80h
SeeAlso: AH=7Eh
--------S-1480-------------------------------
INT 14 - COURIERS.COM - INSTALLATION CHECK
	AH = 80h
Return: AH = E8h if loaded
Program: COURIERS is a TSR utility by PC Magazine
--------S-148000-----------------------------
INT 14 - ARTICOM - INSTALLATION CHECK
	AX = 8000h
Return: AL = FFh if installed
	    BH = major version
	    BL = minor version
Program: ArtiCom is an asynchronous communications driver by Artisoft which
	  works on top of NetBIOS and allows modem/serial-port sharing by
	  programs using INT 14 for serial I/O.
Note:	ArtiCom supports 32 simultaneous COM ports using multiport cars and
	  drivers
SeeAlso: AH=00h,AH=01h,AH=02h,AH=03h,AH=04h,AH=05h,AX=8001h,AX=8002h
--------S-148001-----------------------------
INT 14 - ARTICOM - UNLOAD ASYNCHRONOUS REDIRECTOR FROM MEMORY
	AX = 8001h
Return: AX = error code, if error (see AX=8003h)
SeeAlso: AX=8000h,AX=8002h,AX=8003h
Index:	uninstall;ARTICOM
--------S-148002-----------------------------
INT 14 - ARTICOM - GET ASYNCHRONOUS REDIRECTOR STATUS
	AX = 8002h
	ES:DI -> buffer for redirector status structure (see below)
Return: AX = error code, if error (see AX=8003h)
SeeAlso: AX=8000h,AX=8003h

Format of redirector status:
Offset	Size	Description
 00h	WORD	redirector major and minor version numbers
 02h	WORD	redirectable ports found
 04h	WORD	redirectable ports + local ports found
 06h	WORD	redirector internal buffer size
 08h	WORD	maximum servers maintained
 0Ah	WORD	number of adapters found
--------S-148003-----------------------------
INT 14 - ARTICOM - TRANSLATE ERROR CODE TO ERROR STRING
	AX = 8003h
	CX = error number to translate
Return: ES:DI -> ASCIZ error text or NULL if can't translate.
SeeAlso: AX=8000h

Values for error codes:
 00h	"No error"
 01h	"An invalid port number was specified"
 02h	"Port is already redirected"
 03h	"Too many ports redirected"
 04h	"Cannot locate the server"
 05h	"Server is busy"
 06h	"Access denied"
 07h	"Resource in use"
 08h	"Resource in use - request queued"
 09h	"No such resource"
 0Ah	"Invalid username/password pair"
 0Bh	"Noncompatible version number"
 0Ch	"Can't remove from memory"
 0Dh	"Bad NETBIOS adapter number"
 0Eh	"No more entries in list"
 0Fh	"Resource is not available at this time"
 10h	"Invalid value to INT 14 call"
--------S-148004-----------------------------
INT 14 - ARTICOM - ATTACH ASYNCHRONOUS RESOURCE
	AX = 8004h
	DX = port to redirect (COM1=0, COM2=1, ...)
	CH = attach type
	CL = adapter to use for attach, 0FFh to search all
	ES:DI -> attachment structure (see below)
Return: AX = error code, if error (see AX=8003h)
Note:	The wildcard '*' is supported in the server and resource fields.  If
	  wild cards are used then the first matching available server is
	  attached.
SeeAlso: AX=8000h,AX=8003h,AX=8005h

Format of attachment structure:
Offset	Size	Description
 00h 16 BYTEs	server to look for attach
 10h 16 BYTEs	attach to resource name
 20h 16 BYTEs	username for attach
 30h 16 BYTEs	password for username or resource
 40h	BYTE	attach type
		00h normal
		01h queue if resource is in use (not yet supported in v1.00)
--------S-148005-----------------------------
INT 14 - ARTICOM - DETACH ASYNCHRONOUS RESOURCE
	AX = 8005h
	DX = port to detach (COM1=0, COM2=1, ...)
Return: AX = error code, if error (see AX=8003h)
Note:	only a previously attached resource can be detached
SeeAlso: AX=8000h,AX=8003h,AX=8004h
--------S-148006-----------------------------
INT 14 - ARTICOM - GET RESOURCE INFORMATION
	AX = 8006h
	BX = remote port (COM1=0, COM2=1, ...)
	CL = adapter number, FFH to try all adapters
	ES:DI -> resource information structure (see below)
	DS:SI -> 16 byte server name. See note.
Return: AX = error code, if error (see AX=8003h)
	BX = next remote port, recall to get next resource info
Note:	Wild cards supported in both the resource field and server name
	string DS:SI. If wild cards used then first matching available
	resource information is searched. Set resource field to 0FFh to
	return all resources.
SeeAlso: AX=8000h,AX=8002h,AX=8003h,AX=8007h

Format of resource information structure:
Offset	Size	Description
 00h	BYTE	00h = free, else used
 01h 16 BYTEs	resource name
 11h 16 BYTEs	username of resource user
 21h	WORD	amount of time used
 23h	WORD	amount of time remaining
 53h 48 BYTEs	description of resource
 93h 64 BYTEs	initialization string for modem
 B3h 32 BYTEs	dial string for modem
 D3h 32 BYTEs	hang-up string for modem
--------S-148007-----------------------------
INT 14 - ARTICOM - GET REDIRECTED PORT INFORMATION
	AX = 8007h
	DX = port index (COM1=0, COM2=1, ...)
	ES:DI -> buffer for port information structure (see below)
Return: CF clear if redirection info returned and port is redirected
	CF set if not a redirected port
	AX = error code, if error (see AX=8003h)
SeeAlso: AX=8000h,AX=8003h,AX=8006h,AX=8008h

Format of port information structure:
Offset	Size	Description
 00h 16 BYTEs	server name resource is on
 10h	BYTE	adapter number server is on
 11h 16 BYTEs	resource name
 21h	WORD	remote port index, use to get additional information
 23h	WORD	buffer size
 25h	WORD	baud rate (see below)
 26h	BYTE	modem status register
 27h	BYTE	modem control register
 28h	BYTE	line status register
 29h	BYTE	line control register
 2Ah	BYTE	flow control in use: 0 - NONE, 1 - XON/XOFF, 2 - RTS/CTS
 2Bh	WORD	send timeout in ticks
 2Dh	WORD	receive timeout in ticks
 2Fh	WORD	time used on remote port
 31h	WORD	time left before timeout
 33h	BYTE	if server changes allowed?
 34h	WORD	FFFFh (-1) if connection ok, else old port index

Values for baud rate:
 00h	110
 01h	150
 02h	300
 03h	600
 04h	1200
 05h	2400
 06h	4800
 07h	9600
 08h	19200
 09h	38400
 0Ah	57600
 0Bh	115200
 0Ch	134.5
 0Dh	1800
 0Eh	2000
 0Fh	3600
 10h	7200
--------S-148008-----------------------------
INT 14 - ARTICOM - GET AVAILABLE SERVER NAME
	AX = 8008h
	BX = server index (0,1,...)
	ES:DI -> server name structure (see below)
Return: AX = error code, if error (see AX=8003h)
	BX = next remote port, repeat call to get next available server
Note:	the wildcard '*' is supported in the server name field.	 Set the
	  server name to FFh to search for all servers.
SeeAlso: AX=8000h,AX=8003h,AX=8007h

Format of server name structure:
Offset	 Size	  Description
  00h 16 BYTEs	  (call) ASCIZ servername
  10h	 BYTE	  (return) the adapter server is found
--------S-148009-----------------------------
INT 14 - ARTICOM - SET SEND AND RECEIVE TIMEOUTS
	AX = 8009h
	BX = send timeout in ticks
	CX = receive timeout in ticks
	DX = port index (COM1=0, COM2=1, ...)
Return: nothing
SeeAlso: AX=8000h,AX=800Ah
--------S-14800A-----------------------------
INT 14 - ARTICOM - MODIFY FLOW CONTROL
	AX = 800Ah
	BL = flow control type (00h none, 01h XON/XOFF, 02h RTS/CTS)
	DX = port index (COM1=0, COM2=1, ...)
Return: AX = error code, if error (see AX=8003h)
Note:	for attached ports only!
SeeAlso: AX=8000h,AX=8003h,AX=8009h
--------S-148025-----------------------------
INT 14 - ARTICOM - SET INTERNAL SEND/RECEIVE VECTOR
	AX = 8025h
	DS:DX -> address of trap function (see below) to call on read/write
Note:	setting the vector to a user function allows the redirector's activity
	  to be monitored.
SeeAlso: AX=8000h,AX=8035h,INT 21/AH=25h

Trap function called with:
	AH = operation
	    80h reading character
	    81h writing character
	AL = character
	Return: AX must be preserved
		far JUMP to old trap function (see AX=8035h)
--------S-148035-----------------------------
INT 14 - ARTICOM - GET INTERNAL SEND/RECEIVE VECTOR
	AX = 8035h
Return: ES:BX -> address of current send/receive routine
Note:	this function returns the address of the routine which is called
	  inside A-REDIR.EXE each time a character is received or sent on the
	  active COM port.
SeeAlso: AX=8000h,AX=8025h,INT 21/AH=35h
--------S-1481-------------------------------
INT 14 - COURIERS.COM - CHECK IF PORT BUSY
	AH = 81h
	AL = port number (1-4)
Return: AH = 00h port available
	     01h port exists but already in use
	     02h port nonexistent
Program: COURIERS is a TSR utility by PC Magazine
SeeAlso: AH=83h,AH=8Dh
--------S-1481-------------------------------
INT 14 - Egberto Willies COMM-DRV - EXTENDED INITIALIZATION
	AH = 81h
	BX:DI -> port control block
Return: ???
SeeAlso: AH=00h

Format of port control block:
Offset	Type	Description
 00h	WORD	port IO address
 02h	WORD	port IRQ
 04h	WORD	baud rate
 06h	WORD	parity
 08h	WORD	data bits
 0Ah	WORD	stop bits
 0Ch	WORD	break status
		0000h off
 0Eh	WORD	flow control protocol
 10h	BYTE	input block
 11h	BYTE	output block
 12h	WORD	low threshold
 14h	WORD	high threshold
 16h	WORD	segment of buffer
 18h	WORD	offset of buffer
 1Ah	WORD	input buffer length
 1Ch	WORD	output buffer length
 1Eh	BYTE	auxiliary address
 1Fh	BYTE	spare
 20h  4 WORDs	spares
--------V-148100-----------------------------
INT 14 - VIDEO FOSSIL - RETURN VFOSSIL INFORMATION
	AX = 8100h
	ES:DI -> buffer for VFOSSIL information (see below)
Return: AX = 1954h if installed
SeeAlso: AH=7Eh,AX=8101h

Format of VFOSSIL information:
Offset	Size	Description
 00h	WORD	size of information in bytes, including this field
 02h	WORD	VFOSSIL major version
 04h	WORD	VFOSSIL revision level
 06h	WORD	highest VFOSSIL application function supported
--------V-148101-----------------------------
INT 14 - VIDEO FOSSIL - OPEN VFOSSIL
	AX = 8101h
	ES:DI -> buffer for application function table (see below)
	CX = length of buffer in bytes
Return: AX = 1954h if installed
	    BH = highest VFOSSIL application function supported
Note:	the number of initialized pointers in the application function table
	  will never exceed CX/4; if the buffer is large enough, BH+1 pointers
	  will be initialized
SeeAlso: AX=8102h

Format of application function table:
Offset	Size	Description
 00h	DWORD	-> function to query current video mode (VioGetMode)
 04h	DWORD	-> function to set video mode (VioSetMode)
 08h	DWORD	-> function to query hardware config (VioGetConfig)
 0Ch	DWORD	-> function to write data in TTY mode (VioWrtTTY)
 10h	DWORD	-> function to get current ANSI state (VioGetANSI)
 14h	DWORD	-> function to set new ANSI state (VioSetANSI)
 18h	DWORD	-> function to get curr cursor position (VioGetCurPos)
 1Ch	DWORD	-> function to set cursor position (VioSetCurPos)
 20h	DWORD	-> function to get cursor shape (VioGetCurType)
 24h	DWORD	-> function to set cursor shape (VioSetCurType)
 28h	DWORD	-> function to scroll screen up (VioScrollUp)
 2Ch	DWORD	-> function to scroll screen down (VioScrollDn)
 30h	DWORD	-> function to read cell string from screen (VioReadCellStr)
 34h	DWORD	-> function to read char string from screen (VioReadCharStr)
 38h	DWORD	-> function to write a cell string (VioWrtCellStr)
 3Ch	DWORD	-> function to write char string, leaving attr (VioWrtCharStr)
 40h	DWORD	-> function to write char string,const attr (VioWrtCharStrAttr)
 44h	DWORD	-> function to replicate an attribute (VioWrtNAttr)
 48h	DWORD	-> function to replicate a cell (VioWrtNCell)
 4Ch	DWORD	-> function to replicate a character (VioWrtNChar)

Format of video mode data structure:
Offset	Size	Description
 00h	WORD	length of structure including this field
 02h	BYTE	mode characteristics
		bit 0: clear if MDA, set otherwise
		bit 1: graphics mode
		bit 2: color disabled (black-and-white)
 03h	BYTE	number of colors supported (1=2 colors, 4=16 colors, etc)
 04h	WORD	number of text columns
 06h	WORD	number of text rows
 08h	WORD	reserved
 0Ah	WORD	reserved
 0Ch	DWORD	reserved

Format of video configuration data:
Offset	Size	Description
 00h	WORD	structure length including this field
 02h	WORD	adapter type
		00h monochrome/printer
		01h CGA
		02h EGA
		03h VGA
		07h 8514/A
 04h	WORD	display type
		00h monochrome
		01h color
		02h enhanced color
		09h 8514
 06h	DWORD	adapter memory size

Format of cursor type record:
Offset	Size	Description
 00h	WORD	cursor start line
 02h	WORD	cursor end line
 04h	WORD	cursor width (always 01h)
 06h	WORD	cursor attribute (FFFFh = hidden)

Call VioGetMode with:
	STACK:	WORD	VIO handle (must be 00h)
		DWORD	pointer to video mode data structure (see above)
Return: AX = error code (00h, 74h, 17Eh, 1B4h) (see below)

Values for error code:
 0000h	successful
 0074h	internal VIO failure
 0163h	unsupported mode
 0166h	invalid row value
 0167h	invalid column value
 017Eh	buffer too small
 01A5h	invalid VIO parameter
 01B4h	invalid VIO handle

Call VioSetMode with:
	STACK:	WORD	VIO handle (must be 00h)
		DWORD	pointer to video mode data structure (see above)
Return: AX = error code (00h, 74h, 163h, 17Eh, 1A5h, 1B4h) (see above)

Call VioGetConfig with:
	STACK:	WORD	VIO handle (must be 00h)
		DWORD	pointer to video configuration data buffer (see above)
Return: AX = error code (00h, 74h, 17Eh, 1B4h) (see above)

Call VioWrtTTY with:
	STACK:	WORD	VIO handle (must be 00h)
		WORD	length of string
		DWORD	pointer to character string to be written to screen
Return: AX = error code (00h, 74h, 1B4h) (see above)
Notes:	write wraps at end of line and terminates if it reaches end of screen
	in ANSI mode, ANSI control sequences are interpreted, and this func is
	  not required to be reentrant; in non-ANSI mode, the function is
	  reentrant and may be called from within an MS-DOS function call

Call VioGetANSI with:
	STACK:	WORD	VIO handle (must be 00h)
		DWORD	pointer to WORD which will be set to 00h if ANSI is off
			or 01h if ANSI is on
Return: AX = error code (00h, 74h, 1B4h) (see above)

Call VioSetANSI with:
	STACK:	WORD	VIO handle (must be 00h)
		DWORD	pointer to WORD indicating new state of ANSI
			00h off
			01h on
Return: AX = error code (00h, 74h, 1A4h, 1B4h) (see above)

Call VioGetCurPos with:
	STACK:	WORD	VIO handle (must be 00h)
		DWORD	pointer to WORD to hold current cursor column (0-based)
		DWORD	pointer to WORD to hold current cursor row (0-based)
Return: AX = error code (00h, 74h, 1B4h) (see above)

Call VioSetCurPos with:
	STACK:	WORD	VIO handle (must be 00h)
		WORD	cursor column
		WORD	cursor row
Return: AX = error code (00h, 74h, 166h, 167h, 1B4h) (see above)
Note:	if either coordinate is invalid, the cursor is not moved

Call VioGetCurType with:
	STACK:	WORD	VIO handle (must be 00h)
		DWORD	pointer to cursor type record (see above)
Return: AX = error code (00h, 74h, 1B4h) (see above)

Call VioSetCurType with:
	STACK:	WORD	VIO handle (must be 00h)
		DWORD	pointer to cursor type record (see above)
Return: AX = error code (00h, 74h, 1A4h, 1B4h) (see above)

Call VioScrollUp with:
	STACK:	WORD	VIO handle (must be 00h)
		DWORD	pointer to char/attr cell for filling emptied rows
		WORD	number or rows to scroll (FFFFh = clear area)
		WORD	right column of scroll area
		WORD	bottom row of scroll area
		WORD	left column of scroll area
		WORD	top row of scroll area
Return: AX = error code (00h, 74h, 166h, 167h, 1B4h) (see above)

Call VioScrollDn with:
	STACK:	WORD	VIO handle (must be 00h)
		DWORD	pointer to char/attr cell for filling emptied rows
		WORD	number or rows to scroll (FFFFh = clear area)
		WORD	right column of scroll area
		WORD	bottom row of scroll area
		WORD	left column of scroll area
		WORD	top row of scroll area
Return: AX = error code (00h, 74h, 166h, 167h, 1B4h) (see above)

Call VioReadCellStr with:
	STACK:	WORD	VIO handle (must be 00h)
		WORD	column at which to start reading
		WORD	row at which to start reading
		DWORD	pointer to WORD containing length of buffer in bytes
			on return, WORD contains number of bytes actually read
		DWORD	pointer to buffer for cell string
Return: AX = error code (00h, 74h, 166h ,167h, 1B4h) (see above)

Call VioReadCharStr with:
	STACK:	WORD	VIO handle (must be 00h)
		WORD	column at which to start reading
		WORD	row at which to start reading
		DWORD	pointer to WORD containing length of buffer in bytes
			on return, WORD contains number of bytes actually read
		DWORD	pointer to buffer for character string
Return: AX = error code (00h, 74h, 166h ,167h, 1B4h) (see above)

Call VioWrtCellStr with:
	STACK:	WORD	VIO handle (must be 00h)
		WORD	column at which to start writing
		WORD	row at which to start writing
		WORD	length of cell string in bytes
		DWORD	pointer to cell string to write
Return: AX = error code (00h, 74h, 166h, 167h, 1B4h) (see above)
Note:	write wraps at end of line and terminates if it reaches end of screen

Call VioWrtCharStr with:
	STACK:	WORD	VIO handle (must be 00h)
		WORD	column at which to start writing
		WORD	row at which to start writing
		WORD	length of character string
		DWORD	pointer to character string to write
Return: AX = error code (00h, 74h, 166h, 167h, 1B4h) (see above)
Note:	write wraps at end of line and terminates if it reaches end of screen

Call VioWrtCharStrAttr with:
	STACK:	WORD	VIO handle (must be 00h)
		DWORD	pointer to attribute to be applied to each character
		WORD	column at which to start writing
		WORD	row at which to start writing
		WORD	length of character string
		DWORD	pointer to character string to write
Return: AX = error code (00h, 74h, 166h, 167h, 1B4h) (see above)
Note:	write wraps at end of line and terminates if it reaches end of screen

Call VioWrtNAttr with:
	STACK:	WORD	VIO handle (must be 00h)
		WORD	column at which to start writing
		WORD	row at which to start writing
		WORD	number of times to write attribute
		DWORD	pointer to display attribute to replicate
Return: AX = error code (00h, 74h, 166h, 167h, 1B4h) (see above)
Note:	write wraps at end of line and terminates if it reaches end of screen

Call VioWrtNCell with:
	STACK:	WORD	VIO handle (must be 00h)
		WORD	column at which to start writing
		WORD	row at which to start writing
		WORD	number of times to write cell
		DWORD	pointer to cell to replicate
Return: AX = error code (00h, 74h, 166h, 167h, 1B4h) (see above)
Note:	write wraps at end of line and terminates if it reaches end of screen

Call VioWrtNChar with:
	STACK:	WORD	VIO handle (must be 00h)
		WORD	column at which to start writing
		WORD	row at which to start writing
		WORD	number of times to write character
		DWORD	pointer to character to replicate
Return: AX = error code (00h, 74h, 166h, 167h, 1B4h) (see above)
Note:	write wraps at end of line and terminates if it reaches end of screen
--------V-148102-----------------------------
INT 14 - VIDEO FOSSIL - CLOSE VFOSSIL
	AX = 8102h
Return: AX = 1954h
Note:	terminates all operations; after this call, the video FOSSIL may either
	  be removed from memory or reinitialized
SeeAlso: AX=8101h,AX=8103h
--------V-148103-----------------------------
INT 14 - VIDEO FOSSIL - UNINSTALL
	AX = 8103h
Return: AX = 1954h
Note:	this is an extension to the VFOSSIL spec by Bob Hartman's VFOS_IBM
--------K-1482-------------------------------
INT 14 - KEYBOARD FOSSIL
	AH = 82h
SeeAlso: AH=7Eh
--------S-1482-------------------------------
INT 14 - COURIERS.COM - CONFIGURE PORT
	AH = 82h
	AL = port number (1-4)
	BX = speed (bps)
	CX = bit flags
	    bit 0: enable input flow control
	    bit 1: enable output flow control
	    bit 2: use X.PC protocol (not yet implemented)
SeeAlso: AH=00h,AH=8Ch,INT 7A"X.PC"
----------1483-------------------------------
INT 14 - SYSTEM FOSSIL
	AH = 83h
SeeAlso: AH=7Eh
--------S-1483-------------------------------
INT 14 - COURIERS.COM - START INPUT
	AH = 83h
	ES:BX -> circular input buffer
	CX = length of buffer
		(should be at least 128 bytes if input flow control enabled)
SeeAlso: AH=18h,AH=87h,AH=8Dh,AH=A5h"BAPI"
--------S-1484-------------------------------
INT 14 - COURIERS.COM - READ CHARACTER
	AH = 84h
Return: ZF set if no characters available
	ZF clear
	   AL = character
	   AH = modem status bits
		bit 7: set on input buffer overflow
SeeAlso: AH=02h,AH=86h,AH=89h
--------S-1485-------------------------------
INT 14 - COURIERS.COM - FLUSH PENDING INPUT
	AH = 85h
SeeAlso: AH=0Ah,AH=88h
--------S-1486-------------------------------
INT 14 - COURIERS.COM - START OUTPUT
	AH = 86h
	ES:BX -> output buffer
	CX = length of output buffer
SeeAlso: AH=19h,AH=83h"COURIERS",AH=A4h"BAPI"
--------S-1487-------------------------------
INT 14 - COURIERS.COM - OUTPUT STATUS
	AH = 87h
Return: AX = number of unsent characters
--------S-1488-------------------------------
INT 14 - COURIERS.COM - ABORT OUTPUT
	AH = 88h
SeeAlso: AH=09h,AH=85h
--------S-1489-------------------------------
INT 14 - COURIERS.COM - SEND SINGLE CHARACTER
	AH = 89h
	CL = character to send
SeeAlso: AH=01h,AH=84h
--------S-148A-------------------------------
INT 14 - COURIERS.COM - SEND BREAK
	AH = 8Ah
SeeAlso: AH=89h,AH=FAh
--------S-148C-------------------------------
INT 14 - COURIERS.COM - SET SPEED
	AH = 8Ch
	BX = speed in bps
SeeAlso: AH=00h,AH=82h"COURIERS"
--------S-148D-------------------------------
INT 14 - COURIERS.COM - DECONFIGURE PORT
	AH = 8Dh
SeeAlso: AH=82h"COURIERS"
--------S-14A0-------------------------------
INT 14 - 3com BAPI SERIAL I/O - CONNECT TO PORT
	AH = A0h
	ES:BX -> ASCIZ internet host name
	CX = length of name
Return: AH = return code (00h,04h-06h,08h,0Ah-0Ch) (see below)
	CL = session ID
Program: the Bridge Application Program Interface is a set of functions which
	  makes many of the details of LAN communications transparent
SeeAlso: AH=A1h"BAPI",AH=A2h"BAPI",AH=A5h"BAPI",AX=AF00h

Values for return code:
 00h	successful
 01h	no characters written
 02h	no characters read
 03h	no such session
 04h	clearinghouse name not found
 05h	no response from host
 06h	no more sessions available
 07h	session aborted
 08h	invalid clearinghouse name
 09h	not supported
 0Ah	internal (general) network error
 0Bh	out of memory
 0Ch	invalid IP address
--------S-14A0--CXFFFF-----------------------
INT 14 - Interconnections Inc. TES - INSTALLATION CHECK/STATUS REPORT
	AH = A0h
	CX = FFFFh
Return: CF clear if successful
	    AX = 5445h ('TE')
	    CX <> FFFFh
	    DX = port number
	CF set on error
Program: TES is a network serial port emulation program
SeeAlso: AH=A1h"TES"
--------S-14A1-------------------------------
INT 14 - 3com BAPI SERIAL I/O - DISCONNECT FROM PORT
	AH = A1h
	DH = session ID (00h for external session managment)
Return: AH = return code (00h,03h,07h,0Ah,0Bh) (see AH=A0h"BAPI")
SeeAlso: AH=A0h"BAPI"
--------S-14A1-------------------------------
INT 14 - Interconnections Inc. TES - GET LIST OF SESSIONS WITH STATUS
	AH = A1h
Return: CX = number of active sessions
	ES:SI -> status array (see below)
SeeAlso: AH=A2h"TES",AH=A3h"TES"

Format of status array entry:
Offset	Size	Description
 00h	BYTE	status
 01h	WORD	offset of name
--------S-14A2-------------------------------
INT 14 - 3com BAPI SERIAL I/O - WRITE CHARACTER
	AH = A2h
	AL = character
	DH = session ID (00h for external session managment)
Return: AH = return code (00h,01h,03h,07h,0Ah,0Bh) (see AH=A0h"BAPI")
SeeAlso: AH=A0h"BAPI",AH=A3h"BAPI",AH=A4h"BAPI"
--------S-14A2-------------------------------
INT 14 - Interconnections Inc. TES - GET LIST OF SERVER NAMES
	AH = A2h
Return: CX = number of servers
	ES:SI -> array of offsets from ES for server names
SeeAlso: AH=A1h"TES"
--------S-14A3-------------------------------
INT 14 - 3com BAPI SERIAL I/O - READ CHARACTER
	AH = A3h
	DH = session ID (00h for external session managment)
Return: AH = return code (00h,02h,03h,07h,0Ah,0Bh) (see AH=A0h"BAPI")
	AL = character read or 00h if none available
SeeAlso: AH=A0h"BAPI",AH=A2h"BAPI",AH=A5h"BAPI",AH=A7h"BAPI"
--------S-14A3-------------------------------
INT 14 - Interconnections Inc. TES - START A NEW SESSION
	AH = A3h
	ES:SI -> ???
Return: CF clear if successful
	    AX = 5445h ('TE')
	    CX <> FFFFh
	    DX = port number
	CF set on error
SeeAlso: AH=A1h"TES",AH=A4h"TES",AH=A6h"TES"
--------S-14A4-------------------------------
INT 14 - 3com BAPI SERIAL I/O - WRITE BLOCK
	AH = A4h
	CX = length length of buffer
	DH = session ID (00h for external session managment)
	ES:BX -> buffer containing data
Return: AH = return code (00h,01h,03h,07h,0Ah,0Bh) (see AH=A0h"BAPI")
	CX = number of bytes actually sent
SeeAlso: AH=19h,AH=86h,AH=A0"BAPI",AH=A5h"BAPI"
--------S-14A4-------------------------------
INT 14 - Interconnections Inc. TES - HOLD CURRENTLY ACTIVE SESSION
	AH = A4h
	???
Return: ???
SeeAlso: AH=A3h"TES",AH=A5h"TES"
--------S-14A5-------------------------------
INT 14 - 3com BAPI SERIAL I/O - READ BLOCK
	AH = A5h
	CX = length of buffer
	DH = session ID (00h for external session managment)
	ES:BX -> buffer for data
Return: AH = return code (00h,02h,03h,07h,0Ah,0Bh) (see AH=A0h"BAPI")
	CX = number of bytes actually read
SeeAlso: AH=18h,AH=83h"COURIERS",AH=A0h"BAPI",AH=A3h"BAPI",AH=A4h"BAPI"
SeeAlso: AH=A7h"BAPI",AX=FF02h
--------S-14A5-------------------------------
INT 14 - Interconnections Inc. TES - RESUME A SESSION
	AH = A5h
	AL = session number
Return: ???
SeeAlso: AH=A4h"TES",AH=A6h"TES"
--------S-14A6-------------------------------
INT 14 - 3com BAPI SERIAL I/O - SEND SHORT BREAK
	AH = A6h
	DH = session ID (00h for external session managment)
Return: AH = return code (00h,03h,07h,0Ah,0Bh) (see AH=A0h"BAPI")
Desc:	generate a short break signal; if data delivery was turned off by the
	  break, wait for the host to turn it on again
SeeAlso: AH=1Ah,AH=8Ah,AH=FAh,AH=A0h"BAPI"
--------S-14A6-------------------------------
INT 14 - Interconnections Inc. TES - DROP A SESSION
	AH = A6h
	AL = session number
Return: AH = status
	    00h successful
	    else error
SeeAlso: AH=A3h"TES",AH=A5h"TES"
--------S-14A7-------------------------------
INT 14 - 3com BAPI SERIAL I/O - READ STATUS
	AH = A7h
	DH = session ID (00h for external session managment)
Return: AH = return code (00h,03h,07h,0Ah,0Bh) (see AH=A0h"BAPI")
	CX = number of bytes available for reading
SeeAlso: AH=A5h"BAPI"
--------S-14A7-------------------------------
INT 14 - Interconnections Inc. TES - SWITCH TO NEXT ACTIVE SESSION
	AH = A7h
	???
Return: ???
SeeAlso: AH=A3h"TES",AH=A5h"TES"
--------S-14A8-------------------------------
INT 14 - Interconnections Inc. TES - SEND STRING TO COMMAND INTERPRETER
	AH = A8h
	AL = 00h no visible response
	ES:SI -> ASCIZ command
Return: ???
--------S-14AF00BXAAAA-----------------------
INT 14 - 3com BAPI SERIAL I/O - INSTALLATION CHECK
	AX = AF00h
	BX = AAAAh
Return: AX = AF01h if installed
	    BH = protocol type (if BX=AAAAh on entry)
		01h NetManage TCP/IP
	    BL = version for protocol type (if BX=AAAAh on entry)
Note:	early versions of the BAPI and the ROM BIOS simply destroy AX; this
	  behavior is used to determine whether the newer functions (AH=B0h,
	  AH=B1h,etc) are available
SeeAlso: AH=A0h"BAPI"
--------S-14B0-------------------------------
INT 14 - 3com BAPI SERIAL I/O - EN/DISABLE "ENTER COMMAND MODE" (ECM) CHARACTER
	AH = B0h
	AL = new state (00h disabled, 01h enabled)
Return: AH = return code (00h,07h,0Ah) (see AH=A0h"BAPI")
Note:	disabling the ECM character allows applications to send data which
	  includes the ECM character
SeeAlso: AX=AF00h"BAPI",AH=B1h,AH=B2h
--------S-14B1-------------------------------
INT 14 - 3com BAPI SERIAL I/O - ENTER COMMAND MODE
	AH = B1h
Return: AH = return code (00h,07h,0Ah) (see AH=A0h"BAPI")
Desc:	provide a means for the application or terminal emulator to perform
	  the same action normally caused by the ECM character
SeeAlso: AH=B0h,AH=B2h
--------S-14B2-------------------------------
INT 14 - 3com BAPI SERIAL I/O - GET ECM WATCH STATE
	AH = B2h
Return: AH = return code (00h,07h,0Ah) (see AH=A0h"BAPI")
	AL = watch flag (00h disabled, 01h enabled)
Desc:	determine whether the ECM character is enabled
SeeAlso: AH=B0h,AH=B1h
--------S-14B3-------------------------------
INT 14 - 3com BAPI SERIAL I/O - GET/SET CONFIGURATION INFO
	AH = B3h
	AL = direction (00h get, 01h set)
	DH = session ID (00h for external session managment)
	DL = configuration item (00h = end-of-line mapping)
	CX = new configuration item value (if AL=01h)
	    ---if DL=00h---
	    CH = application EOL type (app to Telnet client)
		01h application will send lone CR
		02h application will send CR-? pair
	    CL = driver EOL type (Telnet client to Telnet server)
		01h driver should send CR-NUL pair
		02h driver should send CR-LF pair
Return: AH = return code (00h,03h,09h-0Bh) (see AH=A0h"BAPI")
	---if AL=00h---
	CX = configuration item value (see above)
SeeAlso: AH=B2h
--------N-14E0-------------------------------
INT 14 - TelAPI - ???
	AH = E0h
	???
Return: ???
SeeAlso: AX=FF00h
--------S-14E000-----------------------------
INT 14 - MX5 Extended FOSSIL - GET MNP STATUS BLOCK
	AX = E000h
	DX = port number (0-3)
Return: ES:BX -> status block (see below)
Program: MX5 is a FOSSIL driver by MagicSoft which emulates MNP Level 5, and
	  ships with the MTEZ terminal program as MTEMNP.DRV (a TSR despite
	  the .DRV extension)
SeeAlso: AX=E006h

Format of status block:
Offset	Size	Description
 00h	BYTE	flag: active (00h no, 01h yes)
 01h	BYTE	MNP level (2,4,5)
 02h	BYTE	series ID from remote MNP
 03h	DWORD	total packets transmitted
 07h	DWORD	duplicate packets transmitted
 0Bh	DWORD	maximum speed
 0Fh	DWORD	total packets received
 13h	DWORD	duplicate packets received
 17h	DWORD	maximum speed
--------S-14E001-----------------------------
INT 14 - MX5 Extended FOSSIL - GET/SET MNP LEVEL
	AX = E001h
	BH = function
	    00h get MNP level
	    01h set MNP level
		BL = new level (00h none, 02h/04h/05h MNP level N)
	DX = port number (0-3)
Return: BL = MNP level
SeeAlso: AX=E002h,AX=E003h,AX=E004h,AX=E006h
--------S-14E002-----------------------------
INT 14 - MX5 Extended FOSSIL - GET/SET MNP ANSWER/ORIGINATE MODE
	AX = E002h
	BH = function
	    00h get answer/originate mode
	    01h set mode
		BL = new mode (00h originate [default], 01h answer)
	DX = port number (0-3)
Return: BL = answer/originate mode
SeeAlso: AX=E001h,AX=E003h,AX=E006h
--------S-14E003-----------------------------
INT 14 - MX5 Extended FOSSIL - GET/SET MNP WAIT TICKS
	AX = E003h
	BH = function
	    00h get wait ticks
	    01h set wait ticks
		BL = MNP wait ticks (default 0Eh)
	DX = port number (0-3)
Return: BL = wait ticks
SeeAlso: AX=E001h,AX=E002h,AX=E006h
--------S-14E004-----------------------------
INT 14 - MX5 Extended FOSSIL - GET/SET MNP CONNECT SOUND LEVEL
	AX = E004h
	BH = function
	    00h get sound level
	    01h set sound level
		BL = new sound level (00h off, 01h on [default])
	DX = port number
Return: BL = sound state
Desc:	specify whether MX5 should generate beeps after an MNP connection
	  (three high beeps if successful, high then low on connection failure)
SeeAlso: AX=E002h,AX=E006h
--------S-14E005-----------------------------
INT 14 - MX5 Extended FOSSIL - UNINSTALL
	AX = E005h
Return: BX = segment of MX5's memory block or 0000h on failure
Note:	caller must free the returned memory block to complete the uninstall
SeeAlso: AX=E006h
--------S-14E006BX0000-----------------------
INT 14 - MX5 Extended FOSSIL - INSTALLATION CHECK
	AX = E006h
	BX = 0000h
Return: BX = 4D58h ('MX') if installed
	    AH = major version
	    AL = minor version
SeeAlso: AX=E000h,AX=E001h,AX=E005h,AX=E007h
--------S-14E007-----------------------------
INT 14 - MX5 Extended FOSSIL - WAIT SPECIFIED NUMBER OF TICKS
	AX = E007h
	CX = number of ticks to wait
Return: nothing
SeeAlso: AX=E006h
--------N-14E1-------------------------------
INT 14 - TelAPI - ???
	AH = E1h
	???
Return: ???
SeeAlso: AH=E6h,AX=FF00h
--------N-14E2-------------------------------
INT 14 - TelAPI - ???
	AH = E2h
	???
Return: ???
SeeAlso: AH=E6h,AX=FF00h
--------N-14E3-------------------------------
INT 14 - TelAPI - ???
	AH = E3h
	???
Return: ???
SeeAlso: AH=E6h,AX=FF00h
--------N-14E4-------------------------------
INT 14 - TelAPI - ???
	AH = E4h
	???
Return: ???
SeeAlso: AH=E6h,AX=FF00h
--------N-14E5-------------------------------
INT 14 - TelAPI - ???
	AH = E5h
	???
Return: ???
SeeAlso: AH=E6h,AX=FF00h
--------N-14E6-------------------------------
INT 14 - TelAPI - ???
	AH = E6h
	???
Return: ???
Note:	TelAPI also supports the NASI/NACS and NCSI APIs on INT 6B
SeeAlso: AX=FF00h,INT 6B/AH=00h,INT 6B/AH=10h
--------N-14E7-------------------------------
INT 14 - TelAPI - ???
	AH = E7h
	???
Return: ???
SeeAlso: AX=FF00h
--------N-14E8-------------------------------
INT 14 - TelAPI - ???
	AH = E8h
	???
Return: ???
SeeAlso: AX=FF00h
--------N-14E9-------------------------------
INT 14 - TelAPI - ???
	AH = E9h
	???
Return: ???
SeeAlso: AX=FF00h
--------N-14EA-------------------------------
INT 14 - TelAPI - ???
	AH = EAh
	???
Return: ???
SeeAlso: AX=FF00h
--------N-14EB-------------------------------
INT 14 - TelAPI - ???
	AH = EBh
	???
Return: ???
SeeAlso: AX=FF00h
--------N-14EC-------------------------------
INT 14 - TelAPI - ???
	AH = ECh
	???
Return: ???
Note:	this function is not supported by the Microdyne TelAPI v3.7
SeeAlso: AX=FF00h
--------N-14ED-------------------------------
INT 14 - TelAPI - ???
	AH = EDh
	???
Return: ???
Note:	this function is not supported by the Microdyne TelAPI v3.7
SeeAlso: AX=FF00h
--------a-14F0F0-----------------------------
INT 14 - ASAP v1.0 - ???
	AX = F0F0h
	DX = ???
	???
Return: ???
Program: ASAP (Automatic Screen Access Program) is a shareware screen reader by
	  MicroTalk
SeeAlso: AX=F0F1h
--------a-14F0F1DX0000-----------------------
INT 14 - ASAP v1.0 - INSTALLATION CHECK
	AX = F0F1h
	DX = 0000h
Return: DX = segment of resident code
	   = 0000h if not installed
Program: ASAP (Automatic Screen Access Program) is a shareware screen reader by
	  MicroTalk
SeeAlso: AX=F0F0h,INT 10/AX=3800h
--------S-14F4FF-----------------------------
INT 14 - IBM/Yale EBIOS SERIAL I/O - INSTALLATION CHECK
	AX = F4FFh
	DX = port (00h-03h)
Return: CF clear if present
	    AX = 0000h
	CF set if not present
	    AX <> 0000h
--------S-14F9-------------------------------
INT 14 - IBM/Yale EBIOS SERIAL I/O - REGAIN CONTROL
	AH = F9h
	DX = port (00h-03h)
--------S-14FA-------------------------------
INT 14 - IBM/Yale EBIOS SERIAL I/O - SEND BREAK
	AH = FAh
	DX = port (00h-03h)
SeeAlso: AH=1Ah,AH=8Ah
--------S-14FB-------------------------------
INT 14 - IBM/Yale EBIOS SERIAL I/O - SET OUTGOING MODEM SIGNALS
	AH = FBh
	AL = modem control register (see AH=05h)
	DX = port (00h-03h)
SeeAlso: AH=05h"SERIAL"
--------S-14FC-------------------------------
INT 14 - IBM/Yale EBIOS SERIAL I/O - READ CHARACTER, NO WAIT
	AH = FCh
	DX = port (00h-03h)
Return: AH = RS232 status bits (see AH=00h)
	AL = character
SeeAlso: AH=02h,AH=0Ch,AX=FF02h
--------S-14FD02-----------------------------
INT 14 - IBM/Yale EBIOS SERIAL I/O - READ STATUS
	AX = FD02h
Return: CX = number of characters available
--------N-14FF00-----------------------------
INT 14 - TelAPI - INSTALLATION CHECK
	AX = FF00h
Return: AL = FFh if installed
SeeAlso: AH=E6h
--------S-14FF02-----------------------------
INT 14 - IBM/Yale EBIOS SERIAL I/O - BUFFERED READ
	AX = FF02h
	CX = length
	DX = port (00h-03h)
	ES:BX -> buffer
Return: CX = number of characters read
SeeAlso: AH=18h,AH=83h"COURIERS",AH=A5h"BAPI",AH=FCh
--------!------------------------------------
Interrupt List, part 2 of 10
This compilation is Copyright (c) 1989,1990,1991,1992,1993 Ralf Brown
--------t-15---------------------------------
INT 15 - Microsoft TSR Specification
	No additional information available at this time.
--------B-1500-------------------------------
INT 15 - CASSETTE - TURN ON TAPE DRIVE'S MOTOR (PC and PCjr only)
	AH = 00h
Return: CF set on error
	    AH = 86h no cassette present
	CF clear if successful
SeeAlso: AH=01h"CASSETTE"
--------M-1500-------------------------------
INT 15 - Amstrad PC1512 - GET AND RESET MOUSE COUNTS
	AH = 00h
Return: CX = signed X count
	DX = signed Y count
--------O-1500-------------------------------
INT 15 - VMiX v2+ - INSTALLATION CHECK
	AH = 00h
Return: DX = 0798h if installed
	    AX = version (AH = major, AL = minor)
--------T-1500-------------------------------
INT 15 - MultiDOS Plus - GIVE UP TIME SLICE
	AH = 00h
Note:	if issued by the highest-priority task while MultiDOS is using
	  priority-based rather than round-robin scheduling, control will be
	  returned to the caller immediately
SeeAlso: AH=03h"MultiDOS",AX=1000h
--------B-1501-------------------------------
INT 15 - CASSETTE - TURN OFF TAPE DRIVE'S MOTOR (PC and PCjr only)
	AH = 01h
Return: CF set on error
	    AH = 86h no cassette present
	CF clear if successful
SeeAlso: AH=00h"CASSETTE"
--------b-1501-------------------------------
INT 15 - Amstrad PC1512 - WRITE DATA TO NON-VOLATILE RAM
	AH = 01h
	AL = NVRAM location (00h to 3Fh)
	BL = NVRAM data value
Return: AH = return code
	    00h OK
	    01h address bad
	    02h write error
SeeAlso: AH=02h"Amstrad"

Format of NVRAM:
Offset	Size	Description
 00h	BYTE	time of day: seconds
 01h	BYTE	alarm time: seconds
 02h	BYTE	time of day: minutes
 03h	BYTE	alarm time: minutes
 04h	BYTE	time of day: hours
 05h	BYTE	alarm time: hours
 06h	BYTE	day of week, 1 = Sunday
 07h	BYTE	day of month
 08h	BYTE	month
 09h	BYTE	year mod 100
 0Ah	BYTE	RTC status register A
		bit 7: set if date/time being updated
		bits 6-4: time base speed, default 010 = 32768 Hz
		bits 3-0: interrupt rate selection, default 0110 = 1024 Hz
 0Bh	BYTE	RTC status register B (see below)
 0Ch	BYTE	RTC status register C (read-only)
		bit 7: IRQF flag
		bit 6: PF flag
		bit 5: AF flag
		bit 4: UF flag
 0Dh	BYTE	RTC status register D
		bit 7: battery good
 0Eh  6 BYTEs	time and date machine last used
 14h	BYTE	user RAM checksum
 15h	WORD	Enter key scancode/ASCII code
 17h	WORD	Forward delete key scancode/ASCII code
 19h	WORD	Joystick fire button 1 scancode/ASCII code
 1Bh	WORD	Joystick fire button 2 scancode/ASCII code
 1Dh	WORD	mouse button 1 scancode/ASCII code
 1Fh	WORD	mouse button 2 scancode/ASCII code
 21h	BYTE	mouse X scaling factor
 22h	BYTE	mouse Y scaling factor
 23h	BYTE	initial VDU mode and drive count
 24h	BYTE	initial VDU character attribute
 25h	BYTE	size of RAM disk in 2K blocks
 26h	BYTE	initial system UART setup byte
 27h	BYTE	initial external UART setup byte
 28h 24 BYTEs	available for user application
Note:	bytes 00h-0Dh are the same on the IBM AT as they are used/updated by
	  the clock chip

Bitfields for RTC status register B:
 bit 7	clear if normal update, set if abort update
 bit 6	periodic interrupt enable
 bit 5	alarm interrupt enable
 bit 4	update end interrupt enable
 bit 3	square wave enable
 bit 2	date mode (clear = BCD, set = binary)
 bit 1	24-hour format
 bit 0	daylight saving time enable
--------O-1501-------------------------------
INT 15 - VMiX - "sys_chanreq" - I/O CHANNEL OBJECT MANAGER
	AH = 01h
	STACK:	WORD	object ID of requestor
		DWORD	pointer to ASCIZ name of requested method
			"assign" assign channel to object
			"deassign" deassign channel
			"cursor" set cursor on/off
			"init" initialize comm port
			"open" open I/O channel
			"position" set cursor position
			"receive" get buffered packet from comm port
			"send" send buffered packet to comm port
			"vio" set current virtual I/O to specified channel
			"window" make window at cursor position
		---if "assign"---
		 WORD	object UID
		 WORD	caller UID/PID
		 DWORD	CSL with port
		---if "deassign"---
		 WORD	channel ID
		---if "cursor"---
		 WORD	channel ID (must be a SRCSINK)
		 WORD	new state (0000h off, 0001h on)
		---if "init"---
		 WORD	channel ID (must be a SRCSINK)
		 WORD	comm port number (00h-03h)
		 WORD	UART init code
		---if "open"---
		 WORD	channel ID
		---if "position"---
		 WORD	channel ID (must be a SRCSINK)
		 WORD	position (high byte = row, low byte = column)
		---if "receive"---
		 DWORD	pointer to buffer
		---if "send"---
		 WORD	length of buffer
		 DWORD	pointer to buffer
		---if "vio"---
		 WORD	channel ID (must be a SRCSINK)
		---if "window"---
		 WORD	top left (high byte = row, low byte = column)
		 WORD	bottom right (high byte = row, low byte = column)
Return: DX:AX -> IRP structure or 0000h:0000h
SeeAlso: AH=00h"VMiX",AH=02h"VMiX"
--------T-1501-------------------------------
INT 15 - MultiDOS Plus - REQUEST RESOURCE SEMAPHORE
	AH = 01h
	AL = semaphore number (00h-3Fh)
Return: AH = status
	    00h successful
	    02h invalid semaphore number
Notes:	if the semaphore is not owned, ownership is assigned to the calling
	  task and the call returns immediately
	if the semaphore is already owned by another task, the calling task
	  is placed on a queue for the semaphore and suspended until it can
	  become owner of the semaphore
	semaphore 0 is used internally by MultiDOS to synchronize DOS access
SeeAlso: AH=02h"MultiDOS",AH=10h"MultiDOS",AH=1Bh"MultiDOS"
--------B-1502-------------------------------
INT 15 - CASSETTE - READ DATA (PC and PCjr only)
	AH = 02h
	CX = number of bytes to read
	ES:BX -> buffer
Return: CF clear if successful
	    DX = number of bytes read
	    ES:BX -> byte following last byte read
	CF set on error
	AH = status (see below)
SeeAlso: AH=00h"CASSETTE",AH=03h"CASSETTE"

Values for status:
 00h	successful
 01h	CRC error
 02h	bad tape signals
 04h	no data
 80h	invalid command
 86h	no cassette present
--------b-1502-------------------------------
INT 15 - Amstrad PC1512 - READ DATA FROM NON-VOLATILE RAM
	AH = 02h
	AL = NVRAM location (00h to 3Fh)
Return: AH = return code
	    00h OK
	    01h address bad
	    02h checksum error
	AL = NVRAM data value
SeeAlso: AH=01h"Amstrad"
--------O-1502-------------------------------
INT 15 - VMiX - "sys_memreq" - MEMORY OBJECT MANAGER
	AH = 02h
	STACK:	WORD	object ID of requestor
		DWORD	pointer to ASCIZ name of requested method
			"assign" allocate low memory block
			"assign extended" allocate extended memory pages
			"assign gdt" allocate GDT selector
			"paged" allocate low paged memory
			"paged extended" alllocate extended memory pages
			"deassign" free memory block
			"deassign gdt" free GDT selector
			"getvpage" get physical address for virtual page
			"setvpage" set physical address for virtual page
			"info" get VMiX memory usage info block
			"move" move contents of 32-bit memory
			"newmcb" make new DOS memory control block
			"owner" get process ID of MCB or PSP owner
			"umb" allocate upper memory block
			"video" toggle system use of vidoe memory and get stat
		---if "assign"---
		 WORD	number of objects
		 WORD	size in bytes (multiple of 512 bytes)
		---if "assign extended"---
		 WORD	number of objects
		 WORD	size in bytes (multiple of 4K)
		---if "assign gdt"---
		 WORD	access type (low byte)
		 WORD	segment size in paragraphs
		 DWORD	pointer to start of physical segment
		---if "paged"---
		 WORD	number of 512-byte pages
		---if "paged extended"
		 WORD	number of 4K pages
		---if "deassign"---
		 DWORD	pointer returned by previous allocation call
		---if "deassign gdt"---
		 WORD	GDT selector
		---if "getvpage"---
		 WORD	owner's process ID
		 DWORD	pointer to buffer for page structure (struct VPGE)
		---if "setvpage"---
		 WORD	owner's process ID
		 DWORD	pointer to new page structure (struct VPGE)
		---if "info"---
		 no additional arguments
		---if "move"
		 DWORD	32-bit source address
		 DWORD	32-bit destination address
		 WORD	number of words to move
		---if "newmcb"---
		 DWORD	pointer to new MCB's location
		 WORD	size of memory block
		 DWORD	pointer to ASCIZ name string (max 8 chars)
		---if "owner"---
		 WORD	MCB or PSP segment
		---if "umb"---
		 WORD	size in paragraphs
		---if "video"---
		 no additional arguments
Return: DX:AX -> memory block or VPGE struct or 0000h:0000h
SeeAlso: AH=00h"VMiX",AH=01h"VMiX"
--------T-1502-------------------------------
INT 15 - MultiDOS Plus - RELEASE RESOURCE SEMAPHORE
	AH = 02h
	AL = semaphore number (00h-3Fh)
Return: AH = status
	    00h successful
	    01h not semaphore owner
	    02h invalid semaphore number
Notes:	if any tasks are waiting for the semaphore, the first task on the wait
	  queue will become the new owner and be reawakened
	do not use within an interrupt handler
SeeAlso: AH=01h"MultiDOS",AH=10h"MultiDOS",AH=1Ch"MultiDOS"
--------B-1503-------------------------------
INT 15 - CASSETTE - WRITE DATA (PC and PCjr only)
	AH = 03h
	CX = number of bytes to write
	ES:BX -> data buffer
Return: CF clear if successful
	    ES:BX -> byte following last byte written
	CF set on error
	AH = status (see AH=02h"CASSETTE")
	CX = 0000h
SeeAlso: AH=00h"CASSETTE",AH=02h"CASSETTE"
--------V-1503-------------------------------
INT 15 - Amstrad PC1512 - WRITE VDU COLOR PLANE WRITE REGISTER
	AH = 03h
	AL = value (I,R,G,B bits)
SeeAlso: AH=04h"Amstrad"
--------O-1503-------------------------------
INT 15 - VMiX - "sys_pinput" - PROMPTED CONSOLE INPUT
	AH = 03h
	STACK:	DWORD	pointer to ASCII prompt
		WORD	field outline character
		WORD	length of input field (max 7Fh)
		DWORD	address of pointer to input buffer
Return: AX = length of input (input buffer is padded with blanks)
SeeAlso: AH=04h"VMiX"
--------T-1503-------------------------------
INT 15 - MultiDOS Plus - SUSPEND TASK FOR INTERVAL
	AH = 03h
	DX = number of time slices to remain suspended
Return: after specified interval has elapsed
Note:	when priority-based scheduling is in use, high-priority tasks should
	  use this function to yield the processor
SeeAlso: AH=00h"MultiDOS",AH=0Ah"MultiDOS"
--------B-1504-------------------------------
INT 15 - SYSTEM - BUILD ABIOS SYSTEM PARAMETER TABLE (PS)
	AH = 04h
	ES:DI -> results buffer length 20h for System Parameter Table
	DS = segment containing ABIOS RAM extensions (zero if none)
Return: AH = 00h success: results at ES:DI
	CF set on failure
SeeAlso: AH=05h"ABIOS",C1h

Format of ABIOS System Parameter Table:
Offset	Size	Description
 00h	DWORD	FAR address of ABIOS Common Start Routine
 04h	DWORD	FAR address of ABIOS Interrupt Routine
 08h	DWORD	FAR address of ABIOS Time-out Routine
 0Ch	WORD	number of bytes of stack required by this ABIOS implementation
 0Eh 16 BYTEs	reserved
 1Eh	WORD	number of entries in initialization table
--------V-1504-------------------------------
INT 15 - Amstrad PC1512 - WRITE VDU COLOR PLANE READ REGISTER
	AH = 04h
	AL = value (RDSEL1 and RDSEL0)
SeeAlso: AH=03h"Amstrad",05h"Amstrad"
--------O-1504-------------------------------
INT 15 - VMiX - "sys_vprintf" - FORMATTED OUTPUT TO STREAM
	AH = 04h
	STACK:	DWORD	control string
		DWORD	array of arguments
SeeAlso: AH=03h"VMiX"
--------T-1504-------------------------------
INT 15 - MultiDOS Plus - SEND MESSAGE TO ANOTHER TASK
	AH = 04h
	AL = mailbox number (00h-3Fh)
	CX = message length in bytes
	DS:SI -> message
Return: AH = status
	    00h successful
	    01h out of message memory
	    02h invalid mailbox number
Note:	the message is copied into a system buffer; the caller may immediately
	  reuse its buffer
SeeAlso: AH=05h"MultiDOS"
--------B-1505-------------------------------
INT 15 - SYSTEM - BUILD ABIOS INITIALIZATION TABLE (PS)
	AH = 05h
	ES:DI -> results buffer length (18h * Number_of_Entries)
	DS = segment containing ABIOS RAM extensions (zero if none)
Return: AH = 00h success: results at ES:DI
	CF set on failure
SeeAlso: AH=04h"ABIOS",C1h

Format of one entry of ABIOS Initialization Table:
Offset	Size	Description
 00h	WORD	device ID
 02h	WORD	number of Logical IDs
 04h	WORD	Device Block length (zero for ABIOS patch or extension)
 06h	DWORD	-> init routine for Device Block and Function Transfer Table
 0Ah	WORD	request block length
 0Ch	WORD	Function Transfer Table length (zero for a patch)
 0Eh	WORD	Data Pointers length (in Common Data Area)
 10h	BYTE	secondary device ID (hardware level this ABIOS ver supports)
 11h	BYTE	revision (device driver revision level this ABIOS supports)
 12h  6 BYTEs	reserved
--------V-1505-------------------------------
INT 15 - Amstrad PC1512 - WRITE VDU GRAPHICS BORDER REGISTER
	AH = 05h
	AL = value (I,R,G,B bits)
SeeAlso: AH=04h"Amstrad"
--------O-1505-------------------------------
INT 15 - VMiX - "sys_getpid" - GET PROCESS ID OF CURRENT PROCESS
	AH = 05h
Return: AX = process ID
SeeAlso: AH=06h"VMiX",AH=0Bh"VMiX"
--------T-1505-------------------------------
INT 15 - MultiDOS Plus - CHECK MAILBOX
	AH = 05h
	AL = mailbox number (00h-3Fh)
Return: AH = status
	    00h successful
		DX = length of first message in queue, 0000h if no message
	    02h invalid mailbox number
SeeAlso: AH=04h"MultiDOS",AH=06h"MultiDOS"
--------b-1506-------------------------------
INT 15 - Amstrad PC1512 - GET ROS VERSION NUMBER
	AH = 06h
Return: BX = version number
--------O-1506-------------------------------
INT 15 - VMiX - "sys_getpcb" - GET POINTER TO PROCESS CONTROL BLOCK
	AH = 06h
	STACK:	WORD	process ID
Return: DX:AX -> process control block
SeeAlso: AH=05h"VMiX",AH=07h"VMiX",AH=08h"VMiX"
--------T-1506-------------------------------
INT 15 - MultiDOS Plus - READ MAILBOX
	AH = 06h
	AL = mailbox number (00h-3Fh)
	CX = size of buffer in bytes
	ES:DI -> buffer for message
Return: AH = status
	    00h successful
		CX = number of bytes copied
		DX = actual length of message
	    02h invalid mailbox number
Note:	if the caller's buffer is not large enough, the message is truncated
	  and the remainder is lost
SeeAlso: AH=04h"MultiDOS",AH=05h"MultiDOS"
--------O-1507-------------------------------
INT 15 - VMiX - "sys_getocb" - GET POINTER TO OBJECT CONTROL BLOCK
	AH = 07h
	STACK:	WORD	object type
Return: DX:AX -> object control block
SeeAlso: AH=06h"VMiX",AH=08h"VMiX"
--------T-1507-------------------------------
INT 15 - MultiDOS Plus - SPAWN INTERNAL TASK (CREATE NEW THREAD)
	AH = 07h
	BX:CX = entry point of new task
	DX = stack size in paragraphs
Return: AH = status
	    00h successful
	    01h no free task control blocks
	    02h no free memory for task's stack
Note:	execution returns immediately to calling task
SeeAlso: AH=08h"MultiDOS",AH=09h"MultiDOS",AH=13h"MultiDOS"
--------O-1508-------------------------------
INT 15 - VMiX - "sys_getccb" - GET CHANNEL CONTROL BLOCK
	AH = 08h
	STACK:	WORD	channel ID
Return: DX:AX -> channel control block
SeeAlso: AH=06h"VMiX",AH=07h"VMiX"
--------T-1508-------------------------------
INT 15 - MultiDOS Plus - TERMINATE INTERNAL TASK (KILL THREAD)
	AH = 08h
Return: calling task terminated, so execution never returns to caller
Notes:	an internal task must be terminated with this function rather than a
	  DOS termination function
	task's stack space is returned to parent task's memory pool
SeeAlso: AH=07h"MultiDOS"
--------O-1509-------------------------------
INT 15 - VMiX - "sys_getqueue" - GET ID OF QUEUED ELEMENT
	AH = 09h
	STACK:	WORD	queue ID (0 = process queue, 1 = object, 3 = type)
		WORD	subqueue ID
Return: AX = queue ID
SeeAlso: AH=0Ah"VMiX"
--------T-1509-------------------------------
INT 15 - MultiDOS Plus - CHANGE TASK'S PRIORITY
	AH = 09h
	AL = new priority
Note:	the priority has different meanings depending on whether priority-
	  based or round-robin scheduling is used
SeeAlso: AH=07h"MultiDOS"
--------O-150A-------------------------------
INT 15 - VMiX - "sys_qetqnext" - GET ID OF NEXT QUEUED ELEMENT
	AH = 0Ah
	STACK:	WORD	queue ID (0 = process queue, 1 = object, 3 = type)
		WORD	ID of current element in queue chain
Return: AX = ID of next element
SeeAlso: AH=09h"VMiX",AH=0Fh"VMiX"
--------T-150A-------------------------------
INT 15 - MultiDOS Plus - CHANGE TIME SLICE INTERVAL
	AH = 0Ah
	AL = new interval
	    00h = 55.0 ms (default)
	    80h = 27.5 ms
	    40h = 13.75 ms
	    20h = 6.88 ms
	    10h = 3.44 ms
	    08h = 1.72 ms
SeeAlso: AH=03h"MultiDOS"
--------O-150B-------------------------------
INT 15 - VMiX - "sys_sysreq" - SYSTEM CONFIGURATION MANAGER
	AH = 0Bh
	STACK:	WORD	caller's UID
		DWORD	pointer to ASCIZ name of requested method
			"abort" abort current send/receive on comm port
			"block" start/end critical section
			"close" terminate interrupt-drive comm I/O
			"open" prepare comm port for interrupt-driven I/O
			"delay" set delay timer and wait
			"hibernate" put process to sleep
			"ints" enable/disable interrupt-driven INT 14h
			"length" get current send/receive buffer offsets
			"kswitch" switch stacks
			"numproc" get number of active processes
			"protocol" set protocol function for comm interrupts
			"relocate" set/reset VMiX flag for relocating to himem
			"status" get current open comm port status
			"wake" awaken a process
			"xport" get comm port polled for logins
		---if "abort"---
		 no additional arguments
		---if "block"---
		 WORD	0000h end, 0001h start
		---if "close"---
		 no additional arguments
		---if "open"---
		 WORD	comm port (00h-03h)
		 WORD	BIOS parameter byte (see INT 14/AH=00h), except
			bits 7-5 = 000 for 19200, 001 for 38400, 011 for 115200
		---if "delay"---
		 WORD	time in seconds
		---if "hibernate"---
		 WORD	process ID
		---if "ints"---
		 WORD	0000h if no, 0001h if yes
		---if "length","numproc","relocate","status","xport"---
		 no additional arguments
		---if "kswitch"---
		 DWORD	pointer to new stack
		---if "protocol"---
		 DWORD	pointer to function (must be in low "assign"ed memory
			when in 386 mode)
		---if "wake"---
		 WORD	process ID
Return: DX:AX -> result or 0000h:0000h
		---if "length"---
		 BYTE	receive offset
		 BYTE	send offset
		---if "kswitch"---
		 DWORD	old stack pointer
		---if "numproc"---
		 WORD	number of active processes
		---if "status"---
		 current open comm port status
		---if "xport"---
		 current comm port being polled for logins
SeeAlso: AH=05h"VMiX",AH=0Eh"VMiX"
--------T-150B-------------------------------
INT 15 - MultiDOS Plus - FORCE DISPLAY OUTPUT TO PHYSICAL SCREEN MEMORY
	AH = 0Bh
Notes:	sets calling task's screen pointer to actual screen memory; the pointer
	  may be restored with AH=0Ch
	caller's video mode must be same as foreground task's video mode
	any text written while in the background will be saved to the
	  foreground task's virtual screen when it switches to the background
	useful if a background task wants to display a message on the
	  foreground screen
SeeAlso: AH=0Ch"MultiDOS"
--------O-150C-------------------------------
INT 15 - VMiX - "sys_getstack" - GET POINTER TO PROCESS TSS STACK
	AH = 0Ch
	STACK:	WORD	process ID
Return: DX:AX -> TSS stack store
SeeAlso: AH=00"VMiX"
--------T-150C-------------------------------
INT 15 - MultiDOS Plus - RESTORE OLD VIDEO DISPLAY MEMORY
	AH = 0Ch
Note:	restores task's screen pointer saved by AH=0Bh; must not be called
	  unless AH=0Bh has been called first
SeeAlso: AH=0Bh"MultiDOS"
--------O-150D-------------------------------
INT 15 - VMiX - "sys_spawn" - START A CHILD PROCESS JOB SHELL
	AH = 0Dh
	STACK:	DWORD	ASCIZ string starting with requested I/O channel and
			followed by standard VMiX shell command string
Return: AX = process ID or error code "SYS_ERROR"
Note:	the maximum string length is 7Fh characters
SeeAlso: AH=0Eh"VMIX",AH=11h"VMiX",INT 21/AH=4Bh
--------T-150D-------------------------------
INT 15 - MultiDOS Plus - DISABLE MULTITASKING
	AH = 0Dh
Note:	calling task receives all time slices until AH=0Eh is called; this
	  allows time-critical events or nonreentrant code to be processed
SeeAlso: AH=0Eh"MultiDOS",AH=10h"MultiDOS",AX=101Bh,AH=20h"MultiDOS"
--------O-150E-------------------------------
INT 15 - VMiX - "sys_kill" - HARD TERMINATE PROCESS
	AH = 0Eh
	STACK:	WORD	process ID
Return: AX = status (SYS_OK or SYS_ERROR)
SeeAlso: AH=0Bh"VMiX",AH=0Dh"VMIX"
--------T-150E-------------------------------
INT 15 - MultiDOS Plus - ENABLE MULTITASKING
	AH = 0Eh
SeeAlso: AH=0Dh"MultiDOS",AX=101Ch,AH=20h"MultiDOS"
--------d-150F-------------------------------
INT 15 C - SYSTEM - FORMAT UNIT PERIODIC INTERRUPT (PS ESDI drives only)
	AH = 0Fh
	AL = phase code
	    00h reserved
	    01h surface analysis
	    02h formatting
Return: CF clear if formatting should continue, set if it should terminate
Note:	called during ESDI drive formatting after each cylinder is completed
SeeAlso: INT 13/AH=1Ah
--------O-150F-------------------------------
INT 15 - VMiX - "sys_getqkey" - GET KEY FIELD OF QUEUED ELEMENT
	AH = 0Fh
	STACK:	WORD	queue ID (0 = process queue, 1 = object q, 3 = type q)
		WORD	ID of element in queue chain
Return: AX = key
SeeAlso: AH=0Ah"VMiX"
--------T-150F-------------------------------
INT 15 - MultiDOS Plus - EXECUTE A MULTIDOS PLUS COMMAND
	AH = 0Fh
	DS:BX -> ASCIZ command
Return: after command has been processed
Notes:	specified string is executed as if it had been typed at the MultiDOS
	  command prompt
	the task is placed on a queue which MultiDOS examines periodically and
	  is suspended until MultiDOS has processed the command
	all lowercase characters up to the first blank are converted to upper
	  case within the given buffer
--------O-1510-------------------------------
INT 15 - VMiX - "sys_virtual" - EXECUTE CONFORMING FUNCTION IN PROTECTED MODE
	AH = 10h
	STACK:	DWORD	pointer to function
	      N WORDs	function args
Return: AX = function's return value??? (not specified in documentation)
Note:	while the function is executing, the following global descriptors are
	  available:
		20h stack segment
		38h code segment of function
		40h data alias for function's code segment
	  additional GDT descriptors can be allocated using AH=02h with
	  function "assign gdt"
SeeAlso: AH=02h"VMiX",AH=51h"VMiX"
--------T-1510-------------------------------
INT 15 - MultiDOS Plus - TEST RESOURCE SEMAPHORE
	AH = 10h
	AL = semaphore number (00h-3Fh)
Return: AH = status
	    00h semaphore not in use
	    01h semaphore owned by another task
	    02h invalid semaphore number
	    03h semaphore owned by caller
SeeAlso: AH=02h"MultiDOS",AH=0Dh"MultiDOS",AH=1Dh"MultiDOS"
--------Q-151000-----------------------------
INT 15 - TopView - "PAUSE" - GIVE UP CPU TIME
	AX = 1000h
Return: after other processes run
Note:	under DESQview, if the process issuing this call has hooked INT 08h,
	  the current time-slice is set to expire at the next clock tick rather
	  than immediately
SeeAlso: AH=00h"MultiDOS",AX=5305h,INT 21/AH=89h,INT 21/AH=EEh"DoubleDOS"
SeeAlso: INT 2F/AX=1680h,INT 60/DI=0106h,INT 62/AH=01h,INT 7A/BX=000Ah
SeeAlso: INT 7F/AH=E8h
--------Q-151001-----------------------------
INT 15 - TopView - "GETMEM" - ALLOCATE "SYSTEM" MEMORY
	AX = 1001h
	BX = number of bytes to allocate
Return: ES:DI -> block of memory or 0000h:0000h (DV v2.26+)
	AX = status (DV v2.42)
	    0000h successful
	    0001h failed
Note:	use SETERROR (AX=DE15h) to avoid a user prompt if there is insufficient
	  common memory.  Under DV v2.42, this call never generates a user
	  prompt regardless of the SETERROR value; instead, it always returns
	  AX=0001h and ES:DI=0000h:0000h if out of memory
SeeAlso: AX=1002h,AX=102Eh,AX=DE0Ch,AX=DE15h
--------Q-151002-----------------------------
INT 15 - TopView - "PUTMEM" - DEALLOCATE "SYSTEM" MEMORY
	AX = 1002h
	ES:DI -> previously allocated block
Return: block freed
SeeAlso: AX=1001h,AX=DE0Dh
--------Q-151003-----------------------------
INT 15 - TopView - "PRINTC" - DISPLAY CHARACTER/ATTRIBUTE ON SCREEN
	AX = 1003h
	BH = attribute
	BL = character
	DX = segment of object handle for window
Note:	BX=0 does not display anything, it only positions the hardware cursor
--------Q-1510-------------------------------
INT 15 - TopView - UNIMPLEMENTED IN DV 2.x
	AH = 10h
	AL = 04h thru 12h
Return: pops up "Programming error" window in DV 2.x
--------Q-151013-----------------------------
INT 15 - TopView - "GETBIT" - DEFINE A 2ND-LEVEL INTERRUPT HANDLER
	AX = 1013h
	ES:DI -> FAR service routine
Return: BX = bit mask indicating which bit was allocated
	     0000h if no more bits available
SeeAlso: AX=1014h,AX=1015h
Note:	only a few TopView/DESQview API calls are allowed during a hardware
	  interrupt; if other calls need to be made, the interrupt handler
	  must schedule a 2nd-level interrupt with "SETBIT" (AX=1015h)
--------Q-151014-----------------------------
INT 15 - TopView - "FREEBIT" - UNDEFINE A 2ND-LEVEL INTERRUPT HANDLER
	AX = 1014h
	BX = bit mask from INT 15/AX=1013h
SeeAlso: AX=1013h,AX=1015h
--------Q-151015-----------------------------
INT 15 - TopView - "SETBIT" - SCHEDULE ONE OR MORE 2ND-LEVEL INTERRUPTS
	AX = 1015h
	BX = bit mask for interrupts to post
Return: indicated routines will be called: (DV 2.0x) at next task switch
					   (DV 2.2x) immediately on return from
						     hardware interrupt
SeeAlso: AX=1013h,AX=1014h
Notes:	this is one of the few TopView calls which are allowed from a hardware
	  interrupt handler
	the handler will be called with ES containing the segment of the handle
	  of the next task to be executed; on return, ES must be the segment of
	  a task handle
--------Q-151016-----------------------------
INT 15 - TopView - "ISOBJ" - VERIFY OBJECT HANDLE
	AX = 1016h
	ES:DI = possible object handle
Return: BX = FFFFh if ES:DI is a valid object handle
	     0000h if ES:DI is not
Note:	under DESQview versions prior to 2.50, an object handle is always a
	  pointer to the object; for versions 2.50 and up, only task handles
	  are always pointers (other handles may consist of a unique object
	  number and offset into DESQview's common memory)
SeeAlso: AX=DE14h,AX=DE2Bh,AX=DE2Ch

Format of object:
Offset	Size	Description
 00h	WORD	offset in common memory of previous object of same type
 02h	WORD	offset in common memory of next object of same type
 04h	WORD	signature FEDCh (DV 2.42-)
		signature FEDCh or object number (DV 2.50+)
 06h	WORD	object type
		00h window/task
		01h mailbox
		02h keyboard
		03h timer
		04h pointer
		05h panel
		06h objectq
 08h	DWORD	object handle to return to caller
 0Ch	DWORD	canonicalized object address (segment = common memory)
 10h	WORD	offset in common memory of owning task
 12h	WORD	mapping context
		offset in common memory of mapping context record (see below)
	remainder varies by object type and DESQview version
---v2.42 keyboard object---
 14h	WORD	flag bits (see also AH=12h/BH=0Ah"OBJECT")
		bit 15: keyboard opened
 16h  4 BYTEs	???
 1Ah	WORD	priority in OBJECTQ???
 1Ch	...
 25h	WORD	offset in common memory of ??? task
 27h  4 BYTEs	???
---v2.42 objectq object---
 14h	WORD	flag bits (see also AH=12h/BH=0Ah"OBJECT")
		bit 15: OBJECTQ opened
 16h  2 BYTEs	???
 18h	WORD	offset in common memory of ??? task
 1Ah  6 BYTEs	???
---v2.42 mailbox object---
 14h	WORD	flag bits (see also AH=12h/BH=0Ah"OBJECT")
		bit 15: mailbox opened
 1Ah	WORD	priority in OBJECTQ???
 1Ch  6 BYTEs	???
 22h	WORD	offset in common memory of mailbox name (counted string)
		0000h if no name
     <= 5 BYTEs ???
---v2.22-2.42 window/task object---
 14h	BYTE	00h window, 01h task
 15h	BYTE	internal (not Switch menu) window number???
 16h	BYTE	internal (not Switch menu) window number???
 17h	WORD	segment of internal window record
 19h  2 BYTEs	???
 1Bh	BYTE	cursor row
 1Ch	BYTE	cursor column
 1Dh  2 BYTEs	???
 1Fh	BYTE	window height (logical)
 20h	BYTE	window width (logical)
 21h	BYTE	window position, row
 22h	BYTE	window position, column
 23h	BYTE	window height (visible)
 24h	BYTE	window width (visible)
 25h	BYTE	row of top of frame (or window if unframed)
 26h	BYTE	column of left of frame (or window if unframed)
 27h	BYTE	window height (physical, including frame)
 28h	BYTE	window width (physical, including frame)
 29h  6 BYTEs	???
 2Fh	BYTE	??? initially logical window height
 30h	BYTE	??? initially logical window width
 31h  2 BYTEs	???
 33h	BYTE	minimum height of window
 34h	BYTE	minimum width of window
 35h	BYTE	maximum height of window
 36h	BYTE	maximum width of window
 37h  3 BYTEs	???
 3Ah  8 BYTEs	window frame characters: ul,ur,ll,lr,t,b,l,r
 42h 24 BYTEs	attributes???
 5Ah  8 BYTEs	window frame characters: ul,ur,ll,lr,t,b,l,r
 62h  3 BYTEs	???
 65h	BYTE	??? bitflags
 66h  2 BYTEs	???
 68h	WORD	offset in common memory of window name or 0000h if untitled
 6Ah	WORD	length of window name
 6Ch  2 BYTEs	???
 6Eh	WORD	offset of logical cursor in window (in character cells)
 70h	DWORD	pointer to field table for window
 74h	BYTE	???
 75h  2 BYTEs	???
 77h	BYTE	number of last-visited field
 78h	DWORD	pointer to field table entry for last-visited field
 7Ch  3 BYTEs	???
 7Fh	BYTE	select field marker character
 80h	BYTE	??? bit flags
		bit 0: allow ECh window stream opcode to change reverse logattr
		bit 1: alternate field processing mode selected
 81h	BYTE	???
 82h	DWORD	notification function (manager stream opcode 8Ah)
		no notification if segment = 0000h
 86h	DWORD	notification argument (manager stream opcode 8Bh)
 8Ah	WORD	offset in common memory of ??? window object or 0000h
 8Ch	WORD	offset in common memory of ??? window object or 0000h
 8Eh	WORD	offset in common memory of ??? window object or 0000h
 90h	BYTE	??? bitflags
 91h	BYTE	???
 ---task object only
 92h	BYTE	bit flags (bits 0-4)
 93h	BYTE	character for ??? (default 20h)
 94h	BYTE	??? flag
 95h	WORD	offset in common memory of ???
 97h  2 BYTEs	???
 99h	WORD	???
 9Bh	BYTE	??? bit flags
		bit 3: ???
		bit 6: perform protected-attribute processing on select fields
 9Ch	BYTE	???
 9Dh	WORD	offset in common memory of current register save record
		(see below).  No register save record in use if < 01C0h
 9Fh	WORD	offset in common memory of task's keyboard object
 A1h	WORD	offset in common memory of task's OBJECTQ object
 A3h	WORD	offset in common memory of task's mailbox object
 A5h	WORD	semaphore: FFFFh if on user stack, else on task's private stack
 A7h	DWORD	user's SS:SP
 ABh	WORD	task's private SP (SS read from offset 0Ah)
 ADh  6 BYTEs	???
 B3h	BYTE	??? bit flags
		bit 0: run in foreground only
 B4h	BYTE	???
 B5h	BYTE	??? bitflags
 B6h	BYTE	task status (see AX=DE2Ch)
 B7h  9 BYTEs	???
 C0h	WORD	head pointer for keyboard buffer (wraps back to 00h after 80h)
 C2h	WORD	tail pointer for keyboard buffer (wraps back to 00h after 80h)
 C4h  2 BYTEs	??? (0000h)
 C6h	WORD	segment of keyboard buffer for task
 C8h	WORD	offset in common memory of ??? keyboard object
 CAh	BYTE	???
 CBh	WORD	offset in common memory of ??? object
 CEh	BYTE	??? flag
 CFh	WORD	offset in common memory of default notify window for task
		or 0000h if none
 D1h  4 BYTEs	???
 D5h	BYTE	window number on Switch Window menu
 D6h  5 BYTEs	???
 DBh	WORD	offset in common memory of ??? object
 DDh  2 BYTEs	???
 DFh	WORD	API level for task
 E1h	WORD	offset in common memory of ??? keyboard object
 E7h	WORD	segment of ???
 E9h 18 BYTEs	???
 FBh	WORD	???
 FDh	BYTE	???
 FFh 26 BYTEs	???
119h	DWORD	SS:SP for ???
11Dh  4 BYTEs	???
121h	DWORD	pointer to ???
125h 35 BYTEs	???
---v2.22
145h		task's default keyboard object
---v2.42
148h	WORD	???
14Ah	BYTE	???
14Dh 42 BYTEs	task's default keyboard object
177h 32 BYTEs	task's ObjectQ object
197h 41 BYTEs	task's default mailbox object
1C0h 24 BYTEs	first register save record
450h	--	default top of private stack

Format of Register Save Record:
Offset	Size	Description
 00h	WORD	AX
 02h	WORD	BX
 04h	WORD	CX
 06h	WORD	DX
 08h	WORD	DI
 0Ah	WORD	SI
 0Eh	WORD	DS
 10h	WORD	ES
 12h	DWORD	return address
 16h	WORD	original flags

Format of mapping context record:
Offset	Size	Description
 00h	WORD	segment of start of system memory chain
 02h	WORD	size of process's memory in paragraphs
 04h 15 BYTEs	???
 13h	BYTE	reference count
--------Q-151017-----------------------------
INT 15 - TopView - UNIMPLEMENTED IN DV 2.x
	AX = 1017h
Return: pops up "Programming error" window in DV 2.x
--------Q-151018-----------------------------
INT 15 - TopView - "LOCATE" - FIND WINDOW AT A GIVEN SCREEN LOCATION
	AX = 1018h
	BH = column
	BL = row
	ES = segment of object handle for window below which to search
	     0000h = start search with topmost window
Return: ES = segment of object handle for window which is visible at the
	       indicated position, or covered by indicated window
	   = 0000h no window
SeeAlso: AX=1023h,AX=1024h
--------Q-151019-----------------------------
INT 15 - TopView - "SOUND" - MAKE TONE
	AX = 1019h
	BX = frequency in Hertz (0000h = silence)
	CX = duration in clock ticks (18.2 ticks/sec)
Return: immediately, tone continues to completion
Notes:	if another tone is already playing, the new tone does not start until
	  completion of the previous one.  Up to 32 tones may be queued before
	  the process is blocked until a note completes.
	in DV 2.00, the lowest tone allowed is 20 Hz
	if CX = 0, the current note is cancelled; if BX = 0 as well, all queued
	  notes are also cancelled
SeeAlso: INT 16/AH=73h
--------Q-15101A-----------------------------
INT 15 - TopView - "OSTACK" - SWITCH TO TASK'S INTERNAL STACK
	AX = 101Ah
Return: stack switched
Notes:	this call may not be nested; a second call must be preceded by a call
	  to "USTACK" (AX=1025h)
	while TopView requires many API calls to be executed while on the
	  task's internal stack, DESQview allows those calls to be executed
	  regardless of the current stack
SeeAlso: AX=1025h
--------Q-15101B-----------------------------
INT 15 - TopView - "BEGINC" - BEGIN CRITICAL REGION
	AX = 101Bh
Return: task-switching temporarily disabled
Notes:	will not task-switch until "ENDC" (AX = 101Ch) called unless task
	  voluntarily releases the CPU (upon regaining the CPU, task-switching
	  will again be disabled)
	suspends the caller until DOS is free
SeeAlso: AH=0Dh"MultiDOS",AX=101Ch,AX=DE13h,AX=DE1Ch,INT 2F/AX=1681h
SeeAlso: INT 60/DI=0602h
--------Q-15101C-----------------------------
INT 15 - TopView - "ENDC" - END CRITICAL REGION
	AX = 101Ch
Return: task-switching enabled
Note:	this API call may be made from within a hardware interrupt handler
SeeAlso: AX=101Bh,AX=DE13h,AX=DE1Bh,INT 2F/AX=1682h,INT 60/DI=0603h
--------Q-15101D-----------------------------
INT 15 - TopView - "STOP" - STOP TASK
	AX = 101Dh
	ES = segment of object handle for task to be stopped
	     (== handle of main window for that task)
Return: indicated task will not get any CPU time until restarted with AX=101Eh
Note:	once a task has been stopped, additional "STOP"s are ignored
BUG:	in DV 2.00, this function is ignored unless the indicated task is the
	  current task
SeeAlso: AX=101Eh,AX=102Bh,AH=12h"VMiX",INT 21/AH=81h
--------Q-15101E-----------------------------
INT 15 - TopView - "START" - START TASK
	AX = 101Eh
	ES = segment of object handle for task to be started
	     (== handle of main window for that task)
Return: indicated task is started up again
Note:	once a task has been started, additional "START"s are ignored
SeeAlso: AX=101Dh,AX=102Bh,INT 21/AH=82h
--------Q-15101F-----------------------------
INT 15 - TopView - "DISPEROR" - POP-UP ERROR WINDOW
	AX = 101Fh
	BX = bit fields
	     bits 0-12: number of characters to display
	     bits 13,14: which mouse button may be pressed to remove window
			 00 = either
			 01 = left
			 10 = right
			 11 = either
	     bit 15: beep if 1
	ES:DI -> text of message
	CH = width of error window (0 = default)
	CL = height of error window (0 = default)
	DX = segment of object handle
Return: BX = status: 1 = left button, 2 = right, 27 = ESC pressed
Note:	window remains on-screen until ESC or indicated mouse button is pressed
--------Q-151020-----------------------------
INT 15 - TopView - UNIMPLEMENTED IN DV v2.00+
	AX = 1020h
Return: pops up "Programming error" window in DV v2.00+
--------Q-151021-----------------------------
INT 15 - TopView - "PGMINT" - INTERRUPT ANOTHER TASK
	AX = 1021h
	BX = segment of object handle for task to interrupt (not self)
	DX:CX -> FAR routine to jump to next time task is run
Return: nothing
Notes:	the FAR routine is entered with the current ES, DS, SI, DI, and BP
	  values, using the task's internal stack (see AX=101Ah); only SS:SP
	  needs to be preserved
	multiple PGMINTs to a single task are processed last-in first-out
	if the other task is in a DOS or DV API call, the interruption will
	  occur on return from that call
--------Q-151022BX0000-----------------------
INT 15 - TopView - "GETVER" - GET VERSION
	AX = 1022h
	BX = 0000h
Return: BX nonzero, TopView or compatible loaded
	(BL = major version, BH = minor version)
Notes:	TaskView returns BX = 0001h, DESQview v2.00+ returns BX = 0A01h
--------Q-151023-----------------------------
INT 15 - TopView - "POSWIN" - POSITION WINDOW
	AX = 1023h
	BX = segment of object handle for parent window within which to
	     position the window (0 = full screen)
	ES = segment of object handle for window to be positioned
	DL = bit flags
	     bits 0,1: horizontal position
		00 = current
		01 = center
		10 = left
		11 = right
	     bits 2,3: vertical position
		00 = current
		01 = center
		10 = top
		11 = bottom
	     bit 4: don't redraw screen if set
	     bits 5-7 not used
	CH = number of columns to offset from position specified by DL
	CL = number of rows to offset from position specified by DL
Return: nothing
--------Q-151024-----------------------------
INT 15 - TopView - "GETBUF" - GET VIRTUAL SCREEN INFO
	AX = 1024h
	BX = segment of object handle for window
	      (0 = use default)
Return: ES:DI -> virtual screen
	CX = size of virtual screen in bytes
	DL = 00h text screen
	     01h graphics screen
SeeAlso: INT 10/AH=FEh,INT 21/AH=2Bh/CX=4445h
--------Q-151025-----------------------------
INT 15 - TopView - "USTACK" - SWITCH BACK TO USER'S STACK
	AX = 1025h
Return: stack switched back
Notes:	call only after having switched to internal stack with AX=101Ah
	while TopView requires many API calls to be executed while on the
	  task's private stack, DESQview allows those calls to be executed
	  regardless of the current stack
SeeAlso: AX=101Ah
--------Q-1510-------------------------------
INT 15 - DESQview (TopView???) - UNIMPLEMENTED IN DV 2.x
	AH = 10h
	AL = 26h thru 2Ah
Return: pops up "Programming error" window in DV 2.x
--------Q-15102B-----------------------------
INT 15 - DESQview v2.00+ (TopView???) - "POSTTASK" - AWAKEN TASK
	AX = 102Bh
	BX = segment of object handle for task
Return: nothing
Note:	forces a task which is waiting on its objectq to continue by placing
	  the handle for the task on the objectq
SeeAlso: AX=101Dh,AX=101Eh,INT 21/AH=82h
--------Q-15102C-----------------------------
INT 15 - DESQview v2.00+ - "NEWPROC" - START NEW APPLICATION IN NEW PROCESS
	AX = 102Ch
	ES:DI -> contents of .PIF/.DVP file (see below)
	BX = size of .PIF/.DVP info
Return: BX = segment of object handle for new task
	     0000h on error
SeeAlso: AX=DE24h,INT 21/AH=4Bh

Format of .PIF/.DVP file:
Offset	Size	Description
 00h	BYTE	reserved (0)
 01h	BYTE	checksum of bytes 02h through 170h
 02h 30 BYTEs	blank-padded program title
 20h	WORD	maximum memory to allocate to partition in KB
 22h	WORD	minimum memory required in KB
 24h 64 BYTEs	ASCIZ program pathname
 64h	BYTE	default drive letter ('A',...)
 65h 64 BYTEs	ASCIZ default directory name
 A5h 64 BYTEs	ASCIZ program parameters
 E5h	BYTE	initial screen mode (0-7) (see also offset 189h)
 E6h	BYTE	number of text pages used
 E7h	BYTE	number of first interrupt to save
 E8h	BYTE	number of last interrupt to save
 E9h	BYTE	rows in virtual screen buffer
 EAh	BYTE	columns in virtual screen buffer
 EBh	BYTE	initial window position, row
 ECh	BYTE	initial window position, column
 EDh	WORD	system memory in KB
 EFh 64 BYTEs	ASCIZ shared program name
12Fh 64 BYTEs	ASCIZ shared program data file
16Fh	BYTE	flags1
		bit 7: writes text directly to screen
		bit 6: runs in foreground only (see also offset 184h)
		bit 5: uses math coprocessor
		bit 4: accesses system keyboard buffer directly
		bits 3-1: reserved (0)
		bit 0: swappable
170h	BYTE	flags2
		bit 6: uses command-line parameters in field at A5h
		bit 5: swaps interrupt vectors
---information unique to .DVP files---
171h  2 BYTEs	keys to use on open menu
173h	WORD	size of script buffer in bytes
175h	WORD	automatically give up CPU after this many tests for keyboard
		input in one clock tick (default 0 = never)
177h	BYTE	nonzero = "uses own colors"
178h	BYTE	nonzero if application swappable
179h  3 BYTEs	reserved (0) according to Quarterdeck documentation
		in actual .DVP files, frequently 01h
17Ch	BYTE	nonzero to automatically close on exit (see also offset 18Bh)
17Dh	BYTE	nonzero if copy-protect floppy is required
---information unique to DESQview 2.0+---
17Eh	BYTE	.DVP version number
		00h DESQview v1.2+
		01h DESQview v2.0+
		02h DESQview v2.2+
17Fh	BYTE	reserved (0)
180h	BYTE	initial number of rows in physical window
181h	BYTE	initial number of columns in physical window
182h	WORD	maximum expanded memory to allow, in KB
184h	BYTE	flags3
		bit 7: automatically assign window position
		bit 5: maximum memory value has been specified
		bit 4: disallow "Close" command
		bit 3: foreground-only when doing graphics
			set by DV 2.3+ when "Runs in Background" = "D" (undoc)
		bit 2: don't virtualize (see also offset 18Bh)
		bit 1: foreground-only during DOS calls
			set by DV 2.3+ when "Runs in Background" = "D" (undoc)
185h	BYTE	keyboard conflict level (0-4 for DV<2.26, 00h-0Fh for DV2.26+)
		bit 3: save/restore entire INT 09 handler state every taskswtch
		bit 2: take special precautions for programs which read the
			BIOS keyboard buffer directly from memory
		bit 1: never indicate keystroke available during scripts/xfers
		bit 0: only indicate keystroke available every sixth poll
186h	BYTE	number of graphics pages used
187h	WORD	extra system memory size
189h	BYTE	initial screen mode (FFh = default) (overrides offset E5h)
---information unique to DESQview 2.2+---
18Ah	BYTE	serial port usage
		FFh uses all serial ports
		00h no serial ports
		01h only COM1
		02h only COM2
18Bh	BYTE	flags4
		bit 7: automatically close application on exit if .COM or .EXE
			specified (see also offset 17Ch)
		bit 6: swappable if not using serial ports
		bit 5: start program with window hidden (v2.26+)
		bit 4: start program in background (v2.26+)
		bit 3: virtualize text (see also offset 184h)
		bit 2: virtualize graphics (see also offset 184h)
		bit 1: share CPU when foreground
		bit 0: share EGA when foreground and zoomed
18Ch	BYTE	protection level for 386 machines
18Dh 19 BYTEs	reserved (0) for regular DESQview
---information unique to DESQview/X 1.0---
18Dh	BYTE	X flags
		bits 3-7: unused (0)
		bit 2: don't display wait message when opening window
		bit 1: don't display DOS window
		bit 0: (XNEWPROC) use DOS client layer (DOS-to-X)
		       (NEWPROC) inherit DOS client layer usage
18Eh	BYTE	X keyboard behavior (0-3)
18Fh	BYTE	font scaling
		00h fixed fonts
		01h scalable fonts
190h 10 BYTEs	reserved (0)
19Ah	WORD	length of data follownig XDVP signature
19Ch  4 BYTEs	signature "XDVP"
1A0h  N BYTEs	list of variable length records (see below)

Format of variable length record:
Offset	Size	Description
 00h	WORD	length of following record, 0000h if end of record list
 02h	BYTE	record type
		01h script filename, up to 64 characters
		02h command-line parameters (allows >64 characters on cmdline)
		03h environment inheritance
		04h environment string
		05h starting window position
---types 01h,02h,04h---
 03h  N BYTEs	ASCII data
---type 03h---
 03h	BYTE	inheritance
		00h do not inherit
		01h inherit environment
---type 05h---
 03h  N BYTEs	ASCII copy of fields as typed into DVPMAN, separated by commas:
		starting row, starting column, starting height, starting width
Note:	if there are multiple occurrences of record types 01h, 02h, or 03h,
	  only the last instance of each type is used; multiple occurrences of
	  type 04h are concatenated
--------Q-15102D-----------------------------
INT 15 - DESQview v2.00+ - "KMOUSE" - KEYBOARD MOUSE CONTROL
	AX = 102Dh
	BL = subfunction
	     00h determine whether using keyboard mouse
		Return: BL = 00h using real mouse
			     01h using keyboard mouse
	     01h turn keyboard mouse on
	     02h turn keyboard mouse off
--------Q-15102E-----------------------------
INT 15 - DESQview v2.40+ - ALLOCATE SYSTEM MEMORY
	AX = 102Eh
	BX = number of bytes
Return: AX = status
	    0000h successful
		ES:DI -> allocated system memory
	    0001h failed
		ES:DI = 0000h:0000h
Note:	under DV 2.42, this call is identical to AX=1001h
SeeAlso: AX=1001h,AX=1002h,AX=DE0Ch

Format of system memory block header (one paragraph before memory block):
Offset	Size	Description
 00h	WORD	segment of next header or 0000h
 02h	WORD	segment of previous header or 0000h
 04h	WORD	size of block in paragraphs, including header
 06h	BYTE	availability flag (00h in use, 01h free)
--------Q-1511-------------------------------
INT 15 - TopView commands
	AH = 11h
	AL = various (except 17h)
Note:	in DESQview 2.x, these function calls are identical to AH=DEh, so
	  see those below
SeeAlso: AH=DEh
--------T-1511-------------------------------
INT 15 - VMiX - "sys_system" - EXECUTE SHELL SYSTEM COMMANDS
	AH = 11h
	STACK:	DWORD	pointer to ASCIZ string containing a VMiX shell
			request (max len = 127)
Return: AX = status (SYS_OK or SYS_ERROR)
SeeAlso: AH=0Ch"VMiX"
--------T-1511-------------------------------
INT 15 - MultiDOS Plus - TURN OFF AltZ TOGGLE
	AH = 11h
Note:	disables the Alt-Z MultiDOS command/program-selection hotkey
SeeAlso: AH=12h"MultiDOS"
Index:	hotkeys;MultiDOS Plus
--------Q-151117BX0000-----------------------
INT 15 - DESQview v2.20+ - "ASSERTMAP" - GET/SET MAPPING CONTEXT
	AX = 1117h
	BX = 0000h	get current mapping context without setting
	     nonzero	set new mapping context
Return: BX = mapping context in effect before call
	interrupts enabled
Notes:	this function differs from AX = DE17h for DESQview v2.20 through 2.25
	mapping contexts determine conventional-memory addressability; setting
	  a mapping context ensures that the associated program and data areas
	  are in memory for access.  Usable by drivers, TSRs and shared
	  programs.
	caller need not be running under DESQview, but must ensure that the
	  stack in use will not be mapped out by the call
SeeAlso: AX=DE17h,INT 2F/AX=1685h
--------m-1511DE-----------------------------
INT 15 - DESQview - QEXT.SYS - INSTALLATION CHECK
	AX = 11DEh
Return: CF clear if installed
	    AX = segment at which QEXT.SYS is located
Desc:	QEXT.SYS is Quarterdeck's HMA manager for DESQview; more recent
	  versions also implement the XMS standard
Note:	a private entry point may be found by searching the beginning of the
	  returned segment for the signature string
	  "QUARTERDECK EXTENDED MEMORY MANAGER 286"; the word immediately
	  prior to the signature contains the QEXT version number in BCD,
	  and the word prior to that contains the offset within the QEXT
	  code segment of the private entry point
SeeAlso: INT 2F/AX=4310h,INT 67/AH=3Fh

Call private entry point with:
	AH = 00h ???
	AH = nonzero ???
--------T-1512-------------------------------
INT 15 - VMiX - "sys_sleep" - PUT PROCESS TO SLEEP
	AH = 12h
	STACK:	WORD	process ID
Return: AX = status (SYS_OK or SYS_ERROR)
SeeAlso: AH=03h"MultiDOS",AX=101Dh,AH=13h"VMiX"
--------T-1512-------------------------------
INT 15 - MultiDOS Plus - TURN ON AltZ TOGGLE
	AH = 12h
Note:	enables the Alt-Z MultiDOS command/program-selection hotkey
SeeAlso: AH=11h"MultiDOS"
Index:	hotkeys;MultiDOS Plus
--------Q-1512--BH00-------------------------
INT 15 - TopView - SEND MESSAGE - "HANDLE" - RETURN OBJECT HANDLE
	AH = 12h
	BH = 00h
	BL = which handle to return
	    00h handle in DWORD on top of stack
	    01h current task's window handle
	    02h given task's mailbox handle (task's handle on stack)
	    03h current task's mailbox handle
	    04h given task's keyboard handle (task's handle on stack)
	    05h current task's keyboard object handle
	    06h given task's OBJECTQ handle (task's handle on stack)
	    07h current task's OBJECTQ handle
	    08h	  \
	      thru > return 0000:0000 under DV < 2.26
	    10h	  /
	    0Ch (2.26+) task owning object with handle in DWORD on top of stack
	    0Dh (2.26+) task handle of owner (parent) of current task
Return: DWORD on top of stack is object handle
Note:	BL=0Ch,0Dh returns 00000000h if the object is not open (keyboard,
	  mailbox, panel, pointer, and timer objects) or is an orphan (task,
	  window)
SeeAlso: AH=12h/BH=02h,AH=12h/BH=80h
--------Q-1512--BH01-------------------------
INT 15 - TopView - SEND MESSAGE - "NEW" - CREATE NEW OBJECT
	AH = 12h
	BH = 01h
	BL = object type to create
	    00h (DV 2.0x only) handle is DWORD on top of stack
	    01h (DV 2.0x only) use task's window handle
	    02h (DV 2.0x only) given task's mailbox (task's handle on stack)
	    03h (DV 2.0x only) current task's mailbox
	    04h (DV 2.0x only) given task's keyboard (task's handle on stack)
	    05h (DV 2.0x only) current task's keyboard object
	    08h WINDOW class
	    09h MAILBOX class
	    0Ah KEYBOARD class
	    0Bh TIMER object (counts down 32-bit time in 10ms increments)
	    0Fh POINTER object
	    10h PANEL object
	STACK: (if window object or WINDOW class)
	       DWORD address to jump to (no new task if high word == 0)
	       DWORD (reserved) 0 = non-task window, FFFFh = task window
	       DWORD bytes for task's private stack (FFFFh == default of 0100h)
	       DWORD bytes system memory for input buffer for READ/READN
			(0 == none, -1 == default--same as logical window size)
	       DWORD window size, columns
	       DWORD window size, rows
	       DWORD length of window title
	       DWORD address of window title
Return: DWORD on top of stack is new object handle
Notes:	if a new task is created, it is started with
	  AX = BX = SI = DI = BP = 0
	  DX:CX = handle of parent task
	  DS = ES = SS = segment of private stack (and new task's handle)
	new windows are orphans, inherit the colors/hidden status of the
	  creating task's window, and are placed in the upper left hand corner
	  of the screen but not automatically redrawn
	new keyboards are closed, and have all object bits cleared except for
	  the hardware cursor bit
SeeAlso: AH=12h/BH=02h,AH=12h/BH=81h
--------Q-1512--BH02-------------------------
INT 15 - TopView - SEND MESSAGE - "FREE" - FREE AN OBJECT
	AH = 12h
	BH = 02h
	BL = object
	    00h handle in DWORD on top of stack
		window: close window and free
		timer: free timer
		panel: free panel object
		pointer: free pointer
	    01h task's window handle - kills task, never returns
	    02h given task's mailbox (task's handle on top of stack)
	    03h current task's mailbox
	    04h given task's keyboard (task's handle on top of stack)
	    05h current task's keyboard object
Notes:	when a window is freed, its keyboard and pointer objects are freed;
	  task windows also free any mailbox, objectq, and panel objects held
	  by the task and any child tasks
	if the keyboard being freed is the default keyboard for a task, this
	  call is equivalent to CLOSE
	panel and pointer objects are automatically closed if open
SeeAlso: AH=12h/BH=01h,AH=12h/BH=0Dh,AH=12h/BH=82h
--------Q-1512--BH03-------------------------
INT 15 - TopView - SEND MESSAGE - "ADDR" - GET HANDLE OF MESSAGE SENDER
	AH = 12h
	BH = 03h
	BL = object
	    00h mailbox handle in DWORD on top of stack
	    02h sender of last msg read from mailbox (task's handle on stack)
	    03h sender of last msg read from current task's mailbox
Return: DWORD on stack is task handle of message sender
SeeAlso: AH=12h/BH=00h,AH=12h/BH=83h
--------Q-1512--BH03-------------------------
INT 15 - DESQview v2.26+ - "CONNECT" - CONNECT TWO WINDOWS
	AH = 12h
	BH = 03h
	BL = window to be connected
	    00h handle of window to be attached in DWORD on top of stack
	    01h attach current task's main window
	STACK: DWORD handle of window to attach to or 00000000h to detach
Return: STACK popped
Notes:	when two windows are connected, both will move if the user moves either
	multiple windows may be attached to a single window, but each window
	  may only be attached to one window at a time
SeeAlso: AH=12h/BH=83h
--------Q-1512--BX0300-----------------------
INT 15 - TopView - SEND MESSAGE - "DIR" - GET PANEL FILE DIRECTORY
	AH = 12h
	BX = 0300h
	STACK: DWORD handle of panel object
Return: STACK: DWORD length of directory (always multiple of 14 bytes)
	       DWORD address of directory
Note:	a null string is returned if the object is not open
SeeAlso: AH=12h/BX=0400h"APPLY",AH=12h/BH=83h

Format of panel file:
Offset	Size	Description
 00h  2 BYTEs	C0h C3h
 02h	BYTE	number of panels in file
 03h	for each panel in file:
	    8 BYTEs  blank-padded panel name
	      DWORD  panel offset in file
	      WORD   panel length
	data for panels (each consists of one or more window/query/manager
	streams)
	    first byte of each panel must be 1Bh, fifth byte must be E5h
--------Q-1512--BH04-------------------------
INT 15 - TopView - SEND MESSAGE - "READ" - READ NEXT LOGICAL LINE OF WINDOW
	AH = 12h
	BH = 04h
	BL = window to read from
	    00h handle is DWORD on top of stack
	    01h use calling task's default window
	    0Ch (DV 2.26+) default window of task owning handle on top of stack
	    0Dh (DV 2.26+) default window of parent task of current task
Return: STACK:	DWORD number of bytes read
		DWORD address of buffer
Notes:	reading starts at the current logical cursor position; the cursor is
	  updated to point at the character following the last one read
	any translucent blanks (FFh) which are visible on screen are changed
	  to the character which is seen through them
	the string produced by the read is placed in an input buffer which may
	  be reused by the next READ or READN of a window
	window stream opcodes D8h and D9h determine whether the read returns
	  characters or attributes
SeeAlso: AH=12h/BH=05h"WINDOW",AH=12h/BH=12h,AH=12h/BH=84h
--------Q-1512--BH04-------------------------
INT 15 - TopView - SEND MESSAGE - "READ" - GET NEXT RECORD FROM OBJECT
	AH = 12h
	BH = 04h
	BL = object
	    00h handle is DWORD on top of stack
		mailbox: wait for and get next message
		keyboard: wait for and get pointer to next input buffer
		pointer: wait for and get next message
	    02h get next message from mailbox (task's handle on top of stack)
	    03h get next message from current task's mailbox
	    04h get the next input from keyboard (handle on top of stack)
	    05h get the next input from task's default keyboard
	    06h wait for input from any object in OBJECTQ (handle on stack)
	    07h wait for input from any object in task's default OBJECTQ
Return: STACK: (if objectq) DWORD handle of object with input
	       (otherwise)  DWORD number of bytes
			    DWORD address
Notes:	for a keyboard in keystroke mode, the input buffer is a single byte
	  containing the character code as returned by the BIOS; the BIOS scan
	  code is available via the STATUS call if the character is zero
	for a keyboard in field mode, the input buffer format is determined
	  by the field table header for the window the keyboard is attached to
	keyboard input buffers and mailbox message buffers may be invalidated
	  by the next READ, ERASE, CLOSE, or FREE message to the same object
SeeAlso: AH=12h/BH=05h"OBJECT",AH=12h/BH=84h

Format of pointer message:
Offset	Size	Description
 00h	WORD	row
 02h	WORD	column
 04h	BYTE	status
		bit 7: set when press/release mode active and button pressed
		bit 6: set when press/release mode active and button released
		bits 7-2: number of clicks-1 if multiple-click mode active
		bits 1,0: button pressed (00=none,01=button1,10=button2)
 05h	BYTE	field number or zero (APILEVEL >= 2.00 only)
--------Q-1512--BX0400-----------------------
INT 15 - TopView - SEND MESSAGE - "READ" - WAIT FOR TIMER TO EXPIRE
	AH = 12h
	BX = 0400h
	STACK: DWORD timer's handle
Return: after timer expires
	STACK: DWORD time in 1/100 sec after midnight when timer expired
SeeAlso: AH=12h/BH=0Ah,AH=12h/BH=84h
--------Q-1512--BX0400-----------------------
INT 15 - TopView - SEND MESSAGE - "APPLY" - WRITE PANEL TO WINDOW
	AH = 12h
	BX = 0400h
	STACK: DWORD handle of panel object
	       DWORD window's handle (or 0 for current task's window)
	       DWORD length of panel name
	       DWORD pointer to panel name
Return: STACK: DWORD handle of window which was used
	       DWORD handle of keyboard or 0
Notes:	status of APPLY may be checked with STATUS message
	panel MUST have the following format
	  first byte must be 1Bh (i.e. must start with a stream)
	  first opcode in stream must be E5h
	    single byte arg of opcode is interpreted thus:
	      bits 7,6	11 means create new window
			10 means create new field table for existing window
			01 means use existing window and field table
	      bit 5 if set, panel contains a field table
			(creates a new keyboard and puts it in field mode)
	      bit 4 if set, panel contains input fields
	      bit 3 if set, panel contains select fields but no input fields
	if the panel contains input or select fields, a keyboard handle is
	  returned; either the window's current open keyboard or a
	  newly-created keyboard object.  The caller should read that keyboard
	  to obtain input from the panel.
SeeAlso: AH=12h/BH=84h
--------Q-1512--BH05------------------------
INT 15 - TopView - SEND MESSAGE - "WRITE" - WRITE TO OBJECT
	AH = 12h
	BH = 05h
	BL = object
	    00h handle is DWORD on top of stack
		timer: start timer to end at a specified time
		keyboard: add input buffer to queue
		pointer: move pointer icon to specified position
	    02h send message by value/status=0 to mbox (task's handle on stack)
	    03h send message by value/status=0 to current task's mailbox
	    04h add input buffer to KEYBOARD queue (handle on top of stack)
	    05h add input buffer to task's default KEYBOARD queue
	    06h add an object to OBJECTQ (handle on top of stack)
	    07h add an object to task's default OBJECTQ
	STACK: (if mailbox)  DWORD length
			     DWORD address
	       (if keyboard) DWORD status (scan code in keystroke mode)
			     DWORD length (should be 1 in keystroke mode)
			     DWORD address
	       (if objectq)  DWORD handle of object to add
	       (if timer)    DWORD 1/100ths seconds since midnight (actually
				   only accurate to 1/18 sec)
	       (if pointer)  DWORD column relative to origin of window
			     DWORD row relative to origin of window
Notes:	under DV 2.2+, failed mailbox writes may return CF set (see AX=DE15h)
	the data and status written to a keyboard object must match the format
	  returned by the keyboard object in the current mode
	the pointer position is scaled according to the current scaling factors
SeeAlso: AH=12h/BH=04h,AH=12h/BH=85h
--------Q-1512--BH05-------------------------
INT 15 - TopView - SEND MESSAGE - "WRITE" - WRITE STRING TO WINDOW
	AH = 12h
	BH = 05h
	BL = window to write to
	    00h DWORD on top of stack is window handle
	    01h write string to task's default window
	    0Ch (DV 2.26+) default window of task owning handle on top of stack
	    0Dh (DV 2.26+) default window of parent of current task
	STACK: DWORD object handle if handle passed on stack
	       DWORD total length of string (high word == 0)
	       DWORD address of string to display
Return: indicated actions performed
	a. non-control characters are displayed (opcodes DEh and DFh control
	   whether the attributes are left or changed to the current attrib)
	b. CR/LF/BS/Tab cause the usual cursor movement
	c. ESC starts a data structure with additional commands if following
	   byte is less than 20h; otherwise, it is written to the window
	STACK:	DWORD handle of new window if window stream opcode E6h
		else nothing
SeeAlso: AH=12h/BH=04h,AH=12h/BH=85h

Data Structure:
	MAGIC  DB  1Bh
	MODE   DB  ?   ; 00h, 01h, 10h, 14h-1Fh legal
	LENGTH DW  ?   ; length of remainder in bytes
	var-length fields follow, each an OPCODE followed by
	     zero or more args

MODE 00h (set or display values) "WINDOW STREAM"
    Opcodes:args
	00h  display 20h blanks with the default attribute
	01h-1Fh display OPCODE blanks with the default attribute
	20h  display char with default attribute 20h times
	     BYTE char to repeat
	21h-3Fh display char with default attribute OPCODE-20h times
	     BYTE char to repeat
	40h  display 20h blanks with specified attribute
	     BYTE attribute of blanks
	41h-5Fh display OPCODE-40h blanks with specified attribute
	     BYTE attribute of blanks
	60h  display next 20h characters
	     20h BYTEs characters to display
	61h-7Fh display next OPCODE-60h characters
	     N BYTEs characters to display
	80h-87h	 display N blanks with default attribute
	     BYTE low 8 bits of 11-bit count (high 3 in low 3 bits of OPCODE)
		      [000h means 800h]
	88h-8Fh display N copies of the character
	     BYTE low 8 bits of 11-bit count (high 3 in low 3 bits of OPCODE)
		      [000h means 800h]
	     BYTE character to repeat
	90h-97h	 display N blanks with specified attribute
	     BYTE low 8 bits of 11-bit length (high 3 in low 3 bits of OPCODE)
		      [000h means 800h]
	     BYTE attribute
	98h-9FH	 display string at logical cursor pos
	     BYTE low 8 bits of 11-bit length (high 3 in low 3 bits of OPCODE)
		      [000h means 800h]
	     N BYTEs string to display
	A0h  set logical cursor row
	     BYTE row number (0 is top)
	A1h  set logical cursor column
	     BYTE column number (0 is leftmost)
	A2h  set top edge of scrolling region
	     BYTE row
	A3h  set left edge of scrolling region
	     BYTE column
	A4h  set row of physical window position
	     BYTE line
	A5h  set column of physical window position
	     BYTE column
	A6h  set height of physical window
	     BYTE #rows
	A7h  set width of physical window
	     BYTE #columns
	A8h  set viewport row
	     BYTE row
	A9h  set viewport column
	     BYTE column
	AAh  set virtual screen height [contents of window unpredictable after]
	     BYTE rows
	ABh  set virtual screen width [contents of window unpredictable after]
	     BYTE columns
	ACh-AEh	 unused
	AFh  set compatible/preferred video modes
	     BYTE compatibility/preference mask
		bit 7	compatible with monochrome
		bit 6	compatible with color text, EGA/VGA graphics
		bit 5	compatible with medium-resolution CGA graphics
		bit 4	compatible with high-resolution CGA graphics
		bit 3	prefer monochrome
		bit 2	prefer color text, EGA/VGA graphics
		bit 1	prefer medium-resolution CGA graphics
		bit 0	prefer high-resolution CGA graphics
	B0h  move logical cursor down
	     BYTE #rows (signed, negative values move up)
			[if #rows=0 and hardware cursor owner, update hw crsr]
	B1h  move logical cursor right
	     BYTE #cols (signed, negative values move left)
			[if #cols=0 and hardware cursor owner, update hw crsr]
	B2h  shift top edge of scrolling region
	     BYTE #rows (signed)
	B3h  shift left edge of scrolling region
	     BYTE #cols (signed)
	B4h  shift physical window down
	     BYTE #lines (signed)
	B5h  shift physical window right
	     BYTE #columns (signed)
	B6h  expand physical window vertically
	     BYTE #lines (signed)
	B7h  expand physical window horizontally
	     BYTE #columns (signed)
	B8h  adjust viewport row
	     BYTE #rows (signed)
	B9h  adjust viewport column
	     BYTE #columns (signed)
	BAh  adjust virtual screen height [contents of window unpredict after]
	     BYTE #rows to increase (signed)
	BBh  adjust virtual screen width [contents of window unpredictbl after]
	     BYTE #cols to increase (signed)
	BCh-BFh	 reserved (currently unused)
	C0h  set logical cursor position
	     BYTE row number (0 is top border)
	     BYTE column number (0 is left border)
	C1h  set top left corner of scrolling region
	     BYTE row
	     BYTE column
	C2h  set physical window pos
	     BYTE upper left row (no top border if 0)
	     BYTE upper left column (no left border if 0)
	C3h  set current window size
	     BYTE #rows
	     BYTE #cols
	C4h  set upper left corner of viewport (portion of virtual screen
	     displayed in window)
	     BYTE row
	     BYTE column
	C5h  set size of virtual screen [contents unpredictable afterwards]
	     BYTE #rows
	     BYTE #cols
	C6h  unused
	C7h  unused
	C8h  set logical cursor relative to current position
	     BYTE number of rows to move down (signed)
	     BYTE number of columns to move right (signed)
		  [if #rows=#cols=0 and hardware cursor owner, update hw cursr]
	C9h  shift top left corner of scrolling region
	     BYTE #rows (signed)
	     BYTE #cols (signed)
	CAh  set window pos relative to current position
	     BYTE number of rows to shift down (signed)
	     BYTE number of columns to shift right (signed)
	CBh  set window size relative to current size
	     BYTE number of rows to expand (signed)
	     BYTE number of cols to expand (signed)
	CCh  shift viewport relative to current position
	     BYTE rows to shift (signed)
	     BYTE cols to shift (signed)
	CDh  resize virtual screen
	     BYTE #rows to expand (signed)
	     BYTE #cols to expand (signed)
	CEh  scroll text when using E8h-EBh/F8h-FBh opcodes (default)
	CFh  scroll attributes when using  E8h-EBh/F8h-FBh opcodes
	D0h  allow window frame to extend beyond screen
	D1h  always display a complete frame, even if window extends beyond
	     edge of screen
	D2h  allow DV to change logical colors on video mode switch (default)
	D3h  application changes logical attributes
	D4h  window is visible [must redraw to actually make visible]
	D5h  window is hidden [must redraw to actually remove]
	D6h  window has frame (default)
	D7h  window unframed [must redraw to actually remove frame]
	D8h  READ/READN will read characters from window (default)
	D9h  READ/READN will read attributes from window
	DAh  use logical attributes, which may be remapped
		attributes
		   1 normal text
		   2 highlighted normal text
		   3 help text
		   4 highlighted help text
		   5 error message
		   6 highlighted error message
		   7 emphasized text
		   8 marked text
		   9-16 are reverse video versions of 1-8
	DBh  use physical attributes for characters
	DCh  enable special actions for control characters (default)
	DDh  disable special control char handling, all chars displayable by
	     BIOS TTY call
	DEh  write both character and attribute (default)
	DFh  write character only, leave attribute untouched
	E0h  repeat following commands through E1h opcode
	     BYTE number of times to repeat (00h means 256 times)
	E1h  end of commands to repeat, start repeating them
	E2h  set current output color
	     BYTE color
	E3h  clear virtual screen from scroll origin to end using current color
	E4h  redraw window
	E5h  select menu style
	     BYTE style (normally 18h)
		bits 5,4 = 01 use two-letter menu entries for remainder of
		  this stream
	E5h  (panel file only)
	     BYTE modifier
		bits 7,6 = 11 panel stream creates new window
			 = 10 panel defines new field table for existing window
			 = 01 panel stream uses existing window & field table
		bit 5 = 1 stream contains a field table (create kyboard object)
		bit 4 = 1 stream defines input fields (create keyboard object)
		bit 3 = 1 stream defines select fields but not input fields
		bit 2 = 1 stream defines exclusive input window (DV 2.2)
		bit 1 reserved
		bit 0 reserved
	E6h  create new window and perform rest of manipulations in new window
	     BYTE number of rows
	     BYTE number of columns
	     Return: DWORD object handle of new window returned on stack at end
	     Note: the window is created with a physical size of 0x0 at the
		     same position as the window to which this stream was sent
	E7h  no operation
	E8h  scroll area up (top left corner defined by opcode C1h)
	     BYTE height
	     BYTE width
	E9h  scroll area down (top left corner defined by opcode C1h)
	     BYTE height
	     BYTE width
	EAh  scroll area left (top left corner defined by opcode C1h)
	     BYTE height
	     BYTE width
	EBh  scroll area right (top left corner defined by opcode C1h)
	     BYTE height
	     BYTE width
	ECh  set logical attributes for window contents
	     BYTE video modes command applies to
		bit 7	monochrome
		bit 6	color text, EGA/VGA graphics
		bit 5	medium-resolution CGA graphics
		bit 4	high-resolution CGA graphics
	     BYTE which attributes to set
		bit 7  if set, copy single following byte to indicated attribs
		bits 4-6  # of first attribute to change - 1
		bits 0-3  # of consecutive attributes to change
	     N BYTEs new attributes
	EDh  set logical attributes for window frame
	     BYTE video modes command applies to (see opcode ECh)
	     BYTE which attributes to set
		bit 7  if set, copy single following byte to indicated attrs
		bits 4-6  # of first attribute to change - 1
		bits 0-3  # of consecutive attributes to change
	     N BYTEs new attributes
		  attributes
		       1 = top left corner
		       2 = top right corner
		       3 = bottom left corner
		       4 = bottom right corner
		       5 = top edge
		       6 = bottom edge
		       7 = left edge
		       8 = right edge
	EEh  set characters for window frame
	     BYTE video modes command applies to (see opcode ECh)
	     BYTE which characters to set
		bit 7  if set, copy single following byte to indicated chars
		bits 4-6  # of first char to change - 1
		bits 0-3  # of consecutive chars to change
	     N BYTEs new chars (same relative position as attributes above)
	EFh  set window name
	     BYTE length of name (should be in range 0 to logical screen width)
	     N BYTEs name
	F0h  clear input field to blanks
	     BYTE field number
	F1h  fill input field with character
	     BYTE field number
	     BYTE char
	F2h  set color of input field
	     BYTE field number (1-N)
	     BYTE attribute
	F3h  set initial contents of input field
	     BYTE field number (1-N)
	     N BYTEs enough chars to exactly fill field as defined by op FFh
	F4h  position cursor to start of specific input field
	     BYTE field number (1-N)
	F5h  change field table entry
	     BYTE field number
	     7-8 BYTEs field table entry (see opcode FFh below)
	F6h  set field type
	     BYTE field number
	     BYTE type
			00h inactive
			40h output field
			80h input field
			C0h deselected field
			C2h selected field
	F7h  "broadcast write"	write data to fields with program output bit
		set in field table entry, in field number order
	     N BYTEs (total length of all program output fields)
	F8h  scroll field up a line
	     BYTE field number
	F9h  scroll field down a line
	     BYTE field number
	FAh  scroll field left
	     BYTE field number
	FBh  scroll field right
	     BYTE field number
	FCh  set field table header
	     BYTE number of fields (must be <= existing number of fields)
	     BYTE screen behavior bits
		bit 7  reserved
		bit 6  set if menu items may be selected via keyboard
		bit 5  set if left mouse button in "status" mode (press
			anywhere in window immediately returns control to app)
		bit 4  set if right mouse button in "status" mode
		bit 3  if set, select fields return contents or blanks rather
			than 'Y' or 'N'
		bit 2  if set, modified bits reset on return to application
		bits 0,1 = 00 no data returned on read of keyboard
			   01 data returned as array of chars containing
				all fields packed together, with no field
				numbers
			   10 data returned as numbered variable-length
				records for all fields
			   11 data returned as numbered variable-length
				records for the fields which were modified
	     BYTE current input field (updated by DESQview)
	     BYTE current select field (updated by DESQview)
	     BYTE attribute for select fields when they are pointed at
	     BYTE attribute for select fields which have been selected
	FDh  reset modified bit for all fields
	FEh  reset selected and modified bits for all fields
	FFh  set up input fields
	     6 BYTEs table header (see opcode FCh above)
	     the field table entries, one for each field
		 BYTE start row	   \
		 BYTE start column  \ if menu selection and start is to
		 BYTE end row	    / right or below end, select from kbd only
		 BYTE end column   /
		 BYTE field type
		    bits 7,6 = 00 inactive (non-entry) field
			       01 echos keystrokes input to make menu selection
			       10 fill-in field
			       11 select field
		    bit 5  field can be filled by broadcast write (F7h opcode)
		    bit 4  reserved
		    bit 3  reserved
		    bit 2  reserved
		    bit 1  set if field selected
		    bit 0  set if field modified
		 BYTE modifier
		      if type is fill-in, then bit flags to determine behavior
			  bit 7	 if set, automatically enter CR when field full
			  bit 6	 move to next field when current field is full
			  bit 5	 if set, enter text from right end (for numbers)
			  bit 4	 if set, force input to uppercase
			  bit 3	 if set, clear old contents on first keystroke
			  bit 2	 if set, input returned when cursor moves out
				 of modified field ("validate",API level 2.02+)
			  bit 1	 reserved
			  bit 0	 reserved
		      if select field, first key to press to activate
			  00h if have to point-&-click or is an extended-ASCII
			      keystroke (only if two-key menus enabled)
		 BYTE (select field only) normal color of field
		 BYTE second key for select field.  This byte is present iff
		      two-letter menu entries selected with opcode E5h, and
		      in that case is present regardless of field type
	     Note: DESQview uses and updates the actual copy of the information
	       which is contained in the stream.  Thus this info must remain
	       intact until after the data entry is complete.

MODE 01h "QUERY STREAM" (valid only for those opcodes listed here)
	A0h return logical cursor row in next byte
	A1h return logical cursor column in next byte
	A2h return top row of scrolling region in next byte
	A3h return left column of scrolling region in next byte
	A4h return row of physical window origin in next byte
	A5h return column of physical window origin in next byte
	A6h return height of physcial window in next byte
	A7h return width of physical window in next byte
	A8h return row of viewport origin in next byte
	A9h return column of viewport origin in next byte
	AAh return height of virtual screen in next byte
	ABh return width of virtual screen in next byte
	AFh return current video mode in next byte
	C0h return current logical cursor position in next two bytes
	C1h return top left corner of scrolling region in next two bytes
	C2h return current window position in next two bytes
	C3h return current window size in next two bytes
	C4h return current viewport origin in next two bytes
	C5h return current virtual screen size in next two bytes
	D0h \ overwritten with D0h if frames may fall off screen edge
	D1h /		       D1h if frames always displayed entirely
	D2h \ overwritten with D2h if DESQview controls color palette
	D3h /		       D3h if application changes color palette
	D4h \ overwritten with D4h if window visible
	D5h /		       D5h if window hidden
	D6h \ overwritten with D6h if window has frame
	D7h /		       D7h if window unframed
	D8h \ overwritten with D8h if reading characters from window
	D9h /		       D9h if reading attributes from window
	DAh \ overwritten with DAh if using logical attributes
	DBh /		       DBh if using physical attributes
	DCh \ overwritten with DCh if TTY control char interpretation on
	DDh /		       DDh if TTY control char interpretation off
	DEh \ overwritten with DEh if writing both characters and attributes
	DFh /		       DFh if leaving attributes untouched
	E2h return current color in next byte
	ECh get logical attributes for window contents
	    BYTE execute call if currently in specified video mode
		bit 7	monochrome
		bit 6	color text, EGA/VGA graphics
		bit 5	medium-resolution CGA graphics
		bit 4	high-resolution CGA graphics
	    BYTE which attributes to get
		bit 7 unused???
		bits 4-6 first attribute to get - 1
		bits 0-3 # consecutive attributes
	    N BYTEs buffer to hold attributes
	EDh get logical attributes for window frame
	    BYTE execute call if currently in video mode (see opcode ECh)
	    BYTE which attributes to get
		bit 7 unused???
		bits 4-6 first attribute to get - 1
		bits 0-3 # consecutive attributes
	    N BYTEs buffer to hold attributes
	EEh get characters for window frame
	    BYTE execute call if currently in video mode (see opcode ECh)
	    BYTE which attributes to get
		bit 7 unused???
		bits 4-6 first char to get - 1
		bits 0-3 # consecutive chars
	    N BYTEs buffer to hold chars
	EFh return first N characters of current window name
	    BYTE    max length of returned name
	    N BYTEs buffer to hold window name
	F3h return contents of specified field
	    BYTE field number
	    N BYTEs buffer to hold field contents (size exactly equal to field
		    size)
	F5h get field table entry
	    BYTE field number
	    7-8 BYTEs buffer to hold field table entry
	       Notes: DV < 2.26 always returns 7 bytes
		      DV 2.26+ w/ APILEVEL < 2.26 returns 8 bytes iff field
			table is using 8-byte entries and eighth byte after
			F5h is E7h (NOP); otherwise, 7 bytes are returned
		      DV 2.26+ w/ APILEVEL > 2.26 returns 7 or 8 bytes
			depending on the field table entry size
	F6h get type of a field
	    BYTE field number
	    BYTE type
	FCh get field table header
	    6 BYTEs buffer to store header

MODE 10h "MANAGER STREAM" (valid only for opcodes listed here)
	00h allow window to be moved horizontally
	01h allow window to be moved vertically
	02h allow window to change width
	03h allow window to change height
	04h allow window to be scrolled horizontally
	05h allow window to be scrolled vertically
	06h allow "Close Window" menu selection for application
	07h allow "Hide Window" menu selection for application
	08h allow application to be suspended ("Rearrange/Freeze")
	0Eh allow "Scissors" menu
	10h allow DESQview main menu to be popped up
	11h allow "Switch Windows" menu
	12h allow "Open Window" menu
	13h allow "Quit" menu selection
	20h-33h opposite of 00h-13h, disallow specified action
	40h notify if horizontal position of window changes
	41h notify if vertical position of window changes
	42h notify if width of window changes
	43h notify if height of window changes
	44h notify if window scrolled horizontally
	45h notify if window scrolled vertically
	46h notify if window is closed--program has to clean up and exit itself
	47h notify if window is hidden
	48h notify if "?" on main menu selected
	49h notify if pointer message sent to window
	4Ah notify if window is placed in foreground
	4Bh notify if window is placed in background
	4Ch notify if video mode changes
	4Dh notify if "Scissors" menu "Cut" option selected
	4Eh notify if "Scissors" menu "Copy" option selected
	4Fh notify if "Scissors" menu "Paste" option selected
	50h notify if DESQview main menu about to pop up
	51h notify if DESQview main menu popped down
	60h-71h	 opposite of 40h-51h: don't notify on specified event
	84h attach window to parent task's window (both move together)
	85h detach window from parent task's window (may move independently)
	86h disable background operation for application
	87h enable running in background
	88h set minimum size of physical window
	    BYTE rows
	    BYTE columns
	89h set maximum size of physical window
	    BYTE rows
	    BYTE cols
	8Ah set primary asynchronous notification routine
	    DWORD address of routine, 0000h:0000h means none (see also below)
	8Bh set async notification parameter
	    DWORD 32-bit value passed to 8Ah async routine in DS:SI
	ACh (DV2.2+) perform regular select field attribute processing
	ADh (DV2.2+) protect attributes in selected field from being lost
	AEh make window default notify window for owning app (API level 2.00+)
	AFh set selected field marker character
	    BYTE character to display at left edge of selected fields
	BCh set standard field processing mode
	BDh set alternate field processing mode (enables cursor pad for menus)
	BEh disables changing reverse logical attributes with ECh opcode
	BFh enables changing reverse logical attributes with ECh opcode
	C0h make current window topmost in system
	C1h force current process into foreground
	C2h make current window topmost in process
	C3h position mouse pointer relative to origin of current field
	    BYTE rows below upper left corner of field
	    BYTE columns to right of upper left corner of field
	C4h position mouse pointer relative to origin of given field
	    BYTE field number
	    BYTE rows below upper left corner of field
	    BYTE columns to right of upper left corner of field
	C5h orphan current window (also hides it)
		Note: must be last in stream; all subsequent commands ignored
	C6h show all windows for this process
	C7h hide all windows for this process
	C8h suspend process and hide all its windows
	C9h force current process into background
	CAh make current window bottom-most in process
	CBh cancel current window manager operation, remove DV menu, give
	    control to topmost application
	CCh orphan window and give it to the system for use as paste data
	CEh reorder windows
	    DWORD pointer to null-terminated list of words
		  each word is segment of object handle for a window
	FFh no operation

MODES 14h to 1Fh "USER STREAMS"
	normally NOPs, but may be defined by SETESC message to invoke FAR
	routines, one for each mode number
	  on entry to handler,
		DS:SI -> first byte of actual stream (not header)
		CX = #bytes in stream
		ES:DI = window's handle

Asynchronous notification routine defined by manager stream 8Ah called with:
	ES:DI = handle of window
	DS:SI is 32-bit value set by 8Bh manager stream opcode
	   mailbox contains message indicating event
	      Opcode
	       40h  horizontal movement
		   DWORD object handle of window
		   BYTE	 new row
		   BYTE	 new col
	       41h  vertical movement
		   DWORD object handle of window
		   BYTE	 new row
		   BYTE	 new col
	       42h  horizontal size change
		   DWORD object handle of window
		   BYTE	 new rows
		   BYTE	 new cols
	       43h  vertical size change
		   DWORD object handle of window
		   BYTE	 new rows
		   BYTE	 new cols
	       44h  scrolled horizontally
		   DWORD object handle of window
		   BYTE	 mouse row within window
		   BYTE	 mouse column within window
		   BYTE	 field mouse is on, 0 if none
		   BYTE	 amount moved: >0 right, <0 left, 0 done
	       45h  scrolled vertically
		   DWORD object hande of window
		   BYTE	 mouse row within window
		   BYTE	 mouse column within window
		   BYTE	 field mouse is on, 0 if none
		   BYTE	 amount moved: >0 down, <0 up, 0 done
	       46h  window close request
		   DWORD object handle of window
		   BYTE	 mouse pointer row
		   BYTE	 mouse pointer column
		   BYTE	 field mouse is on, 0 if none
	       47h  application's windows hidden
	       48h  Help for Program selected
		   DWORD object handle of window
		   BYTE	 mouse pointer row
		   BYTE	 mouse pointer column
		   BYTE	 field mouse is on, 0 if none
	       49h  pointer message sent to window
		   DWORD pointer handle which received message
	       4Ah  switched to window from another ("raise")
	       4Bh  switched away from the window ("lower")
	       4Ch  video mode changed
		   BYTE new BIOS video mode
	       4Dh  Scissors/cUt selected
		   DWORD object handle of window
		   BYTE	 row of upper left corner
		   BYTE	 column of upper left corner
		   BYTE	 field number ul corner is in, 0=none
		   DWORD handle of orphaned window created with
			 copy of data from specified region
		   BYTE	 height of region
		   BYTE	 width of region
	       4Eh  Scissors/Copy selected
		   DWORD object handle of window
		   BYTE	 row of upper left corner
		   BYTE	 column of upper left corner
		   BYTE	 field number ul corner is in, 0=none
		   DWORD handle of orphaned window created with
			 copy of data from specified region
		   BYTE	 height of region
		   BYTE	 width of region
	       4Fh  Scissors/Paste selected
		   DWORD object handle of window
		   BYTE	 row of upper left corner
		   BYTE	 column of upper left corner
		   BYTE	 field number ul corner is in, 0=none
		   DWORD handle of orphaned window with data
		   BYTE	 height of region
		   BYTE	 width of region
			Note: orphaned data window should be adopted or freed
				when done
	       50h  main menu about to pop up
	       51h  main menu popped down
Return: all registers unchanged
--------Q-1512--BH06-------------------------
INT 15 - DESQview 2.20+ - SEND MESSAGE - "SETPRI" - SET PRIORITY WITHIN OBJECTQ
	AH = 12h
	BH = 06h
	BL = object
	    00h object handle in DWORD on top of stack
		mailbox, keyboard, pointer, or timer
		(DV 2.50+) window
	    01h (DV 2.50+) current task's window
	    04h given task's keyboard (task's handle on top of stack)
	    05h current task's default keyboard
	STACK: DWORD new priority of object in task's OBJECTQ
			(new priority of task if window handle)
Notes:	initially all objects have the same default value.  Should only make
	  relative adjustments to this default value.
	when changing priorities, all objects already on the objectq are
	  reordered
	for window handles, only the non-blocked task(s) with the highest
	  priority receive CPU time under DESQview 2.50-2.52; the default
	  priority is 0Ah
SeeAlso: AH=12h/BH=07h,AH=12h/BH=87h
--------Q-1512--BH07-------------------------
INT 15 - DESQview 2.20+ - SEND MESSAGE - "GETPRI" - GET PRIORITY WITHIN OBJECTQ
	AH = 12h
	BH = 07h
	BL = object
	    00h object handle in DWORD on top of stack
		mailbox, keyboard, pointer, or timer
		(DV 2.50+) window
	    01h (DV 2.50+) current task's window
	    04h given task's keyboard (task's handle on top of stack)
	    05h current task's default keyboard
Return: STACK: DWORD object priority
Note:	initially all objects have the same default value.  Should only make
	  relative adjustments to this default value.
SeeAlso: AH=12h/BH=06h
--------Q-1512--BH08-------------------------
INT 15 - TopView - SEND MESSAGE - "SIZEOF" - GET OBJECT SIZE
	AH = 12h
	BH = 08h
	BL = object
	    00h handle in DWORD on top of stack
		window: total character positions in window
		timer: elapsed time since timer started
		pointer: number of messages queued to pointer object
		panel: number of panels in panel file
		keyboard: number of input buffers queued
	    01h total chars in current task's default window
	    02h number of messages in task's mailbox (task's handle on stack)
	    03h number of messages in current task's mailbox
	    04h number of input buffers queued in task's kbd (handle on stack)
	    05h number of input buffers queued for current task's default kbd
	    06h number of objects queued in OBJECTQ (task's handle on stack)
	    07h number of objects queued in current task's OBJECTQ
	    0Ch (DV 2.26+) total chars in window owning handle on top of stack
	    0Dh (DV 2.26+) total chars in parent task's window
Return: DWORD on top of stack is result
Note:	for panel objects, a count of zero is returned if no panel file is open
	  for the object
SeeAlso: AH=12h/BH=04h,AH=12h/BH=09h
--------Q-1512--BH09-------------------------
INT 15 - TopView - SEND MESSAGE - "LEN" - GET OBJECT LENGTH
	AH = 12h
	BH = 09h
	BL = object
	    00h handle in DWORD on top of stack
		window: get chars/line
		timer: get 1/100 seconds remaining before timer expires
		mailbox: (DV/X) get number of bytes queued to mailbox
	    01h get number of chars/line in current task's default window
	    0Ch (DV 2.26+) get chars/line in window owning handle on top of stk
	    0Dh (DV 2.26+) get chars/line in parent task's window
Return: DWORD on top of stack is length
SeeAlso: AH=12h/BH=08h
--------Q-1512--BH0A-------------------------
INT 15 - TopView - SEND MESSAGE - "ADDTO" - WRITE CHARS AND ATTRIBS TO WINDOW
	AH = 12h
	BH = 0Ah
	BL = window to write to
	    00h window handle is DWORD on top of stack
	    01h current task's default window
	    0Ch (DV 2.26+) default window of task owning handle on top of stack
	    0Dh (DV 2.26+) default window of parent of current task
	STACK:	DWORD count of attributes
		DWORD address of attribute string
		DWORD count of characters
		DWORD address of character string
Notes:	if one string is longer than the other, the shorter one will be reused
	  until the longer one is exhausted
	the cursor is left just after the last character written
SeeAlso: AH=12h/BH=0Bh"WINDOW"
--------Q-1512--BH0A-------------------------
INT 15 - TopView - SEND MESSAGE - "ADDTO" - SEND MAILBOX MESSAGE/STAT BY VALUE
	AH = 12h
	BH = 0Ah
	BL = mailbox to write to
	    00h handle is DWORD on top of stack
	    02h default mailbox of task whose handle is on top of stack
	    03h current task's default mailbox
	STACK:	DWORD	status (low byte)
		DWORD	length of message
		DWORD	address of message
Notes:	the message is copied into either system or common memory
	insufficient memory normally causes the process to be aborted; under
	  DESQview 2.2+, failed writes may return CF set instead (see AX=DE15h)
SeeAlso: AH=12h/BH=0Bh"MAILBOX"
--------Q-1512--BH0A-------------------------
INT 15 - TopView - SEND MESSAGE - "ADDTO" - SET OBJECT BITS
	AH = 12h
	BH = 0Ah
	BL = object
	    00h handle is DWORD on top of stack
		timer: start timer for specified interval
		pointer: set control flags
		keyboard: set control flags
	    04h set control flags on KEYBOARD object (handle on top of stack)
	    05h set control flags on task's default KEYBOARD object
	STACK: (if timer)   DWORD duration in 1/100 seconds
	       (otherwise)  DWORD bits to set
SeeAlso: AH=12h/BH=0Bh"OBJECT"

For keyboard objects, the bits have the following significance:
	bit 15 reserved, can't be set
	bit 14 unused
	bit 13 reserved, can't be set
	bit 12-6 unused
	bit 5  (DV 2.2+) exclusive input
	bit 4  filter all keys (used with handler established by SETESC)
		if 0, only keys that would normally be displayed are filtered
	bit 3  program continues executing while input in progress
	bit 2  insert mode active for field mode
	bit 1  hardware cursor displayed when task is hardware cursor owner
		must be set if keyboard in field mode and field table includes
		input fields
	bit 0  keyboard is in field mode rather than keystroke mode

For pointer objects, the bits have the following significance:
	bit 15 reserved, can't be set
	bit 14-8 unused
	bit 7  mouse pointer is hidden while in window
	bit 6  get messages even if window not topmost
	bit 5  get messages even if window not foreground
	bit 4  multiple clicks separated by less than 1/3 second are counted
		and returned in a single message
	bit 3  pointer position is relative to screen origin, not window origin
	bit 2  send message on button release as well as button press
	bit 1  (DV 2.23+) send message with row=FFFFh and col=FFFFh whenever
		pointer leaves the window
	bit 0  send message only on button activity, not movement
	       DV-specific, and INT 15/AX=DE0Fh must have been called first
--------Q-1512--BH0B-------------------------
INT 15 - TopView - SEND MESSAGE - "SUBFROM" - WRITE ATTRIBUTES TO WINDOW
	AH = 12h
	BH = 0Bh
	BL = window to write attributes to
	    00h handle is DWORD on top of stack
	    01h current task's default window
	    0Ch (DV 2.26+) default window of task owning handle on top of stack
	    0Dh (DV 2.26+) default window of parent of current task
	STACK:	DWORD number of attributes to write
		DWORD address of attributes
Note:	the attributes are written starting at the current cursor position; the
	  cursor is left just after the last position written
SeeAlso: AH=12h/BH=0Ah"WINDOW"
--------Q-1512--BH0B-------------------------
INT 15 - TopView - SEND MESSAGE - "SUBFROM" - SEND MAILBOX MESSAGE/STAT BY REF
	AH = 12h
	BH = 0Bh
	BL = mailbox to write to
	    00h handle is DWORD on top of stack
	    02h default mailbox of task whose handle is on top of stack
	    03h current task's default mailbox
	STACK:	DWORD	status (low byte)
		DWORD	length of message
		DWORD	address of message
Notes:	only a pointer to the message is stored, but the write may still fail
	  due to insufficient memory
	under DV 2.2+, failed mailbox writes may return CF set (see AX=DE15h)
SeeAlso: AH=12h/BH=0Ah"MAILBOX"
--------Q-1512--BH0B-------------------------
INT 15 - TopView - SEND MESSAGE - "SUBFROM" - REMOVE OBJECT FROM OBJECTQ
	AH = 12h
	BH = 0Bh
	BL = OBJECTQ from which to remove all copies of a particular object
	    06h OBJECTQ of task whose handle is on top of stack
	    07h task's default OBJECTQ
	STACK:	DWORD	handle of object to remove
Note:	should be sent whenever an object is erased or closed
--------Q-1512--BH0B-------------------------
INT 15 - TopView - SEND MESSAGE - "SUBFROM" - RESET OBJECT BITS
	AH = 12h
	BH = 0Bh
	BL = object
	    00h handle is DWORD on top of stack
		pointer: reset control flags
		keyboard: reset control flags
	    04h clear control flags on KEYBOARD object (handle on top of stack)
	    05h clear control flags on task's default KEYBOARD object
	STACK:	DWORD	which bits to clear (see AH=12h/BH=0Ah"OBJECT")
SeeAlso: AH=12h/BH=0Ah"OBJECT"
--------Q-1512--BH0C-------------------------
INT 15 - TopView - SEND MESSAGE - "OPEN" - OPEN OBJECT
	AH = 12h
	BH = 0Ch
	BL = object
	    00h handle is DWORD on top of stack
		window:	  fill with given character from scroll origin to end
		keyboard: attach to a window
		timer:	  open
		pointer:  start taking input for window
		panel:	  associate with a panel file
	    01h fill task's default window with given char from scrl org to end
	    02h open given task's mailbox for input (task's handle on stack)
	    03h open current task's mailbox
	    04h attach a KEYBOARD to a window (handle on top of stack)
	    05h attach task's default KEYBOARD to a window
	    06h open a task's OBJECTQ (task's handle on top of stack)
	    07h open current task's OBJECTQ
	    0Ch (DV 2.26+) fill def window of task owning handle on top of stck
	    0Dh (DV 2.26+) fill default window of parent of current task
	 STACK: (if window)   DWORD character to fill with
		(if keyboard) DWORD handle of window to attach to
		(if pointer)  DWORD handle of window to attach to
		(if panel)    DWORD length of filename or resident panel
			      DWORD address of filename or resident panel
		(otherwise)   nothing
Notes:	if first byte of panel file name is 1Bh, then the "name" IS a panel
	if first two bytes of panel file "name" are C0hC3h, then the "name" IS
	  the panel file
	result code of open may be retrieved with STATUS message
	logical cursor is left at scroll origin after filling window
	the task opening a mailbox becomes its owner, and the only task allowed
	  to read the mailbox
	messages are only sent to a pointer object when the mouse is positioned
	  in the window to which the pointer has been attached
	there is no need to explicitly open a timer object, as ADDTO and WRITE
	  messages automatically open the timer
SeeAlso: AH=12h/BH=0Dh,AH=12h/BH=14h"LOCK"
--------Q-1512--BH0D-------------------------
INT 15 - TopView - SEND MESSAGE - "CLOSE" - CLOSE OBJECT
	AH = 12h
	BH = 0Dh
	BL = object
	    00h handle is DWORD on top of stack
		timer:	  close
		keyboard: detach from window and discard queued input
		pointer:  stop taking input
		panel:	  close
		mailbox:  close, unlock, and discard any pending messages
	    02h close given task's mailbox (task's handle on top of stack)
	    03h close task's default mailbox
	    04h close KEYBOARD object (handle on top of stack)
	    05h close task's default KEYBOARD
	    06h close givent task's OBJECTQ (task's handle on top of stack)
	    07h close current task's OBJECTQ
Notes:	when an OBJECTQ is closed, each object in the OBJECTQ is sent an
	  ERASE message (AH=12h/BH=0Eh)
	when a panel object is closed, the panel file and any panels currently
	  in use are freed; window and keyboard objects created by APPLY are
	  not affected, but field mode input ceases
	open but idle timer objects consume a small amount of CPU time
SeeAlso: AH=12h/BH=0Ch,AH=12h/BH=0Eh,AH=12h/BH=14h"LOCK"
--------Q-1512--BH0E-------------------------
INT 15 - TopView - SEND MESSAGE - "ERASE" - ERASE OBJECT
	AH = 12h
	BH = 0Eh
	BL = object
	    00h handle is DWORD on top of stack
		window:	  clear from scroll origin to end of window
		keyboard: discard input
		timer:	  cancel current interval
		pointer:  discard all pending messages
		mailbox:  discard all pending messages
	    01h clear task's default window from scroll origin to end
	    02h discard all queued messages in mailbox (handle on top of stack)
	    03h discard all queued messages in current task's default mailbox
	    04h discard all input queued to KEYBOARD (handle on top of stack)
	    05h discard all input queued to task's default KEYBOARD
	    06h remove all objects from OBJECTQ (task's handle on top of stack)
	    07h remove all objects from current task's OBJECTQ
	    0Ch (DV 2.26+) clear window of task owning handle on top of stack
	    0Dh (DV 2.26+) clear default window of parent of current task
Note:	when an OBJECTQ is erased, each object in the OBJECTQ is also erased
SeeAlso: AH=12h/BH=02h
--------Q-1512--BH0F-------------------------
INT 15 - TopView - SEND MESSAGE - "STATUS" - GET OBJECT STATUS
	AH = 12h
	BH = 0Fh
	BL = object
	    00h handle is DWORD on top of stack
		timer:	 is it running?
		pointer: return status of last message
		panel:	 verify success of last OPEN or APPLY
	    02h return status of last msg READ from mailbox (handle on stack)
	    03h return status of last msg READ from task's default mailbox
	    04h get status of last msg from task's KEYBOARD (task handle on stk)
	    05h get status of last msg from task's default KEYBOARD
	    06h return whether OBJECTQ is open or not (handle on top of stack)
	    07h return whether task's default OBJECTQ is open or not
Return: DWORD on top of stack is status
Notes:	if object is a panel object, the status indicates the error code:
	  00h successful
	  14h panel name not in panel directory
	  15h not enough memory to apply panel
	  16h invalid panel format
	  17h panel file already open
	  81h-92h  DOS error codes+80h			\  codes > 80h indicate
	  95h not enough memory to open panel file	 > that the panel was
	  98h null panel file name			/  not opened
	if object is a timer, the status is:
	  00000000h open but not running
	  40000000h open and running
	  80000000h closed
	if object is an OBJECTQ, the status is:
	  00000000h open
	  80000000h closed
	if object is a keyboard in keystroke mode, the status is the extended
	  character code (scan code) of teh last keystroke
	if object is a keyboard in field mode, the status indicates the reason
	  for the last return from the field manager
	  00h Enter key pressed
	  01h Button 1 or keystroke selection
	  02h Button 2
	  03h validation
	  04h auto Enter on field
	  1Bh Escape pressed
	  46h ^Break pressed
	  other: extended code for key terminating input
	the status of mailbox messages sent by the window manager is always 80h
	the status of a pointer message is the same as the status field in the
	  message
SeeAlso: AH=12h/BH=04h"READ"
--------Q-1512--BH10-------------------------
INT 15 - TopView - SEND MESSAGE - "EOF" - GET OBJECT EOF STATUS
	AH = 12h
	BH = 10h
	BL = object
	    00h handle is DWORD on top of stack
		window: return TRUE if logical cursor past end of window
		mailbox: ???
	    01h returns TRUE if logical cursor past end of task's def window
	    02h return ??? for task's mailbox (task's handle on top of stack)
	    03h return ??? for current task's mailbox
	    0Ch (DV 2.26+) check log crsr of window owning handle on top of stk
	    0Dh (DV 2.26+) check log cursor of window of parent task
Return: DWORD on top of stack is status
--------Q-1512--BH11-------------------------
INT 15 - TopView - SEND MESSAGE - "AT" - POSITION OBJECT CURSOR
	AH = 12h
	BH = 11h
	BL = window for which to move cursor
	    00h window's handle is DWORD on top of stack
	    01h task's default window
	    0Ch (DV 2.26+) default window of task owning handle on top of stack
	    0Dh (DV 2.26+) default window of parent of current task
	STACK: DWORD column
	       DWORD row
--------Q-1512--BH11-------------------------
INT 15 - TopView - SEND MESSAGE - "SETNAME" - ASSIGN NAME TO MAILBOX
	AH = 12h
	BH = 11h
	BL = mailbox to name
	    00h DWORD on top of stack is mailbox handle
	    02h use given task's mailbox (task's handle on top of stack)
	    03h use current task's default mailbox
	STACK: DWORD length of name
	       DWORD address of name
SeeAlso: AH=12h/BH=12h"GETNAME",AX=DE0Eh
--------Q-1512--BX1100-----------------------
INT 15 - TopView - SEND MESSAGE - "SETSCALE" - SET POINTER SCALE FACTOR
	AH = 12h
	BX = 1100h
	STACK: DWORD object handle for pointer object
	       DWORD number of colums to scale pointer position to
	       DWORD number of rows to scale pointer position to
SeeAlso: AH=12h/BX=1200h
--------Q-1512--BH12-------------------------
INT 15 - TopView - SEND MESSAGE - "READN" - GET NEXT N OBJECT BYTES
	AH = 12h
	BH = 12h
	BL = window to read from
	    00h handle is DWORD on top of stack
	    01h read next N chars or attributes on task's default window
	    0Ch (DV 2.26+) read window of task owning handle on top of stack
	    0Dh (DV 2.26+) read default window of parent of current task
	STACK: DWORD count
Return: STACK: DWORD number of bytes actually read
	       DWORD address of buffer containing data
Notes:	reading starts at the current logical cursor position; the cursor is
	  updated to point at the character following the last one read
	any translucent blanks (FFh) which are visible on screen are changed
	  to the character which is seen through them
	the string produced by the read is placed in an input buffer which may
	  be reused by the next READ or READN of a window
	window stream opcodes D8h and D9h determine whether the read returns
	  characters or attributes
SeeAlso: AH=12h/BH=04h"WINDOW",AH=12h/BH=05h"WINDOW"
--------Q-1512--BH12-------------------------
INT 15 - DESQview 2.50+ - SEND MESSAGE - "GETNAME" - GET NAME OF MAILBOX
	AH = 12h
	BH = 12h
	BL = mailbox for which to retrieve name
	    00h DWORD on top of stack is mailbox handle
	    02h use given task's mailbox (task's handle on top of stack)
	    03h use current task's default mailbox
	STACK: DWORD length of buffer for name
	       DWORD pointer to buffer
Return: STACK: DWORD length of returned name (or size of buffer, if less)
Program: DESQview 2.5x is distributed as part of DESQview/X 1.0x
Note:	the returned name is not NUL-terminated
SeeAlso: AH=12h/BH=11h"SETNAME",AX=DE0Eh
--------Q-1512--BX1200-----------------------
INT 15 - TopView - SEND MESSAGE - "GETSCALE" - GET POINTER SCALE FACTOR
	AH = 12h
	BX = 1200h
	STACK: DWORD object handle for pointer
Return: STACK: DWORD pointer pos scaled as if window were this many colums wide
	       DWORD pointer pos scaled as if window were this many rows high
SeeAlso: AH=12h/BX=1100h
--------Q-1512--BH13-------------------------
INT 15 - TopView - SEND MESSAGE - "REDRAW" - REDRAW WINDOW
	AH = 12h
	BH = 13h
	BL = window object
	    00h DWORD on top of stack is handle for window to redraw
	    01h redraw task's default window
	    0Ch (DV 2.26+) redraw window of task owning handle on top of stack
	    0Dh (DV 2.26+) redraw default window of parent of current task
SeeAlso: AH=12h/BH=05h"WINDOW",AH=12h/BH=0Eh
--------Q-1512--BH13-------------------------
INT 15 - DESQview 2.50+ - SEND MESSAGE - "READINTO" - GET NEXT MAIL MESSAGE
	AH = 12h
	BH = 13h
	BL = mailbox from which to read
	    00h DWORD on top of stack is mailbox handle
	    02h use given task's mailbox (task's handle on top of stack)
	    03h use current task's default mailbox
	STACK: DWORD size of buffer in bytes
	       DWORD pointer to buffer
Return: STACK: DWORD number of bytes read
Program: DESQview 2.5x is distributed as part of DESQview/X 1.0x
Notes:	this call blocks if no input is available, but will return less than
	  the requested number of bytes if some (but insufficient) data is
	  available
	use this call instead of AH=12h/BH=04h if the mailbox has flag bits
	  4 or 5 set, as common memory may be exhausted by that call when
	  attempting to read the next message
SeeAlso: AH=12h/BH=04h"READ",AH=12h/BH=05h,AH=12h/BH=16h
--------Q-1512--BX1300-----------------------
INT 15 - TopView - SEND MESSAGE - "SETICON" - SPECIFY POINTER ICON
	AH = 12h
	BX = 1300h
	STACK: DWORD object handle for pointer
	       DWORD character to use for pointer
--------Q-1512--BH14-------------------------
INT 15 - TopView - SEND MESSAGE - "SETESC" - SET ESCAPE ROUTINE ADDRESS
	AH = 12h
	BH = 14h
	BL = message modifier
	    00h handle is DWORD on top of stack
	    01h define user stream
	    04h intercept keystrokes from KEYBOARD to window (handle on stack)
	    05h intercept keystrokes from task's default KEYBOARD to a window
	STACK: (if window)   DWORD user stream number (14h-1Fh)
			     DWORD address of FAR user stream handler
	       (if keyboard) DWORD address of FAR filter function

The keyboard filter function is called when the keyboard is in field mode.  On
entry,
	AL = character
	AH = 00h or extended ASCII code if AL = 00h
	BL = field number
	CH = cursor column
	CL = cursor row
	DL = field type modifier (sixth item in field table entry)
	DH = seventh item in field table entry
	ES:SI = window's handle
	DS:DI -> field table entry for field containing the cursor
The filter function should return
	AH = 00h use keystroke
	     01h ignore keystroke
	     FFh beep and ignore keystroke
Note: the filter function is not allowed to make INT 15, DOS, or BIOS calls
--------Q-1512--BH14-------------------------
INT 15 - TopView - SEND MESSAGE - "LOCK" - REQUEST EXCLUSIVE ACCESS TO RESOURCE
	AH = 12h
	BH = 14h
	BL = object
	    00h mailbox handle is DWORD on top of stack
	    02h use given task's mailbox (task's handle on top of stack)
	    03h use current task's default mailbox
Note:	release exclusive access by sending CLOSE message to mailbox
	access may be requested multiple times, and requires multiple CLOSEs
SeeAlso: AH=12h/BH=0Dh
--------Q-1512--BH15-------------------------
INT 15 - DESQview v2.20+ - SEND MESSAGE - "SETFLAGS" - SET OBJECT FLAGS
	AH = 12h
	BH = 15h
	BL = object
	    00h DWORD on top of stack
		mailbox, keyboard, or pointer only
	    02h mailbox for task whose handle is on top of stack
	    03h mailbox for current task
	    04h keyboard for task whose handle is on top of stack
	    05h keyboard for current task
	STACK: DWORD flags
		if mailbox:
			bit 0: all mail messages in common memory
			bit 1: allow write even if closed
			bit 2: don't erase messages when mailbox closed
			bit 4: (DV/X) append messages with like status and
				sender (stream-oriented mail)
			bit 5: (DV/X) store mail in expanded memory (pool
				grows as needed)
			bit 6: (DV/X) make mailbox into non-owned mailbox
		if keyboard:
			bit 5: exclusive input when keyboard in use for input
Return: nothing
Notes:	only available if the API level has been set to at least 2.20
	equivalent to performing SUBFROM and ADDTO calls on the object
	if a mailbox has bits 4 or 5 set, you must use "READINTO" rather than
	  "READ" (see AH=12h/BX=1300h"READINTO") to retrieve messages
SeeAlso: AH=12h/BH=0Ah,AH=12h/BH=0Bh,AH=12h/BH=16h
--------Q-1512--BH16-------------------------
INT 15 - DESQview v2.20+ - SEND MESSAGE - "GETFLAGS" - GET OBJECT FLAGS
	AH = 12h
	BH = 16h
	BL = object
	    00h DWORD on top of stack
		mailbox, keyboard, or pointer only
	    02h mailbox for task whose handle is on top of stack
	    03h mailbox for current task
	    04h keyboard for task whose handle is on top of stack
	    05h keyboard for current task
Return: STACK: DWORD current control flags (see AH=12h/BH=15h)
Notes:	only available if the API level has been set to at least 2.20
	if a mailbox has bits 4 or 5 set, you must use "READINTO" rather than
	  "READ" (see AH=12h/BH=13h"READINTO") to retrieve messages
SeeAlso: AH=12h/BH=0Ah,AH=12h/BH=0Bh,AH=12h/BH=13h"READINTO",AH=12h/BH=15h
--------Q-1512--BH17-------------------------
INT 15 - DESQview v2.42-2.52 - BUG
	AH = 12h
	BH = 17h
	BL = object
	    00h DWORD on top of stack
		mailbox, keyboard, or pointer only
	    02h mailbox for task whose handle is on top of stack
	    03h mailbox for current task
	    04h keyboard for task whose handle is on top of stack
	    05h keyboard for current task
Notes:	due to a fencepost error, message 17h is accepted for mailboxes,
	  keyboards, and pointers, but causes a random branch
	DESQview v2.50-2.52 are distributed as part of DESQview/X v1.02
--------Q-1512--BH80-------------------------
INT 15 - DESQview v2.50+ - SEND MESSAGE 00h WITH ERROR RECOVERY
	AH = 12h
	BH = 80h
Note:	this function is identical to AH=12h/BH=00h, except that DESQview will
	  not pop up a "Programming Error" window, instead returning an error
	  code in AL:
		00h no error
		01h invalid values
		02h alias invalid
		03h handle valid but wrong type
		04h invalid handle
SeeAlso: AH=12h/BH=00h
--------Q-1512--BH81-------------------------
INT 15 - DESQview v2.50+ - SEND MESSAGE 01h WITH ERROR RECOVERY
	AH = 12h
	BH = 81h
Note:	this function is identical to AH=12h/BH=01h, except that DESQview will
	  not pop up a "Programming Error" window, instead returning an error
	  code in AL (see AH=12h/BH=80h)
SeeAlso: AH=12h/BH=01h
--------Q-1512--BH82-------------------------
INT 15 - DESQview v2.50+ - SEND MESSAGE 02h WITH ERROR RECOVERY
	AH = 12h
	BH = 82h
Note:	this function is identical to AH=12h/BH=02h, except that DESQview will
	  not pop up a "Programming Error" window, instead returning an error
	  code in AL (see AH=12h/BH=80h)
SeeAlso: AH=12h/BH=02h
--------Q-1512--BH83-------------------------
INT 15 - DESQview v2.50+ - SEND MESSAGE 03h WITH ERROR RECOVERY
	AH = 12h
	BH = 83h
Note:	this function is identical to AH=12h/BH=03h, except that DESQview will
	  not pop up a "Programming Error" window, instead returning an error
	  code in AL (see AH=12h/BH=80h)
SeeAlso: AH=12h/BH=03h,AH=12h/BX=0300h
--------Q-1512--BH84-------------------------
INT 15 - DESQview v2.50+ - SEND MESSAGE 04h WITH ERROR RECOVERY
	AH = 12h
	BH = 84h
Note:	this function is identical to AH=12h/BH=04h, except that DESQview will
	  not pop up a "Programming Error" window, instead returning an error
	  code in AL (see AH=12h/BH=80h)
SeeAlso: AH=12h/BH=04h,AH=12h/BX=0400h
--------Q-1512--BH85-------------------------
INT 15 - DESQview v2.50+ - SEND MESSAGE 05h WITH ERROR RECOVERY
	AH = 12h
	BH = 85h
Note:	this function is identical to AH=12h/BH=05h, except that DESQview will
	  not pop up a "Programming Error" window, instead returning an error
	  code in AL (see AH=12h/BH=80h)
SeeAlso: AH=12h/BH=05h
--------Q-1512--BH86-------------------------
INT 15 - DESQview v2.50+ - SEND MESSAGE 06h WITH ERROR RECOVERY
	AH = 12h
	BH = 86h
Note:	this function is identical to AH=12h/BH=06h, except that DESQview will
	  not pop up a "Programming Error" window, instead returning an error
	  code in AL (see AH=12h/BH=80h)
SeeAlso: AH=12h/BH=06h
--------Q-1512--BH87-------------------------
INT 15 - DESQview v2.50+ - SEND MESSAGE 07h WITH ERROR RECOVERY
	AH = 12h
	BH = 87h
Note:	this function is identical to AH=12h/BH=07h, except that DESQview will
	  not pop up a "Programming Error" window, instead returning an error
	  code in AL (see AH=12h/BH=80h)
SeeAlso: AH=12h/BH=07h
--------Q-1512--BH88-------------------------
INT 15 - DESQview v2.50+ - SEND MESSAGE 08h WITH ERROR RECOVERY
	AH = 12h
	BH = 88h
Note:	this function is identical to AH=12h/BH=08h, except that DESQview will
	  not pop up a "Programming Error" window, instead returning an error
	  code in AL (see AH=12h/BH=80h)
SeeAlso: AH=12h/BH=08h
--------Q-1512--BH89-------------------------
INT 15 - DESQview v2.50+ - SEND MESSAGE 09h WITH ERROR RECOVERY
	AH = 12h
	BH = 89h
Note:	this function is identical to AH=12h/BH=09h, except that DESQview will
	  not pop up a "Programming Error" window, instead returning an error
	  code in AL (see AH=12h/BH=80h)
SeeAlso: AH=12h/BH=09h
--------Q-1512--BH8A-------------------------
INT 15 - DESQview v2.50+ - SEND MESSAGE 0Ah WITH ERROR RECOVERY
	AH = 12h
	BH = 8Ah
Note:	this function is identical to AH=12h/BH=0Ah, except that DESQview will
	  not pop up a "Programming Error" window, instead returning an error
	  code in AL (see AH=12h/BH=80h)
SeeAlso: AH=12h/BH=0Ah
--------Q-1512--BH8B-------------------------
INT 15 - DESQview v2.50+ - SEND MESSAGE 0Bh WITH ERROR RECOVERY
	AH = 12h
	BH = 8Bh
Note:	this function is identical to AH=12h/BH=0Bh, except that DESQview will
	  not pop up a "Programming Error" window, instead returning an error
	  code in AL (see AH=12h/BH=80h)
SeeAlso: AH=12h/BH=0Bh
--------Q-1512--BH8C-------------------------
INT 15 - DESQview v2.50+ - SEND MESSAGE 0Ch WITH ERROR RECOVERY
	AH = 12h
	BH = 8Ch
Note:	this function is identical to AH=12h/BH=0Ch, except that DESQview will
	  not pop up a "Programming Error" window, instead returning an error
	  code in AL (see AH=12h/BH=80h)
SeeAlso: AH=12h/BH=0Ch
--------Q-1512--BH8D-------------------------
INT 15 - DESQview v2.50+ - SEND MESSAGE 0Dh WITH ERROR RECOVERY
	AH = 12h
	BH = 8Dh
Note:	this function is identical to AH=12h/BH=0Dh, except that DESQview will
	  not pop up a "Programming Error" window, instead returning an error
	  code in AL (see AH=12h/BH=80h)
SeeAlso: AH=12h/BH=0Dh
--------Q-1512--BH8E-------------------------
INT 15 - DESQview v2.50+ - SEND MESSAGE 0Eh WITH ERROR RECOVERY
	AH = 12h
	BH = 8Eh
Note:	this function is identical to AH=12h/BH=0Eh, except that DESQview will
	  not pop up a "Programming Error" window, instead returning an error
	  code in AL (see AH=12h/BH=80h)
SeeAlso: AH=12h/BH=0Eh
--------Q-1512--BH8F-------------------------
INT 15 - DESQview v2.50+ - SEND MESSAGE 0Fh WITH ERROR RECOVERY
	AH = 12h
	BH = 8Fh
Note:	this function is identical to AH=12h/BH=0Fh, except that DESQview will
	  not pop up a "Programming Error" window, instead returning an error
	  code in AL (see AH=12h/BH=80h)
SeeAlso: AH=12h/BH=0Fh
--------Q-1512--BH90-------------------------
INT 15 - DESQview v2.50+ - SEND MESSAGE 10h WITH ERROR RECOVERY
	AH = 12h
	BH = 90h
Note:	this function is identical to AH=12h/BH=10h, except that DESQview will
	  not pop up a "Programming Error" window, instead returning an error
	  code in AL (see AH=12h/BH=80h)
SeeAlso: AH=12h/BH=10h
--------Q-1512--BH91-------------------------
INT 15 - DESQview v2.50+ - SEND MESSAGE 11h WITH ERROR RECOVERY
	AH = 12h
	BH = 91h
Note:	this function is identical to AH=12h/BH=11h, except that DESQview will
	  not pop up a "Programming Error" window, instead returning an error
	  code in AL (see AH=12h/BH=80h)
SeeAlso: AH=12h/BH=11h,AH=12h/BX=1100h
--------Q-1512--BH92-------------------------
INT 15 - DESQview v2.50+ - SEND MESSAGE 12h WITH ERROR RECOVERY
	AH = 12h
	BH = 92h
Note:	this function is identical to AH=12h/BH=12h, except that DESQview will
	  not pop up a "Programming Error" window, instead returning an error
	  code in AL (see AH=12h/BH=80h)
SeeAlso: AH=12h/BH=12h,AH=12h/BX=1200h
--------Q-1512--BH93-------------------------
INT 15 - DESQview v2.50+ - SEND MESSAGE 13h WITH ERROR RECOVERY
	AH = 12h
	BH = 93h
Note:	this function is identical to AH=12h/BH=13h, except that DESQview will
	  not pop up a "Programming Error" window, instead returning an error
	  code in AL (see AH=12h/BH=80h)
SeeAlso: AH=12h/BH=13h
--------Q-1512--BH94-------------------------
INT 15 - DESQview v2.50+ - SEND MESSAGE 14h WITH ERROR RECOVERY
	AH = 12h
	BH = 94h
Note:	this function is identical to AH=12h/BH=14h, except that DESQview will
	  not pop up a "Programming Error" window, instead returning an error
	  code in AL (see AH=12h/BH=80h)
SeeAlso: AH=12h/BH=14h
--------Q-1512--BH95-------------------------
INT 15 - DESQview v2.50+ - SEND MESSAGE 15h WITH ERROR RECOVERY
	AH = 12h
	BH = 95h
Note:	this function is identical to AH=12h/BH=15h, except that DESQview will
	  not pop up a "Programming Error" window, instead returning an error
	  code in AL (see AH=12h/BH=80h)
SeeAlso: AH=12h/BH=15h
--------Q-1512--BH96-------------------------
INT 15 - DESQview v2.50+ - SEND MESSAGE 16h WITH ERROR RECOVERY
	AH = 12h
	BH = 96h
Note:	this function is identical to AH=12h/BH=16h, except that DESQview will
	  not pop up a "Programming Error" window, instead returning an error
	  code in AL (see AH=12h/BH=80h)
SeeAlso: AH=12h/BH=16h
--------T-1513-------------------------------
INT 15 - VMiX - "sys_wake" - WAKE SLEEPING PROCESS
	AH = 13h
	STACK:	WORD	process ID
Return: AX = status (SYS_OK or SYS_ERROR)
SeeAlso: AH=12h"VMiX"
--------T-1513-------------------------------
INT 15 - MultiDOS Plus - GET TASK CONTROL BLOCK
	AH = 13h
Return: BX:AX -> task control block (see below)
SeeAlso: AH=15h"MultiDOS"

Format of MultiDOS Plus v4.0 task control block:
Offset	Size	Description
 00h	DWORD	pointer to next TCB
 04h  8 BYTEs	ASCIZ task name
 0Ch  2 BYTEs	???
 0Eh	WORD	task PSP segment
 10h	WORD	abort/suspend flags
 12h	WORD	current screen segment (see AH=0Bh,AH=0Ch)
 14h	WORD	priority level (0000h-FFFEh)
 16h	WORD	time slice counter
 18h  2 BYTEs	???
 1Ah	WORD	suspend timer value
 1Ch	WORD	stack segment
 1Eh	WORD	stack pointer
 20h	WORD	display type
 22h	WORD	display memory
 24h  2 BYTEs	???
 26h	WORD	termination count
 28h	WORD	equipment flag for BIO10 driver
 2Ah	BYTE	background CRT mode
 2Bh	WORD	screen width in columns
 2Dh	WORD	screen size in bytes
 2Fh	WORD	segment of physical screen memory
 31h 16 BYTEs	eight cursor positions
 41h	WORD	current cursor shape
 43h	BYTE	active display page
 44h	WORD	CRT controller I/O port base
 46h  2 BYTEs	???
 48h	WORD	foreground task flag
 4Ah  6 BYTEs	???
 50h	WORD	saved video segment (see AH=0Bh,AH=0Ch)
 52h	DWORD	old INT 22
 56h	DWORD	old INT 23
 5Ah	DWORD	old INT 24
 5Eh	WORD	top of memory for task
 60h  4 BYTEs	???
 64h	WORD	DTA segment (see INT 21/AH=1Ah)
 66h	WORD	DTA offset
 68h  4 BYTEs	???
 6Ch	BYTE	current ANSI.SYS attribute
 6Dh	BYTE	current ANSI.SYS column
 6Eh	BYTE	current ANSI.SYS row
 6Fh	BYTE	current ANSI.SYS display state
 70h	BYTE	maximum ANSI.SYS columns
 71h	BYTE	current ANSI.SYS page
 72h	WORD	saved ANSI.SYS cursor position
 74h	BYTE	ANSI.SYS parameter buffer index
 75h	BYTE	current ANSI.SYS screen mode
 76h	BYTE	ANSI.SYS wrap flag
 77h  6 BYTEs	ANSI.SYS parameter buffer
 7Dh	BYTE	ANSI.SYS keyboard DSR state
 7Eh  7 BYTEs	ANSI.SYS keyboard DSR buffer
 85h  3 BYTEs	???
 88h 16 BYTEs	request header for DOS driver calls
 98h 14 BYTEs	???
 A6h	WORD	segment of EMS map if EMS task
 A8h	WORD	flag: task makes EMS calls
 AAh	WORD	EMS handle for task
 ACh	WORD	keyboard shift state
 AEh 12 BYTEs	???
 BAh	WORD	TCB of parent if child task
 BCh	WORD	termination code
 BEh	WORD	COM port number
 C0h  4 BYTEs	???
 C4h	WORD	current IRQ number
 C6h  2 BYTEs	???
 C8h	WORD	miscellaneous flag word
 CAh  2 BYTEs	???
 CCh	DWORD	old INT 10
 D0h	WORD	EMS alternate map set number
 D2h 414 BYTEs	DOS current disk and directory context (optional)
--------T-1514-------------------------------
INT 15 - VMiX - "sys_clrwindow" - CLEAR WINDOW
	AH = 14h
	STACK:	WORD	top left corner of window (high byte = row, low = col)
		WORD	bottom right corner of window (high = row, low = col)
Return: AX = status (SYS_OK)
Note:	clears window to color set with "sys_setcolors" (AH=18h)
SeeAlso: AH=15h"VMiX",AH=16h"VMiX",AH=18h"VMiX",AH=1Fh"VMiX"
--------T-1514-------------------------------
INT 15 - MultiDOS Plus - CHECK IF MultiDOS FOREGROUND OR BACKGROUND
	AH = 14h
Return: AX = current state
	    0000h MultiDOS Plus command prompt is background task
	    0001h command prompt is foreground task
SeeAlso: AH=0Bh"MultiDOS"
--------T-1515-------------------------------
INT 15 - VMiX - "sys_setbwindow" - SET BANNER WINDOW MESSAGE
	AH = 15h
	STACK:	DWORD	pointer to ASCIZ banner message for top of screen
Return: AX = status (SYS_OK)
SeeAlso: AH=14h"VMiX",AH=16h"VMiX"
--------T-1515-------------------------------
INT 15 - MultiDOS Plus - GET SYSTEM BLOCK
	AH = 15h
Return: BX:AX -> system block (see below)
SeeAlso: AH=13h"MultiDOS"

Format of MultiDOS Plus 4.0 system block:
Offset	Size	Description
 00h	WORD	segment of system control block
 02h	WORD	redirection flag set by /NOREDIRECT
 04h	WORD	no-INT 10 flag set by /NO10
 06h	DWORD	old INT 10
 0Ah	DWORD	new INT 10
 0Eh	DWORD	pointer to WORD with current TCB offset (see AH=13h)
 12h	DWORD	pointer to WORD with idle task TCB offset
 16h	DWORD	pointer to WORD with foreground TCB offset
 1Ah	DWORD	pointer to WORD with MultiDOS TCB offset
 1Eh	WORD	Task Control Block size
 20h	WORD	number of TCBs
 22h	WORD	flag: EMS present
 24h	WORD	EMS page frame base segment
 26h	WORD	16K pages in EMS page frame
 28h	WORD	base segment for conventional memory tasks
 2Ah	WORD	conventional memory size in paragraphs
 2Ch	DWORD	pointer to list of queue pointers
--------T-1516-------------------------------
INT 15 - VMiX - "sys_setwindow" - SET ROOT WINDOW SIZE AND HOME CURSOR
	AH = 16h
	STACK:	DWORD	pointer to I/O Request Packet
		WORD	top left corner of window (high byte = row, low = col)
		WORD	bottom right corner of window (high = row, low = col)
Return: AX = status (SYS_OK or SYS_ERROR)
SeeAlso: AH=14h"VMiX",AH=17h"VMiX"
--------T-1516-------------------------------
INT 15 - MultiDOS Plus - INITIALIZATION
	AH = 16h
Note:	used internally during initialization; any other calls will cause
	  unpredicatable results
--------T-1517-------------------------------
INT 15 - VMiX - "sys_getcolors" - GET CONSOLE WINDOW COLORS
	AH = 17h
Return: AH = foreground color
	AL = background color
SeeAlso: AH=16h"VMiX",AH=18h"VMiX"
--------T-1517-------------------------------
INT 15 - MultiDOS Plus - MAP IRQ
	AH = 17h
	AL = IRQ to map (01h-0Fh)
	BX = offset of task control block (see AH=13h) to associate with IRQ
Return: AX = status
	    0000h successful
	    other invalid IRQ
Note:	the EMS map of the specified TCB is associated with the given interrupt
SeeAlso: AH=18h"MultiDOS",AH=19h"MultiDOS"
--------T-1518-------------------------------
INT 15 - VMiX - "sys_setcolors" - SET CONSOLE COLORS
	AH = 18h
	STACK:	WORD	new background/foreground colors
			bits 3-0: foreground
			bits 7-4: background
			bits 15-8: unused
Return: AX = color
SeeAlso: AH=14h"VMiX",AH=17h"VMiX",AH=19h"VMiX"
--------T-1518-------------------------------
INT 15 - MultiDOS Plus - UNMAP IRQ
	AH = 18h
	AL = IRQ to unmap (01h-0Fh)
Return: AX = status
	    0000h successful
	    0001h invalid IRQ
Note:	results are unpredictable if the IRQ has not been mapped
SeeAlso: AH=17h"MultiDOS",AH=19h"MultiDOS"
--------T-1519-------------------------------
INT 15 - VMiX v2+ - "sys_setconwn" - SET WINDOW COLORS
	AH = 19h
	STACK:	WORD	new background/foreground colors
			bits 3-0: foreground
			bits 7-4: background
			bits 15-8: unused
Return: AX = color
SeeAlso: AH=18h"VMiX"
--------T-1519-------------------------------
INT 15 - MultiDOS Plus - UNMAP ALL IRQs
	AH = 19h
Return: AX destroyed
Note:	for MultiDOS internal use only
SeeAlso: AH=17h"MultiDOS",AH=18h"MultiDOS"
--------T-151A-------------------------------
INT 15 - VMiX v2+ - "sys_sint" - INVOKE SOFTWARE INTERRUPT
	AH = 1Ah
	STACK:	WORD	interrupt number
		DWORD	pointer to register structure
Return: AX = returned flags
--------T-151A-------------------------------
INT 15 - MultiDOS Plus - MAP SEMAPHORE NAME TO NUMBER
	AH = 1Ah
	DS:SI -> 8-byte name
Return: AL = status
	    00h successful
		AH = semaphore number (20h-3Fh)
	    04h out of string space
Notes:	all eight bytes of the name are significant
	if the name does not already exist, it is added to the name table and
	  associated with a free semaphore number
	names cannot be destroyed
SeeAlso: AH=1Bh"MultiDOS",AH=1Ch"MultiDOS",AH=1Dh"MultiDOS"
--------T-151B-------------------------------
INT 15 - VMiX v2+ - "sys_blkmov" - MOVE MEMORY BLOCK
	AH = 1Bh
	STACK:	DWORD	source address
		DWORD	destination address
		WORD	number of words to move
Return: nothing
--------T-151B-------------------------------
INT 15 - MultiDOS Plus - REQUEST RESOURCE SEMAPHORE BY NAME
	AH = 1Bh
	DS:SI -> 8-byte name
Return: AH = status
	    00h successful
	    02h invalid semaphore number
	    03h caller already owns semaphore
	    04h out of string space
Notes:	(see AH=01h"MultiDOS")
	equivalent to AH=1Ah followed by AH=01h
SeeAlso: AH=01h"MultiDOS",AH=1Ah"MultiDOS",AH=1Ch"MultiDOS",AH=1Dh"MultiDOS"
--------T-151C-------------------------------
INT 15 - VMiX v2+ - "sys_bitblt" - PUT GRAPHICAL OBJECT AT CURSOR POSITION
	AH = 1Ch
	STACK:	WORD	AND/OR pixel with background (00h = OR, 01h = AND)
		DWORD	pointer to object bitmap
		WORD	object width in pixels
		WORD	object height in pixels
Return: nothing
SeeAlso: AH=1Dh"VMiX"
--------T-151C-------------------------------
INT 15 - MultiDOS Plus - RELEASE RESOURCE SEMAPHORE BY NAME
	AH = 1Ch
	DS:SI -> 8-byte name
Return: AH = status
	    00h successful
	    01h not semaphore owner
	    02h invalid semaphore number
	    04h out of string space
Notes:	(see AH=02h"MultiDOS")
	equivalent to AH=1Ah followed by AH=02h
SeeAlso: AH=02h"MultiDOS",AH=1Ah"MultiDOS",AH=1Bh"MultiDOS",AH=1Dh"MultiDOS"
--------T-151D-------------------------------
INT 15 - VMiX v2+ - "sys_getfont" - GET CURRENT CONSOLE GRAPHICS FONT
	AH = 1Dh
Return: AX = current font number (00h-03h)
SeeAlso: AH=1Ch"VMiX",AH=1Eh"VMiX"
--------T-151D-------------------------------
INT 15 - MultiDOS Plus - TEST RESOURCE SEMAPHORE BY NAME
	AH = 1Dh
	DS:SI -> 8-byte name
Return; AH = status
	    00h semaphore not in use
	    01h semaphore owned by another task
	    02h invalid semaphore number
	    03h caller owns semaphore
	    04h out of string space
Notes:	(see AH=10h"MultiDOS")
	equivalent to AH=1Ah followed by AH=10h
SeeAlso: AH=10h"MultiDOS",AH=1Ah"MultiDOS",AH=1Bh"MultiDOS",AH=1Ch"MultiDOS"
--------T-151E-------------------------------
INT 15 - VMiX v2+ - "sys_setfont" - SET CONSOLE GRAPHICS FONT
	AH = 1Eh
	STACK: WORD new font number (00h-03h)
Return: AX = current font number (00h-03h)
SeeAlso: AH=1Dh"VMiX"
--------T-151E00-----------------------------
INT 15 - MultiDOS Plus - CLEAR EVENT COUNTER
	AX = 1E00h
	DX = event/trigger number (00h-3Fh)
Return: AH = status
	    00h successful
SeeAlso: AX=1E01h,AX=1E02h
--------T-151E01-----------------------------
INT 15 - MultiDOS Plus - TRIGGER EVENT
	AX = 1E01h
	DX = event/trigger number (00h-3Fh)
Return: AH = status
	    00h successful
	    01h invalid event/trigger number
Notes:	schedules any task waiting for event; if no task is waiting, the event
	  counter is incremented (and will roll over if it was 65535)
	may be invoked by interrupt handler
SeeAlso: AX=1E00h,AX=1E02h
--------T-151E02-----------------------------
INT 15 - MultiDOS Plus - WAIT FOR EVENT
	AX = 1E02h
	DX = event/trigger number (00h-3Fh)
Return: AH = status
	    00h successful
	    01h invalid event/trigger number
Note:	if the event counter is zero, the task is suspended until the event is
	  triggered with AX=1E01h; else, the counter is decremented and the
	  call returns immediately
SeeAlso: AX=1E00h,AX=1E01h
--------T-151E08-----------------------------
INT 15 - MultiDOS Plus 4.01 - SET CONTEXT-SWITCH FUNCTIONS
	AX = 1E08h
	DX:BX -> context save handler
	DX:CX -> context restore handler
Note:	handlers may be removed by setting addresses to 0000h:0000h

Handlers are called with:
	ES:BX -> task's TCB
Return: all registers preserved
--------T-151F-------------------------------
INT 15 - VMiX v2.???+ - "sys_scrollwin" - SCROLL WINDOW
	AH = 1Fh
	STACK:	WORD	top left corner of window (high byte = row, low = col)
		WORD	bottom right corner of window
Return: AX = status (SYS_OK)
SeeAlso: AH=14h"VMiX",AH=18h"VMiX"
--------T-151F-------------------------------
INT 15 - MultiDOS Plus v4.01 - GET MEMORY PARAMETERS
	AH = 1Fh
Return: BX = first segment of conventional memory
	DX = first segment of EMS swap frame into which MultiDOS will load
		programs
--------T-1520-------------------------------
INT 15 - MultiDOS Plus v4.01 - CHECK IF MULTITASKING ENABLED
	AH = 20h
Return: AX = current state
	    0000h multitasking enabled
	    other TCB of task that disabled multitasking
SeeAlso: AH=0Dh"MultiDOS",AH=13h"MultiDOS"
--------c-152000-----------------------------
INT 15 U - DOS 3+ PRINT.COM - DISABLE CRITICAL REGION FLAG
	AX = 2000h
Desc:	stop setting user flag on entry to PRINT critical region
Note:	also supported by PC Network v1.00 RECEIVER.COM
SeeAlso: AX=2001h
--------c-152001-----------------------------
INT 15 U - DOS 3+ PRINT.COM - SET CRITICAL REGION FLAG
	AX = 2001h
	ES:BX -> byte which is to be incremented while in a DOS call
Desc:	specify a user flag which PRINT should set to let an interested
	  application know it is in a critical region
Note:	also supported by PC Network v1.00 RECEIVER.COM
SeeAlso: AX=2000h
--------O-152010-----------------------------
INT 15 - OS HOOK - SETUP SYSREQ ROUTINE (AT,XT286,PS50+)
	AX = 2010h
	???
Return: ???
SeeAlso: AX=2011h
--------O-152011-----------------------------
INT 15 - OS HOOK - COMPLETION OF SYSREQ FUNCTION (AT,XT286,PS50+)
	AX = 2011h
	???
Return: ???
SeeAlso: AX=2010h
--------B-1521-------------------------------
INT 15 - SYSTEM - POWER-ON SELF-TEST ERROR LOG (PS50+)
	AH = 21h
	AL = subfunction
	    00h read POST log
	    01h write POST log
		BH = device ID
		BL = error code
Return: CF set on error
	AH = status (00h OK, 01h list full, 80h invalid cmd, 86h unsupported)
	if function 00h:
	   BX = number of error codes stored
	   ES:DI -> error log
Note:	the log is a series of words, the first byte of which identifies the
	  error code and the second the device.
--------B-1522-------------------------------
INT 15 - SYSTEM - later PS/2s - LOCATE ROM BASIC
	AH = 22h
Return: CF set on error
	    AH = status (86h if function not supported)
	CF clear on success
	    AH = 00h
	    ES:BX -> ROM BASIC
Note:	if this function is not supported, ROM BASIC is at F600h:0000h
SeeAlso: INT 86"BASIC",INT F0"BASIC"
--------b-152400-----------------------------
INT 15 - SYSTEM - later PS/2s - DISABLE A20 GATE
	AX = 2400h
Return: CF clear if successful
	    AH = 00h
	CF set on error
	    AH = status
		01h keyboard controller is in secure mode
		86h function not supported
Note:	also supported by Qualitas 386MAX v6.01+
SeeAlso: AX=2401h,AX=2402h,AX=2403h
--------b-152401-----------------------------
INT 15 - SYSTEM - later PS/2s - ENABLE A20 GATE
	AX = 2401h
Return: CF clear if successful
	    AH = 00h
	CF set on error
	    AH = status
		01h keyboard controller is in secure mode
		86h function not supported
Note:	also supported by Qualitas 386MAX v6.01+
SeeAlso: AX=2400h,AX=2402h
--------b-152402-----------------------------
INT 15 - SYSTEM - later PS/2s - GET A20 GATE STATUS
	AX = 2402h
Return: CF clear if successful
	    AH = 00h
	    AL = current state (00h disabled, 01h enabled)
	CF set on error
	    AH = status
		01h keyboard controller is in secure mode
		86h function not supported
Note:	also supported by Qualitas 386MAX v6.01+
SeeAlso: AX=2400h,AX=2401h
--------b-152403-----------------------------
INT 15 - SYSTEM - later PS/2s - QUERY A20 GATE SUPPORT
	AX = 2403h
Return: CF clear if successful
	    AH = 00h
	    BX = status of A20 gate support
		bit 0: supported with bit 1 of I/O port 92h
		bit 1: supported on keyboard controller
		bit 15: additional data is available (location not yet defined)
	CF set on error
	    AH = status
		01h keyboard controller is in secure mode
		86h function not supported
Note:	also supported by Qualitas 386MAX v6.01+
SeeAlso: AX=2402h
--------B-1540-------------------------------
INT 15 - SYSTEM - READ/MODIFY PROFILES (CONVERTIBLE)
	AH = 40h
	AL = subfunction
	    00h get system profile in CX and BX
	    01h set system profile from CX and BX
	    02h get internal modem profile in BX
	    03h set internal modem profile from BX
Return: CF clear if successful
	    AH = 00h
	CF set on error
	    AH = status (80h = profile execution failed)
--------V-154000-----------------------------
INT 15 - Compaq SLT/286 or Portable 386 - READ LCD/PLASMA TIMEOUT
	AX = 4000h
Return: AX = 4000h
	CL = 00h timeout disabled
	   else timeout in minutes
SeeAlso: AX=4001h,AX=4600h
--------V-154001CL00-------------------------
INT 15 - Compaq SLT/286 or Portable 386 - SET LCD/PLASMA TIMEOUT
	AX = 4001h
	CL = 00h timeout disabled
	   else	 timeout in minutes
Return: AL = 00h timeout modified
	     01h timeout cannot be modified
	     40h timeout cannot be modified
	CL = 00h timeout disabled
	   else timeout in minutes
SeeAlso: AX=4000h,AX=4601h
--------B-1541-------------------------------
INT 15 - SYSTEM - WAIT ON EXTERNAL EVENT (CONVERTIBLE and some others)
	AH = 41h
	AL = condition type
	    bits 0-2: condition to wait for
		     0 any external event
		     1 compare and return if equal
		     2 compare and return if not equal
		     3 test and return if not zero
		     4 test and return if zero
	    bit 3:    reserved
	    bit 4:    1=port address, 0=user byte
	    bits 5-7: reserved
	BH = condition compare or mask value
	BL = timeout value times 55 milliseconds
	    00h means no timeout
	DX = I/O port address if AL bit 4 set
	ES:DI -> user byte if AL bit 4 clear
Note:	call AH=C0h and examine bit 3 of feature byte 1 to determine whether
	  this function is supported
SeeAlso: AH=83h,AH=86h,AH=C0h
--------B-1542-------------------------------
INT 15 - SYSTEM - REQUEST POWER OFF (CONVERTIBLE,HP 95LX)
	AH = 42h
	AL = suspend type
	    00h to use system profile
	    01h to force suspend regardless of system profile
Note:	the HP 95LX apparently suspends regardless of the value in AL; on
	  power-up, execution will resume following the instruction calling
	  this function
SeeAlso: AH=44h
--------b-154280-----------------------------
INT 15 - Compaq SLT/286 - ENTER STANDBY
	AX = 4280h
Return: AH = 42h
	CF clear if successful
	CF set if unable to enter standby
SeeAlso: AX=4600h,AX=5307h/BX=0001h/CX=0001h
--------B-1543-------------------------------
INT 15 - SYSTEM - READ SYSTEM STATUS (CONVERTIBLE)
	AH = 43h
Return: AL = status bits (see below)

Bitfields for Convertible system status:
 bit 0	LCD detached
 bit 1	reserved
 bit 2	RS232/parallel adapter powered on
 bit 3	internal modem powered on
 bit 4	power activated by alarm
 bit 5	standby power lost
 bit 6	external power in use
 bit 7	power low
--------B-1544-------------------------------
INT 15 - SYSTEM - (DE)ACTIVATE INTERNAL MODEM POWER (CONVERTIBLE)
	AH = 44h
	AL = new modem power state (00h power off, 01h power on)
SeeAlso: AH=42h
--------b-154600-----------------------------
INT 15 - Compaq SLT/286 - READ POWER CONSERVATION/MODEM CONFIGURATION
	AX = 4600h
Return: AH = modem configuration information
	    bit 0 powerup state
		    0 off
		    1 on
		1 modem installed
		2 IRQ line assignment
		    0 IRQ 4
		    1 IRQ 3
		3 COM port assignment
		    0 = COM 2
		    1 = COM 1
		4 modem state
		    0 not assigned
		    1 assigned
		5 modem is on
	AL = power conservation status information
	    bit 0  power source (0 internal, 1 external)
	       1-2 low battery state
		    00 no low battery condition
		    01 low battery 1
		    10 reserved
		    11 low battery 2
	       3-4 power conservation mode
		    00 automatic
		    01 on
		    10 off
		    11 reserved
	BH = default system inactivity timeout (1-21 minutes)
	BL = current system inactivity timeout (1-21 minutes)
	CH = default video display inactivity timeout (1-63 minutes)
	CL = current video display inactivity timeout (1-63 minutes)
	DH = default fixed disk drive inactivity timeout (1-21 minutes)
	DL = current fixed disk drive inactivity timeout (1-21 minutes)
SeeAlso: AX=4280h,AX=4601h,INT 77
--------b-154601-----------------------------
INT 15 - Compaq SLT/286 - Modify Power Conservation/Modem Configuration
	AX = 4601h
	BL = system inactivity timeout (1-21 minutes)
	   = FFh do not change
	CL = video display inactivity timeout (1-63 minutes)
	   = FFh do not change
	DL = current fixed disk drive inactivity timeout (1-21 minutes)
	   = FFh do not change
	DH = 00h turn modem OFF
	   = 01h turn modem ON
	   = FFh do not change modem state
Return: CF clear if successful
	    AH = 00h
	    BL = current system inactivity timeout (1-21 minutes)
	    CL = current video display inactivity timeout (1-63 minutes)
	    DL = current fixed disk drive inactivity timeout (1-21 minutes)
	    DH = FFh modem state unchanged
	       = 00h modem turned OFF
	       = 01h modem turned ON
	CF set on error
	    AH = 01h input is out of range
	       = 02h - No modem present
SeeAlso: AX=4600h,INT 77
--------D-154900-----------------------------
INT 15 - Far East MS-DOS - GET DOS TYPE
	AX = 4900h
Return: CF clear if successful
	    AH = 00h
	    BL = type of DOS running
		00h DOS/V
		01h DOS/J or DOS/K (early IBM Japan versions of MS-DOS)
	CF set on error
	    AH = 86h (function not supported)
Note:	in practice, DOS/J returns AH=86h; AX DOS does not support this call
SeeAlso: INT 21/AH=30h
--------b-154DD4-----------------------------
INT 15 - HP 95LX - INSTALLATION CHECK
	AX = 4DD4h
Return: BX = 4850h ("HP") if HP 95LX
	    CX = ??? (0101h)
	    DL = ??? (00h)
SeeAlso: INT 0B"HP 95LX",INT 0F"HP 95LX",INT 5F/AH=00h,INT 60/DI=0100h
SeeAlso: INT 61"HP 95LX"
--------b-154E-------------------------------
INT 15 - HP 95LX - ENABLE/DISABLE LIGHT SLEEP
	AH = 4Eh
	AL = light sleep
	    00h disabled
	    01h enabled
Note:	when light sleep is disabled, the system will continue running at full
	  speed; when enabled, it may automatically slow to conserve batteries
SeeAlso: INT 06"HP 95LX",INT 60/DI=0100h
--------B-154F-------------------------------
INT 15 C - KEYBOARD - KEYBOARD INTERCEPT (AT model 3x9,XT2,XT286,CONV,PS)
	AH = 4Fh
	AL = hardware scan code
	CF set
Return: CF set
	   AL = hardware scan code
	CF clear
	   scan code should be ignored
Note:	called by INT 09 handler to translate scan codes; the INT 09 code does
	  not examine the scan code it reads from the keyboard until after
	  this function returns.  This permits software to rearrange the
	  keyboard; for example, swapping the CapsLock and Control keys, or
	  turning the right Shift key into Enter.
SeeAlso: INT 09,INT 15/AH=C0h
--------T-1550-------------------------------
INT 15 - VMIX v2.???+ - "sys_vm_page" - SET NEW VIRTUAL PAGE TABLE
	AH = 50h
	BX = segment of page directory table
	CX = page number of page table
SeeAlso: AH=10h"VMiX",AH=51h"VMiX",AH=52h"VMiX"
--------T-1551-------------------------------
INT 15 - VMiX v2.???+ - "sys_vm_func" - EXECUTE FUNCTION IN PROTECTED MODE
	AH = 51h
	STACK:	DWORD	selector:offset of function
Return: registers as returned by function
Note:	executes function with privilege level 0 (highest privilege)
SeeAlso: AH=10h"VMiX",AH=52h"VMiX"
--------B-155101-----------------------------
INT 15 - SYSTEM - later PS/2s - EXPANSION UNIT, RETURN CONFIGURATION NUMBER
	AX = 5101h
Return: CF set if successful
	    AH = 00h
	    AL = current configuration number
		00h system unit only
		FFh configuration not recognized
	    BX = status flag
		bits 0-14: reserved
		bit 15: additional data is available (location TBD)
	CF clear on error
	    AH = status
		01h expansion unit is not present
		86h function not supported
Note:	CF convention is the reverse of the standard convention for this
	  interrupt.  (Perhaps a typo in the IBM BIOS Tech Ref?)
--------T-1552-------------------------------
INT 15 - VMiX v2.???+ - "sys_vm_init" - INITIALIZE PROTECTED-MODE ENVIRONMENT
	AH = 52h
SeeAlso: AH=50h"VMiX",AH=51h"VMiX"
--------p-155300BX0000-----------------------
INT 15 - Advanced Power Management Specification - INSTALLATION CHECK
	AX = 5300h
	BX = 0000h (device ID of system BIOS)
Return: CF clear if successful
	    AH = major version (BCD)
	    AL = minor version (BCD)
	    BX = 504Dh ("PM")
	    CX = flags
		bit 0: 16-bit protected mode interface supported
		bit 1: 32-bit protected mode interface supported
		bit 2: CPU idle call reduces processor speed
		bit 3: BIOS power management disabled
		bits 4-7 reserved
	CF set on error
	    AH = error code (86h) (see below)

Values for error code:
 01h	power management functionality disabled
 02h	interface connection already in effect
 03h	interface not connected
 04h	real-mode interface not connected
 05h	16-bit protected-mode interface already connected
 06h	16-bit protected-mode interface not supported
 07h	32-bit protected-mode interface already connected
 08h	32-bit protected-mode interface not supported
 09h	unrecognized device ID
 0Ah	invalid parameter value in CX
 0Bh-1Fh reserved for other interface and general errors
 20h-3Fh reserved for CPU errors
 40h-5Fh reserved for device errors
 60h	can't enter requested state
 61h-7Fh reserved for other system errors
 80h	no power management events pending
 81h-85h reserved for other power management event errors
 86h	APM not present
 87h-9Fh reserved for other power management event errors
--------p-155301BX0000-----------------------
INT 15 - Advanced Power Management Specification - CONNECT REAL-MODE INTERFACE
	AX = 5301h
	BX = 0000h (device ID of system BIOS)
Return: CF clear if successful
	CF set on error
	    AH = error code (02h,09h) (see AX=5300h)
SeeAlso: AX=5302h,AX=5303h,AX=5304h
--------p-155302BX0000-----------------------
INT 15 R - Advanced Power Management Spec - CONNECT 16-BIT PROTMODE INTERFACE
	AX = 5302h
	BX = 0000h (device ID of system BIOS)
Return: CF clear if successful
	    AX = real-mode segment base address of protected-mode 16-bit code
		segment
	    BX = offset of entry point
	    CX = real-mode segment base address of protected-mode 16-bit data
		segment
	CF set on error
	    AH = error code (05h,06h,09h) (see AX=5300h)
Notes:	the caller must initialize two consecutive descriptors with the
	  returned segment base addresses; these descriptors must be valid
	  whenever the protected-mode interface is called, and will have
	  their limits arbitrarily set to 64K.
	the protected mode interface is invoked by making a far call with the
	  same register values as for INT 15; it must be invoked while CPL=0,
	  the code segment descriptor must have a DPL of 0, the stack must be
	  in a 16-bit segment and have enough room for BIOS use and possible
	  interrupts, and the current I/O permission bit map must allow access
	  to the I/O ports used for power management.
	functions 00h-03h are not available from protected mode
SeeAlso: AX=5301h,AX=5303h,AX=5304h
--------p-155303BX0000-----------------------
INT 15 - Advanced Power Management Spec - CONNECT 32-BIT PROTMODE INTERFACE
	AX = 5303h
	BX = 0000h (device ID of system BIOS)
Return: CF clear if successful
	    AX = real-mode segment base address of protected-mode 32-bit code
		segment
	    EBX = offset of entry point
	    CX = real-mode segment base address of protected-mode 16-bit code
		segment
	    DX = real-mode segment base address of protected-mode 16-bit data
		segment
	CF set on error
	    AH = error code (07h,08h,09h) (see AX=5300h)
Notes:	the caller must initialize three consecutive descriptors with the
	  returned segment base addresses for 32-bit code, 16-bit code, and
	  16-bit data, respectively; these descriptors must be valid whenever
	  the protected-mode interface is called, and will have their limits
	  arbitrarily set to 64K.
	the protected mode interface is invoked by making a far call to the
	  32-bit code segment with the same register values as for INT 15; it
	  must be invoked while CPL=0, the code segment descriptor must have a
	  DPL of 0, the stack must be in a 32-bit segment and have enough room
	  for BIOS use and possible interrupts, and the current I/O permission
	  bit map must allow access to the I/O ports used for power management.
	functions 00h-03h are not available from protected mode
SeeAlso: AX=5301h,AX=5302h,AX=5304h
--------p-155304BX0000-----------------------
INT 15 - Advanced Power Management Specification - DISCONNECT INTERFACE
	AX = 5304h
	BX = 0000h (device ID of system BIOS)
Return: CF clear if successful
	CF set on error
	    AH = error code (03h,09h) (see AX=5300h)
SeeAlso: AX=5301h,AX=5302h,AX=5303h
--------p-155305-----------------------------
INT 15 - Advanced Power Management Specification - CPU IDLE
	AX = 5305h
Return: after system leaves idle state
	CF clear
Notes:	call when the system is idle and should be suspended until the next
	  system event or interrupt
	should not be called from within a hardware interrupt handler to avoid
	  reentrance problems
	if an interrupt causes the system to resume normal processing, the
	  interrupt may or may not have been handled when the BIOS returns
	  from this call; thus, the caller should allow interrupts on return
	interrupt handlers may not retain control if the BIOS allows
	  interrupts while in idle mode even if they are able to determine
	  that they were called from idle mode
	the caller should issue this call continuously in a loop until it needs
	  to perform some processing of its own
SeeAlso: AX=1000h,AX=5306h,INT 2F/AX=1680h
--------p-155306-----------------------------
INT 15 - Advanced Power Management Specification - CPU BUSY
	AX = 5306h
Return: CF clear
Notes:	called to ensure that the system runs at full speed even on systems
	  where the BIOS is unable to recognize increased activity (especially
	  if interrupts are hooked by other programs and not chained to the
	  BIOS)
	this call may be made even when the system is already running at full
	  speed, but it will create unnecessary overhead
	should not be called from within a hardware interrupt handler to avoid
	  reentrance problems
SeeAlso: AX=5305h
--------p-155307-----------------------------
INT 15 - Advanced Power Management Specification - SET POWER STATE
	AX = 5307h
	BX = device ID (see below)
	CX = system state ID
	    0000h ready (not supported for device ID 0001h)
	    0001h stand-by
	    0002h suspend
	    0003h off (not supported for device ID 0001h)
	    0004h-FFFFh reserved
Return: CF clear if successful
	CF set on error
	    AH = error code (01h,09h,0Ah,60h) (see AX=5300h)
Note:	should not be called from within a hardware interrupt handler to avoid
	  reentrance problems

Values for device IDs:
 0000h	system BIOS
 0001h	all devices for which the system BIOS manages power
 01xxh	display (01FFh for all attached display devices)
 02xxh	secondary storage (02FFh for all attached secondary storage devices)
 03xxh	parallel ports (03FFh for all attached parallel ports)
 04xxh	serial ports (04FFh for all attached serial ports)
 0500h-FFFFh reserved
--------p-155307BX0001-----------------------
INT 15 - Advanced Power Management Specification - SYSTEM STAND-BY
	AX = 5307h
	BX = 0001h
	CX = 0001h
Return: CF clear
Notes:	puts the entire system into stand-by mode; normally called in response
	  to a System Stand-by Request notification after any necessary
	  processing, but may also be invoked at the caller's discretion
	should not be called from within a hardware interrupt handler to avoid
	  reentrance problems
	the stand-by state is typically exited on an interrupt
SeeAlso: AX=4280h,AX=5307h/BX=0001h/CX=0002h,AX=530Bh
--------p-155307BX0001-----------------------
INT 15 - Advanced Power Management Specification - SUSPEND SYSTEM
	AX = 5307h
	BX = 0001h
	CX = 0002h
Return: after system is resumed
	CF clear
Notes:	puts the entire system into a low-power suspended state; normally
	  called in response to a Suspend System Request notification after
	  any necessary processing, but may also be invoked at the caller's
	  discretion
	should not be called from within a hardware interrupt handler to avoid
	  reentrance problems
	the caller may need to update its date and time values because the
	  system could have been suspended for a long period of time
SeeAlso: AX=5307h/BX=0001h/CX=0001h,AX=530Bh
--------p-155308BXFFFF-----------------------
INT 15 - Advanced Power Management Spec - ENABLE/DISABLE POWER MANAGEMENT
	AX = 5308h
	BX = FFFFh
	CX = new state
	    0000h disabled
	    0001h enabled
Return: CF clear if successful
	CF set on error
	    AH = error code (01h,09h,0Ah) (see AX=5300h)
Notes:	when power management is disabled, the system BIOS will not
	  automatically power down devices, enter stand-by or suspended mode,
	  or perform any power-saving actions in response to AX=5305h calls
	should not be called from within a hardware interrupt handler to avoid
	  reentrance problems
SeeAlso: AX=5309h
--------p-155309BXFFFF-----------------------
INT 15 - Advanced Power Management Specification - RESTORE POWER-ON DEFAULTS
	AX = 5309h
	BX = FFFFh
Return: CF clear if successful
	CF set on error
	    AH = error code (09h) (see AX=5300h)
Note:	should not be called from within a hardware interrupt handler to avoid
	  reentrance problems
SeeAlso: AX=5308h
--------p-15530ABX0001-----------------------
INT 15 - Advanced Power Management Specification - GET POWER STATUS
	AX = 530Ah
	BX = 0001h
Return: CF clear if successful
	    BH = AC line status
		00h off-line
		01h on-line
		FFh unknown
		other reserved
	    BL = battery status
		00h high
		01h low
		02h critical
		03h charging
		FFh unknown
		other reserved
	    CL = remaining battery life
		00h-64h (0-100) percentage of full charge
		FFh unknown
	CF set on error
	    AH = error code (09h) (see AX=5300h)
Note:	should not be called from within a hardware interrupt handler to avoid
	  reentrance problems
--------p-15530B-----------------------------
INT 15 - Advanced Power Management Specification - GET POWER MANAGEMENT EVENT
	AX = 530Bh
Return: CF clear if successful
	    BX = event code
		0001h system stand-by request
		0002h system suspend request
		0003h normal resume system notification
		0004h critical resume system notification
		0005h battery low notification
	CF set on error
	    AH = error code (03h,80h) (see AX=5300h)
Notes:	although power management events are often asynchronous, notification
	  will not be made until polled via this call to permit software to
	  only receive event notification when it is prepared to process
	  power management events; since these events are not very time-
	  critical, it should be sufficient to poll once or twice per second
	the critical resume notification is made after the system resumes
	  from an emergency suspension; normally, the system BIOS only notifies
	  its partner that it wishes to suspend and relies on the partner to
	  actually request the suspension, but no notification is made on an
	  emergency suspension
	should not be called from within a hardware interrupt handler to avoid
	  reentrance problems
SeeAlso: AX=5307h,AX=5307h/BX=0001h/CX=0001h,AX=5307h/BX=0001h/CX=0002h
--------T-155400-----------------------------
INT 15 C - Omniview Multitasker - INSTALLATION NOTIFICATION
	AX = 5400h
	ES:BX -> device information tables
	DI:DX -> dispatcher entry point
Note:	called by OmniView to notify programs loaded before OmniView of state
	  changes inside OmniView
SeeAlso: AX=5407h,INT 2F/AX=DE00h
--------T-155401-----------------------------
INT 15 C - Omniview Multitasker - PROCESS CREATION
	AX = 5401h
	ES:BX = process handle
Note:	called by OmniView to notify programs loaded before OmniView of state
	  changes inside OmniView
SeeAlso: AX=5402h,INT 2F/AX=DE04h
--------T-155402-----------------------------
INT 15 C - Omniview Multitasker - PROCESS DESTRUCTION
	AX = 5402h
	ES:DX = process handle
Note:	called by OmniView to notify programs loaded before OmniView of state
	  changes inside OmniView
SeeAlso: AX=5401h,INT 2F/AX=DE05h
--------T-155403-----------------------------
INT 15 C - Omniview Multitasker - SAVE
	AX = 5403h
	ES:DX = process swapping out
Note:	called by OmniView to notify programs loaded before OmniView of state
	  changes inside OmniView
SeeAlso: AX=5404h,INT 2F/AX=DE08h
--------T-155404-----------------------------
INT 15 C - Omniview Multitasker - RESTORE
	AX = 5404h
	ES:DX = process swapping in
Note:	called by OmniView to notify programs loaded before OmniView of state
	  changes inside OmniView
SeeAlso: AX=5403h,INT 2F/AX=DE09h
--------T-155405-----------------------------
INT 15 C - Omniview Multitasker - SWITCHING TO BACKGROUND
	AX = 5405h
	ES:DX = process swapping in
Note:	called by OmniView to notify programs loaded before OmniView of state
	  changes inside OmniView
SeeAlso: AX=5406h
--------T-155406-----------------------------
INT 15 C - Omniview Multitasker - SWITCHING TO FOREGROUND
	AX = 5406h
	ES:DX = process swapping in
Note:	called by OmniView to notify programs loaded before OmniView of state
	  changes inside OmniView
SeeAlso: AX=5405h
--------T-155407-----------------------------
INT 15 C - Omniview Multitasker - EXIT NOTIFICATION
	AX = 5407h
Note:	called by OmniView to notify programs loaded before OmniView of state
	  changes inside OmniView
SeeAlso: AX=5400h,INT 2F/AX=DE03h
--------B-1580-------------------------------
INT 15 C - OS HOOK - DEVICE OPEN (AT,XT286,PS)
	AH = 80h
	BX = device ID
	CX = process ID
	CF clear
Return: CF clear if successful
	    AH = 00h
	CF set on error
	    AH = status
		80h invalid command (PC,PCjr)
		86h function not supported (XT)
Note:	this function should be hooked by a multitasker which wishes to keep
	  track of device ownership; the default BIOS handler merely returns
	  successfully
SeeAlso: AH=81h,AH=82h
--------B-1581-------------------------------
INT 15 C - OS HOOK - DEVICE CLOSE
	AH = 81h
	BX = device ID
	CX = process ID
	CF clear
Return: CF clear if successful
	    AH = 00h
	CF set on error
	    AH = status (see AH=80h)
Note:	this function should be hooked by a multitasker which wishes to keep
	  track of device ownership; the default BIOS handler merely returns
	  successfully
SeeAlso: AH=80h,AH=82h
--------B-1582-------------------------------
INT 15 C - OS HOOK - PROGRAM TERMINATION
	AH = 82h
	BX = process ID
	CF clear
Return: CF clear if successful
	    AH = 00h
	CF set on error
	    AH = status (see AH=80h)
Notes:	closes all devices opened by the given process ID with function 80h
	this function should be hooked by a multitasker which wishes to keep
	  track of device ownership; the default BIOS handler merely returns
	  successfully
SeeAlso: AH=80h,AH=81h
--------B-1583-------------------------------
INT 15 - BIOS - SET EVENT WAIT INTERVAL (AT,PS50+)
	AH = 83h
	AL = subfunction
	    00h set interval
		CX:DX = microseconds to delay
		ES:BX -> byte whose high bit is to be set at end of interval
	    01h cancel wait interval
Return: CF set on error or function already busy
	    AH = status
		80h invalid command (PC,PCjr)
		86h function not supported (XT and later)
	CF clear if successful
Notes:	the resolution of the wait period is 977 microseconds on most systems
	  because most BIOSes use the 1/1024 second fast interrupt from the AT
	  real-time clock chip which is available on INT 70
	IBM AT 1/10/84 BIOS ignores AL and always performs subfunction 00h
SeeAlso: AH=41h,AH=86h,INT 70
--------B-1584-------------------------------
INT 15 - BIOS - JOYSTICK SUPPORT (XT after 11/8/82,AT,XT286,PS)
	AH = 84h
	DX = subfunction
	    0000h read joystick switches
		Return: AL bits 7-4 = switch settings
	    0001h read positions of joysticks
		Return: AX = X position of joystick A
			BX = Y position of joystick A
			CX = X position of joystick B
			DX = Y position of joystick B
Return: CF set on error
	    AH = status
		80h invalid command (PC,PCjr)
		86h function not supported (other)
	CF clear if successful
Notes:	if no game port is installed, subfunction 0000h returns AL=00h (all
	  switches open) and subfunction 0001h returns AX=BX=CX=DX=0000h
	a 250kOhm joystick typically returns 0000h-01A0h
--------B-1585-------------------------------
INT 15 C - OS HOOK - SysRq KEY ACTIVITY (AT,PS)
	AH = 85h
	AL = 00h SysRq key pressed
	   = 01h SysRq key released
	CF clear
Return: CF clear if successful
	    AH = 00h
	CF set on error
	    AH = status (see AH=84h)
Notes:	called by keyboard decode routine
	the default handler simply returns successfully; programs which wish
	  to monitor the SysRq key must hook this call
SeeAlso: INT 09
--------B-1586-------------------------------
INT 15 - BIOS - WAIT (AT,PS)
	AH = 86h
	CX:DX = interval in microseconds
Return: CF clear if successful (wait interval elapsed)
	CF set on error or AH=83h wait already in progress
	    AH = status (see AH=84h)
Note:	the resolution of the wait period is 977 microseconds on most systems
	  because most BIOSes use the 1/1024 second fast interrupt from the AT
	  real-time clock chip which is available on INT 70
SeeAlso: AH=41h,AH=83h,INT 1A/AX=FF01h,INT 70
--------B-1587-------------------------------
INT 15 - SYSTEM - COPY EXTENDED MEMORY
	AH = 87h
	CX = number of words to copy (max 8000h)
	ES:SI -> global descriptor table
Return: CF set on error
	CF clear if successful
	AH = status
	    00h source copied into destination
	    01h parity error
	    02h interrupt error
	    03h address line 20 gating failed
	    80h invalid command (PC,PCjr)
	    86h unsupported function (XT,PS30)
Notes:	copy is done in protected mode with interrupts disabled by the default
	  BIOS handler; many 386 memory managers perform the copy with
	  interrupts enabled
	this function is incompatible with the OS/2 compatibility box
SeeAlso: AH=88h,AH=89h

Format of global descriptor table:
Offset	Size	Description
 00h 16 BYTEs	zeros
 10h	WORD	source segment length in bytes (2*CX-1 or greater)
 12h  3 BYTEs	24-bit linear source address, low byte first
 15h	BYTE	source segment access rights (93h)
 16h	WORD	zero
 18h	WORD	destination segment length in bytes (2*CX-1 or greater)
 1Ah  3 BYTEs	24-bit linear destination address, low byte first
 1Dh	BYTE	destination segment access rights (93h)
 1Eh 18 BYTEs	zeros
--------B-1588-------------------------------
INT 15 - SYSTEM - GET EXTENDED MEMORY SIZE (286+)
	AH = 88h
Return: CF clear if successful
	    AX = number of contiguous KB starting at absolute address 100000h
	CF set on error
	    AH = status
		80h invalid command (PC,PCjr)
		86h unsupported function (XT,PS30)
Notes:	TSRs which wish to allocate extended memory to themselves often hook
	  this call, and return a reduced memory size.	They are then free to
	  use the memory between the new and old sizes at will.
	the standard BIOS only returns memory between 1MB and 16MB; use AH=C7h
	  for memory beyond 16MB
SeeAlso: AH=87h,AH=C7h
--------B-1589-------------------------------
INT 15 - SYSTEM - SWITCH TO PROTECTED MODE
	AH = 89h
	BL = interrupt number of IRQ0 (IRQ1-7 use next 7 interrupts)
	BH = interrupt number of IRQ8 (IRQ9-F use next 7 interrupts)
	ES:SI -> GDT for protected mode
	       offset 0h  null descriptor (initialize to zeros)
		      8h  GDT descriptor
		     10h  IDT descriptor
		     18h  DS
		     20h  ES
		     28h  SS
		     30h  CS
		     38h  uninitialized, used to build descriptor for BIOS CS
	CX = offset into protected-mode CS to jump to
Return: CF set on error
	   AH = FFh  error enabling address line 20
	CF clear if successful
	   AH = 00h
	   in protected mode at specified address
Note:	BL and BH must be multiples of 8
SeeAlso: AH=87h,AH=88h,INT 67/AX=DE0Ch
--------B-1590-------------------------------
INT 15 - OS HOOK - DEVICE BUSY (AT,PS)
	AH = 90h
	AL = device type (see below)
	ES:BX -> request block for type codes 80h through BFh
	CF clear
Return: CF set if wait time satisfied
	CF clear if driver must perform wait
	    AH = 00h
Notes:	type codes are allocated as follows:
	  00-7F non-reentrant devices; OS must arbitrate access
	  80-BF reentrant devices; ES:BX points to a unique control block
	  C0-FF wait-only calls, no complementary INT 15/AH=91h call
	floppy and hard disk BIOS code uses this call to implement a timeout;
	  for device types 00h and 01h, a return of CF set means that the
	  timeout expired before the disk responded.
	this function should be hooked by a multitasker to allow other tasks
	  to execute while the BIOS is waiting for I/O completion; the default
	  handler merely returns with AH=00h and CF clear
SeeAlso: AH=91h,INT 13/AH=00h,INT 17/AH=00h,INT 1A/AH=83h

Values for device type:
 00h	disk
 01h	diskette
 02h	keyboard
 03h	PS/2 pointing device
 21h	waiting for keyboard input (Phoenix BIOS)
 80h	network
 FBh	digital sound (Tandy)
 FCh	disk reset (PS)
 FDh	diskette motor start
 FEh	printer
--------B-1591-------------------------------
INT 15 - OS HOOK - DEVICE POST (AT,PS)
	AH = 91h
	AL = device type (see AH=90h)
	ES:BX -> request block for type codes 80h through BFh
	CF clear
Return: AH = 00h
Note:	this function should be hooked by a multitasker to allow other tasks
	  to execute while the BIOS is waiting for I/O completion; the default
	  handler merely returns with AH=00h and CF clear
SeeAlso: AH=90h
--------b-15BC-------------------------------
INT 15 - Phoenix 386 BIOS - DETERMINE CPU SPEED
	AH = BCh
Return: CF clear
	BYTE 0040h:00B0h set to ??? (43 on my 386/33)
Note:	reads system timer channel 0 twice, then does calculations on returned
	  values
--------E-15BF00-----------------------------
INT 15 - Rational Systems DOS/16M - ???
	AX = BF00h
	???
Return: ???
Note:	under DESQview/X 1.02 DVDOS4GX.DVR, this call is identical to AX=BF02h
SeeAlso: AX=BF02h
--------E-15BF01-----------------------------
INT 15 - Rational Systems DOS/16M - ???
	AX = BF01h
	???
Return: ???
Notes:	under DESQview/X 1.02 DVDOS4GX.DVR, this call is identical to AX=BF02h
	called by DOS/4GW
SeeAlso: AX=BF00h,AX=BF02h
--------E-15BF02DX0000-----------------------
INT 15 - Rational Systems DOS/16M - INSTALLATION CHECK
	AX = BF02h
	DX = 0000h
Return: DX = nonzero if installed
	    DX:SI -> XBRK structure (see below)
Note:	this function is also supported by DOS/4G
SeeAlso: AX=BF01h,AX=BFDCh,AX=BFDEh/BX=0000h
SeeAlso: INT 21/AH=FFh/DH=0Eh,INT 2F/AH=A1h,INT 2F/AX=F100h,INT 2F/AX=FBA1h

Format of XBRK structure:
Offset	Size	Description
 00h	DWORD	linear address of first available byte
 04h	DWORD	linear address of last available byte + 1 ???
 08h	DWORD	real-mode address of XBRK structure???
 0Ch	DWORD	???
 10h  2 BYTEs	???
 12h	WORD	segment of ???
 14h  8 BYTEs	???
 1Ch 512 BYTEs	protected-mode IDT
21Ch  N BYTEs	protected-mode GDT
--------E-15BF03-----------------------------
INT 15 - Rational Systems DOS/4GW - UNINSTALL???
	AX = BF03h
	BX = PSP segment of extender
	???
Return: ???
Note:	if BX is not the PSP segment of the extender, it passes the call down
	  the INT 15 chain; this allows nested instances of the extender
SeeAlso: AX=BF06h
--------E-15BF04-----------------------------
INT 15 - Rational Systems DOS/4GW - ???
	AX = BF04h
	BX = PSP segment of extender
Return: nothing???
Notes:	if BX is not the PSP segment of the extender, it passes the call down
	  the INT 15 chain; this allows nested instances of the extender
	grabs INT 2Fh and installs handlers for INT 2F/AX=1605h-1607h
SeeAlso: INT 2F/AX=1607h/BX=22C0h
--------E-15BF05-----------------------------
INT 15 - Rational Systems DOS/4GW - INITIALIZE PROTECTED-MODE INTERFACE
	AX = BF05h
	BX = PSP segment of extender
Return: nothing???
Notes:	if BX is not the PSP segment of the extender, it passes the call down
	  the INT 15 chain; this allows nested instances of the extender
	calls INT 67/AX=DE01h if ???
--------E-15BF06-----------------------------
INT 15 - Rational Systems DOS/4GW - ???
	AX = BF06h
	BX = PSP segment of extender
	???
Return: ???
Note:	if BX is not the PSP segment of the extender, it passes the call down
	  the INT 15 chain; this allows nested instances of the extender
SeeAlso: AX=BF03h
--------E-15BFDCDX0000-----------------------
INT 15 - Rational Systems DOS/4GW - INSTALLATION CHECK
	AX = BFDCh
	DX = 0000h
	SI = 0000h
Return: DX = nonzero if installed
	    DX:SI -> XBRK structure (see AX=BF02h)
SeeAlso: AX=BF02h
--------E-15BFDEBX0000-----------------------
INT 15 - DESQview/X - DVDOS4GX.DVR - INSTALLATION CHECK
	AX = BFDEh
	BX = 0000h
Return: AX = ??? (0003h)
	BX = FFFFh
SeeAlso: AX=BF02h
--------E-15BFDEBX0001-----------------------
INT 15 - DESQview/X 1.02+ - DVDOS4GX.DVR - GET PROCESS MANAGER NAME
	AX = BFDEh
	BX = 0001h
Return: BX = 0000h (success)
	CX:DX -> name of process manager executable
SeeAlso: AX=BFDEh/BX=0000h
--------E-15BFDEBX0002-----------------------
INT 15 - DESQview/X 1.02+ - DVDOS4GX.DVR - SET ???
	AX = BFDEh
	BX = 0002h
	CX:DX -> ???
Return: BX = 0000h (success)
SeeAlso: AX=BFDEh/BX=0000h,AX=BFDEh/BX=0003h
--------E-15BFDEBX0003-----------------------
INT 15 - DESQview/X 1.02+ - DVDOS4GX.DVR - GET ???
	AX = BFDEh
	BX = 0003h
Return: BX = 0000h (success)
	CX:DX -> ???
SeeAlso: AX=BFDEh/BX=0000h,AX=BFDEh/BX=0002h
--------E-15BFDEBX0004-----------------------
INT 15 - DESQview/X 1.02+ - DVDOS4GX.DVR - ???
	AX = BFDEh
	BX = 0004h
	CL = ???
Return: BX = 0000h (success)
	CX:DX -> XBRK structure (see AX=BF02h)
SeeAlso: AX=BFDEh/BX=0000h
--------E-15BFDEBX0005-----------------------
INT 15 - DESQview/X 1.02+ - DVDOS4GX.DVR - ???
	AX = BFDEh
	BX = 0005h
	CX = new value for ???
Return: BX = 0000h (success)
	AX = old value of ???
	DS:SI -> ??? (if AX nonzero on return)
	ES:DI -> ??? (if AX zero on return)
Note:	called by DOS4GW.EXE
SeeAlso: AX=BFDEh/BX=0000h
--------E-15BFDEBX0006-----------------------
INT 15 - DESQview/X 1.02+ - DVDOS4GX.DVR - GET ???
	AX = BFDEh
	BX = 0006h
Return: BX = 0000h (success)
	AH = interrupt number??? (BEh)
	CX:DX = ???
SeeAlso: AX=BFDEh/BX=0000h,AX=BFDEh/BX=0007h,INT BE"DESQview"
--------E-15BFDEBX0007-----------------------
INT 15 - DESQview/X 1.02+ - DVDOS4GX.DVR - SET ???
	AX = BFDEh
	BX = 0007h
	CX:DX = ???
Return: BX = 0000h (success)
SeeAlso: AX=BFDEh/BX=0000h,AX=BFDEh/BX=0006h
--------E-15BFDEBX0008-----------------------
INT 15 - DESQview/X 1.02+ - DVDOS4GX.DVR - ???
	AX = BFDEh
	BX = 0008h
	CX = segment of ???
	DS = ???
Return: BX = status
	    0000h successful
		AL = ??? (80h or C0h)
		DX = ??? (0603h) if AL=C0h
	    0001h failed
		AX = 0000h
Note:	called by DOS4GW.EXE
SeeAlso: AX=BFDEh/BX=0000h
--------E-15BFDEBX0009-----------------------
INT 15 - DESQview/X 1.02+ - DVDOS4GX.DVR - GET PROTECTED MODE PROGRAM LOADER
	AX = BFDEh
	BX = 0009h
Return: BX = 0000h (success)
	CX:DX -> full pathname to LOAD32.EXP
SeeAlso: AX=BFDEh/BX=0000h
--------E-15BFDEBX000A-----------------------
INT 15 - DESQview/X 1.02+ - DVDOS4GX.DVR - DECREMENT ???
	AX = BFDEh
	BX = 000Ah
Return: BX = 0000h (success)
	AX = new value of ??? counter
Notes:	also resets a variety of values if the counter goes negative
	called by DOS4GW.EXE
SeeAlso: AX=BFDEh/BX=0000h,AX=BFDEh/BX=000Bh
--------E-15BFDEBX000B-----------------------
INT 15 - DESQview/X 1.02+ - DVDOS4GX.DVR - INCREMENT ???
	AX = BFDEh
	BX = 000Bh
Return: AX = new value of ??? counter
Note:	called by DOS4GW.EXE
SeeAlso: AX=BFDEh/BX=0000h,AX=BFDEh/BX=000Ah
--------E-15BFDEBX000C-----------------------
INT 15 - DESQview/X 1.02+ - DVDOS4GX.DVR - ???
	AX = BFDEh
	BX = 000Ch
	CL = ???
	    00h
	    nonzero
Return: ???
SeeAlso: AX=BFDEh/BX=0000h
--------E-15BFDEBX000D-----------------------
INT 15 - DESQview/X 1.02+ - DVDOS4GX.DVR - ???
	AX = BFDEh
	BX = 000Dh
	???
Return: ???
SeeAlso: AX=BFDEh/BX=0000h
--------E-15BFDEBX000E-----------------------
INT 15 - DESQview/X 1.02+ - DVDOS4GX.DVR - ???
	AX = BFDEh
	BX = 000Eh
	DX:CX -> ???
Return: AX = segment of handle for calling task
	BX = ??? (probably destroyed)
	DX:CX -> ???
SeeAlso: AX=BFDEh/BX=0000h,AX=BFDEh/BX=000Fh,AX=BFDEh/BX=0013h
--------E-15BFDEBX000F-----------------------
INT 15 - DESQview/X 1.02+ - DVDOS4GX.DVR - ???
	AX = BFDEh
	BX = 000Fh
Return: AX = segment of handle for calling task
	BX = ??? (probably destroyed)
	DX:CX -> ???
Note:	identical to AX=BFDEh/BX=000Eh with CX:DX = 0000h:0000h
SeeAlso: AX=BFDEh/BX=000Eh,AX=BFDEh/BX=0010h
--------E-15BFDEBX0010-----------------------
INT 15 - DESQview/X 1.02+ - DVDOS4GX.DVR - GET TASK HANDLE
	AX = BFDEh
	BX = 0010h
Return: AX = segment of caller's task handle
	BX destroyed
SeeAlso: AX=BFDEh/BX=000Fh
--------E-15BFDEBX0011-----------------------
INT 15 - DESQview/X 1.02+ - DVDOS4GX.DVR - GET ???
	AX = BFDEh
	BX = 0011h
Return: CX = code segment of DVDOS4GX.DVR
	BX = ??? (0004h)
SeeAlso: AX=BFDEh/BX=0000h
--------E-15BFDEBX0012-----------------------
INT 15 - DESQview/X 1.02+ - DVDOS4GX.DVR - GET ???
	AX = BFDEh
	BX = 0012h
Return: DX = code segment of DVDOS4GX.DVR
	BX = ??? (012Ch)
	CX = ??? (0006h)
SeeAlso: AX=BFDEh/BX=0000h
--------E-15BFDEBX0013-----------------------
INT 15 - DESQview/X 1.02+ - DVDOS4GX.DVR - GET ???
	AX = BFDEh
	BX = 0013h
Return: DX:CX -> ???
SeeAlso: AX=BFDEh/BX=000Eh
--------E-15BFDEBX0014-----------------------
INT 15 - DESQview/X 1.02+ - DVDOS4GX.DVR - LOCK ??? MAILBOX
	AX = BFDEh
	BX = 0014h
	CX = index of ??? mailbox
		(0000h-0004h valid, but no range checking done)
Return: AX,BX destroyed
SeeAlso: AX=BFDEh/BX=0015h,AX=BFDEh/BX=0017h
--------E-15BFDEBX0015-----------------------
INT 15 - DESQview/X 1.02+ - DVDOS4GX.DVR - UNLOCK ??? MAILBOX
	AX = BFDEh
	BX = 0015h
	CX = index of ??? mailbox
		(0000h-0004h valid, but no range checking done)
Return: AX,BX destroyed
SeeAlso: AX=BFDEh/BX=0014h,AX=BFDEh/BX=0016h
--------E-15BFDEBX0016-----------------------
INT 15 - DESQview/X 1.02+ - DVDOS4GX.DVR - CHECK IF ??? MAILBOX OWNED
	AX = BFDEh
	BX = 0016h
	CX = index of ??? mailbox
		(0000h-0004h valid, but no range checking done)
Return: AX = status
	    0000h no one owns mailbox
	    0001h mailbox has an owner
	BX destroyed
SeeAlso: AX=BFDEh/BX=0015h,AX=BFDEh/BX=0017h
--------E-15BFDEBX0017-----------------------
INT 15 - DESQview/X 1.02+ - DVDOS4GX.DVR - GET ??? MAILBOX OWNER
	AX = BFDEh
	BX = 0017h
	CX = index of ??? mailbox
		(0000h-0004h valid, but no range checking done)
Return: AX = segment of mailbox owner's handle
	BX = segment of caller's task handle
SeeAlso: AX=BFDEh/BX=0015h,AX=BFDEh/BX=0016h
--------E-15BFDEBXFFFD-----------------------
INT 15 - DESQview/X 1.02+ - DVDOS4GX.DVR - GET ???
	AX = BFDEh
	BX = FFFDh
Return: CX:DX = ???
SeeAlso: AX=BFDEh/BX=FFFEh
--------E-15BFDEBXFFFE-----------------------
INT 15 - DESQview/X 1.02+ - DVDOS4GX.DVR - SET ???
	AX = BFDEh
	BX = FFFEh
	CX:DX = ???
SeeAlso: AX=BFDEh/BX=FFFDh
--------E-15BFDEBXFFFF-----------------------
INT 15 - DESQview/X 1.02+ - DVDOS4GX.DVR - NOP
	AX = BFDEh
	BX = FFFFh
SeeAlso: AX=BFDEh/BX=0000h
--------B-15C0-------------------------------
INT 15 - SYSTEM - GET CONFIGURATION (XT after 1/10/86,AT mdl 3x9,CONV,XT286,PS)
	AH = C0h
Return: CF set if BIOS doesn't support call
	CF clear on success
	    ES:BX -> ROM table (see below)
	AH = status
	    00h successful
	    86h unsupported function
Notes:	the 1/10/86 XT BIOS returns an incorrect value for the feature byte
	the configuration table is at F000h:E6F5h in 100% compatible BIOSes
	Dell machines contain the signature "DELL" or "Dell" at absolute FE076h
	  and a model byte at absolute address FE845h
	Tandy 1000 machines contain 21h in the byte at F000h:C000h
	some AST machines contain the string "COPYRIGHT AST RESEARCH" one byte
	  past the end of the configuration table
	the Phoenix 386 BIOS contains a second version and date string
	  (presumably the last modification for that OEM version) beginning at
	  F000h:FFD8h, with each byte doubled (so that both ROM chips contain
	  the complete information)
SeeAlso: AH=C7h,AH=C9h,AH=D1h

Format of ROM configuration table:
Offset	Size	Description
 00h	WORD	number of bytes following
 02h	BYTE	model (see below)
 03h	BYTE	submodel (see below)
 04h	BYTE	BIOS revision: 0 for first release, 1 for 2nd, etc.
 05h	BYTE	feature byte 1:
		bit 7: DMA channel 3 used by hard disk BIOS
		bit 6: 2nd 8259 installed
		bit 5: Real-Time Clock installed
		bit 4: INT 15/AH=4Fh called upon INT 09h
		bit 3: wait for external event (INT 15/AH=41h) supported
		bit 2: extended BIOS area allocated (usually at top of RAM)
		bit 1: bus is Micro Channel instead of ISA
		bit 0: system has dual bus (Micro Channel + ISA)
 06h	BYTE	feature byte 2:
		bit 7: reserved
		bit 6: INT 16/AH=09h (keyboard functionality) supported
		bit 5: INT 15/AH=C6h (get POS data) supported
		bit 4: INT 15/AH=C7h (return memory map info) supported
		bit 3: INT 15/AH=C8h (en/disable CPU functions) supported
		bit 2: non-8042 keyboard controller
		bit 1: data streaming supported
		bit 0: reserved
 07h	BYTE	feature byte 3:
		bits 7-5 reserved
		bit 4: ??? (set on 1992 PS/1's, N51SX, CL57SX, 35SX?, 40SX?)
		bit 3: SCSI subsystem supported on system board
		bit 2: information panel installed
		bit 1: IML (Initial Machine Load) system
		bit 0: SCSI supported in IML
 08h	BYTE	feature byte 4:
		bit 7: ??? (set on N51SX, CL57SX)
		bits 6-4: reserved
		bit 3: ??? (set on some 1992 PS/1's, 35SX, 40SX)
		bits 2-1: reserved
		bit 0: ??? (set on N51SX, CL57SX, 57SX)
 09h	BYTE	feature byte 5:
		reserved (0) (IBM)
		??? (08h) (Phoenix 386 v1.10)
---AWARD BIOS---
 0Ah  N BYTEs	AWARD copyright notice
---Phoenix BIOS---
 0Ah	BYTE	??? (00h)
 0Bh	BYTE	major version
 0Ch	BYTE	minor version (BCD)
 0Dh  4 BYTEs	ASCIZ string "PTL" (Phoenix Technologies Ltd)
---Quadram Quad386---
 0Ah 17 BYTEs	ASCII signature string "Quadram Quad386XT"

Values for model/submodel/revision:
Model  Submdl  Rev	BIOS date	System
 FFh	*	*	04/24/81	PC (original)
 FFh	*	*	10/19/81	PC (some bugfixes)
 FFh	*	*	10/27/82	PC (HD, 640K, EGA support)
 FFh	46h	***	  ???		Olivetti M15
 FEh	*	*	08/16/82	PC XT
 FEh	*	*	11/08/82	PC XT and Portable
 FEh	43h	***	  ???		Olivetti M240
 FEh	A6h	???	  ???		Quadram Quad386
 FDh	*	*	06/01/83	PCjr
 FCh	*	*	01/10/84	AT models 068,099 6 MHz 20MB
 FCh	00h	01h	06/10/85	AT model  239	  6 MHz 30MB
 FCh	00h	<> 01h	  ???		7531/2 Industrial AT
 FCh	01h	00h	11/15/85	AT models 319,339 8 MHz, Enh Keyb, 3.5"
 FCh	01h	00h	09/17/87	Tandy 3000
 FCh	01h	00h	01/15&88	Toshiba T5200/100
 FCh	01h	00h	12/26*89	Toshiba T1200/XE
			(Those date characters are not typos)
 FCh	01h	30h	  ???		Tandy 3000NL
 FCh	01h	???	  ???		Compaq 286/386
 FCh	02h	00h	04/21/86	PC XT-286
 FCh	04h	00h	02/13/87     ** PS/2 Model 50 (10 MHz/1 ws 286)
 FCh	04h	03h	04/18/88	PS/2 Model 50Z (10 MHz/0 ws 286)
 FCh	05h	00h	02/13/87     ** PS/2 Model 60 (10 MHz 286)
 FCh	06h	???	  ???		7552 "Gearbox"
 FCh	08h	***	  ???		Epson, unknown model
 FCh	09h	00h	  ???		PS/2 Model 25 (10 MHz 286)
 FCh	09h	02h	06/28/89	PS/2 Model 30-286
 FCh	0Bh	00h	02/16/90	PS/1 Model 2011 (10 MHz 286)
 FCh	30h	***	  ???		Epson, unknown model
 FCh	31h	***	  ???		Epson, unknown model
 FCh	33h	***	  ???		Epson, unknown model
 FCh	42h	***	  ???		Olivetti M280
 FCh	45h	***	  ???		Olivetti M380 (XP 1, XP3, XP 5)
 FCh	48h	***	  ???		Olivetti M290
 FCh	4Fh	***	  ???		Olivetti M250
 FCh	50h	***	  ???		Olivetti M380 (XP 7)
 FCh	51h	***	  ???		Olivetti PCS286
 FCh	52h	***	  ???		Olivetti M300
 FCh	81h	00h	01/15/88	Phoenix 386 BIOS v1.10 10a
 FBh	00h	01h	01/10/86	PC XT, Enh Keyb, 3.5" support
 FBh	00h	02h	05/09/86	PC XT
 FBh	4Ch	***	  ???		Olivetti M200
 FAh	00h	00h	09/02/86	PS/2 Model 30 (8 MHz 8086)
 FAh	00h	01h	12/12/86	PS/2 Model 30
 FAh	01h	00h	  ???		PS/2 Model 25/25L (8 MHz 8086)
 FAh	4Eh	***	  ???		Olivetti M111
 F9h	00h	00h	09/13/85	PC Convertible
 F8h	00h	00h	03/30/87     ** PS/2 Model 80 (16MHz 386)
 F8h	01h	00h	10/07/87	PS/2 Model 80 (20MHz 386)
 F8h	04h	02h	04/11/88	PS/2 Model 70 20MHz, type 2 system brd
 F8h	04h	03h	03/17/89	PS/2 Model 70 20MHz, type 2 system brd
 F8h	09h	00h	  ???		PS/2 Model 70 16MHz, type 1 system brd
 F8h	09h	02h	04/11/88	PS/2 Model 70 some models
 F8h	09h	03h	03/17/89	PS/2 Model 70 some models
 F8h	0Bh	00h	01/18/89	PS/2 Model P70 (8573-121) typ 2 sys brd
 F8h	0Bh	02h	12/16/89	PS/2 Model P70 ??
 F8h	0Ch	00h	11/02/88	PS/2 Model 55SX (16 MHz 386SX)
 F8h	0Dh	00h	  ???		PS/2 Model 70 25MHz, type 3 system brd
 F8h	11h	00h	10/01/90	PS/2 Model 90 (25 MHz 486)
 F8h	13h	00h	10/01/90	PS/2 Model 90 (33 MHz 486)
 F8h	14h	00h	10/01/90	PS/2 Model 90-AK9 (25 MHz 486)
 F8h	16h	00h	10/01/90	PS/2 Model 90-AKD (33 MHz 486)
 F8h	19h	05h	  ???		PS/2 Model 35/35LS or 40 (20 MHz 386SX)
 F8h	1Bh	00h	10/02/89	PS/2 Model 70-486 (25 MHz 486)
 F8h	1Ch	00h	02/08/90	PS/2 Model 65-121 (16 MHz 386SX)
 F8h	1Eh	00h	02/08/90	PS/2 Model 55LS (16 MHz 386SX)
 F8h	23h	01h	  ???		PS/2 Model L40 (20 MHz 386SX)
 F8h	25h	06h	  ???		PS/2 Model M57 (20 MHz 386SLC)
 F8h	26h	01h	  ???		PS/2 Model 57 (20 MHz 386SX)
 F8h	2Ah	00h	  ???		PS/2 Model 95 (50 MHz 486)
 F8h	2Bh	00h	  ???		PS/2 Model 90 (50 MHz 486)
 F8h	2Ch	01h	  ???		PS/2 Model 95 (20 MHz 486SX)
 F8h	2Dh	00h	  ???		PS/2 Model 90 (20 MHz 486SX)
 F8h	2Eh	01h	  ???		PS/2 Model 95 (20 MHz 486SX + 487SX)
 F8h	2Fh	00h	  ???		PS/2 Model 90 (20 MHz 486SX + 487SX)
 F8h	30h	00h	  ???		PS/1 Model 2121 (16 MHz 386SX)
 F8h	50h	00h	  ???		PS/2 Model P70 (8573) (16 MHz 386)
 F8h	50h	01h	12/16/89	PS/2 Model P70 (8570-031)
 F8h	52h	00h	  ???		PS/2 Model P75 (33 MHz 486)
 F8h	61h	***	  ???		Olivetti P500
 F8h	62h	***	  ???		Olivetti P800
 F8h	80h	00h	  ???		PS/2 Model 80 (25 MHz 386)
 F8h	80h	01h	11/21/89	PS/2 Model 80-A21
 F8h	???	???	  ???		PS/2 Model 90 (25 MHz 486SX)
 F8h	???	???	  ???		PS/2 Model 95 (25 MHz 486SX)
 F8h	???	???	  ???		PS/2 Model 90 (25 MHz 486SX + 487SX)
 F8h	???	???	  ???		PS/2 Model 95 (25 MHz 486SX + 487SX)
 E1h	???	???	  ???		??? (checked for by DOS4GW.EXE)
 9Ah	*	*	  ???		Compaq XT/Compaq Plus
 30h	???	???	  ???		Sperry PC
 2Dh	*	*	  ???		Compaq PC/Compaq Deskpro
 ???	56h	???	  ???		Olivetti, unknown model
 ???	74h	???	  ???		Olivetti, unknown model
    * This BIOS call is not implemented in these early versions.
      Read Model byte at F000h:FFFEh and BIOS date at F000h:FFF5h.
   ** These BIOS versions require the DASDDRVR.SYS patches.
  *** These Olivetti and Epson machines store the submodel in the byte at
	F000h:FFFDh.

Values for Dell model byte:
 02h	Dell 200
 03h	Dell 300
 05h	Dell 220
 06h	Dell 310
 07h	Dell 325
 09h	Dell 310A
 0Ah	Dell 316
 0Bh	Dell 220E
 0Ch	Dell 210
 0Dh	Dell 316SX
 0Eh	Dell 316LT
 0Fh	Dell 320LX
 11h	Dell 425E
--------B-15C1-------------------------------
INT 15 - SYSTEM - RETURN EXTENDED-BIOS DATA-AREA SEGMENT ADDRESS (PS)
	AH = C1h
Return: CF set on error
	CF clear if successful
	    ES = segment of data area
SeeAlso: AH=04h"ABIOS"
--------M-15C200-----------------------------
INT 15 - SYSTEM - POINTING DEVICE BIOS INTERFACE (PS) - ENABLE/DISABLE
	AX = C200h
	BH = new state
	    00h disabled
	    01h enabled
Return: CF set on error
	AH = status
	    00h successful
	    01h invalid function
	    02h invalid input
	    03h interface error
	    04h need to resend
	    05h no device handler installed
--------M-15C201-----------------------------
INT 15 - SYSTEM - POINTING DEVICE BIOS INTERFACE (PS) - RESET
	AX = C201h
Return: CF set on error
	    AH = status (see AX=C200h)
	CF clear if successful
	    BH = device ID
	    BL = value returned by attached device after reset
		AAh if device is a mouse
Note:	after successful completion of this call, the pointing device is set
	  as follows: disabled, sample rate 100 Hz, resolution 4 counts/mm,
	  scaling 1:1, unchanged data package size
SeeAlso: INT 33/AX=0000h
--------M-15C202-----------------------------
INT 15 - SYSTEM - POINTING DEVICE BIOS INTERFACE (PS) - SET SAMPLING RATE
	AX = C202h
	BH = sampling rate
	    00h 10/second
	    01h 20/second
	    02h 40/second
	    03h 60/second
	    04h 80/second
	    05h 100/second
	    06h 200/second
Return: CF set on error
	    AH = status (see AX=C200h)
SeeAlso: INT 33/AX=001Ch
--------M-15C203-----------------------------
INT 15 - SYSTEM - POINTING DEVICE BIOS INTERFACE (PS) - SET RESOLUTION
	AX = C203h
	BH = resolution
	    00h one count per mm
	    01h two counts per mm
	    02h four counts per mm
	    03h eight counts per mm
Return: CF set on error
	    AH = status (see AX=C200h)
--------M-15C204-----------------------------
INT 15 - SYSTEM - POINTING DEVICE BIOS INTERFACE (PS) - GET TYPE
	AX = C204h
Return: CF set on error
	    AH = status (see AX=C200h)
	CF clear if successful
	    BH = device ID
--------M-15C205-----------------------------
INT 15 - SYSTEM - POINTING DEVICE BIOS INTERFACE (PS) - INITIALIZE
	AX = C205h
	BH = data package size (1 - 8 bytes)
Return: CF set on error
	    AH = status (see AX=C200h)
Note:	the pointing device is set as follows: disabled, 100 Hz sample rate,
	  resolution 4 counts/mm, scaling 1:1
SeeAlso: AX=C201h
--------M-15C206-----------------------------
INT 15 - SYSTEM - POINTING DEVICE BIOS INTERFACE (PS) - EXTENDED COMMANDS
	AX = C206h
	BH = subfunction
	    00h return device status
		Return: BL = pointing device status (see below)
			CL = resolution (see AX=C203h)
			DL = sample rate, reports per second
	    01h set scaling at 1:1
	    02h set scaling at 2:1
Return: CF set on error
	    AH = status (see AX=C200h)

Bitfields for pointing device status:
 bit 0	right button pressed
 bit 1	reserved
 bit 2	left button pressed
 bit 3	reserved
 bit 4	0 if 1:1 scaling, 1 if 2:1 scaling
 bit 5	device enabled
 bit 6	0 if stream mode, 1 if remote mode
 bit 7	reserved
--------M-15C207-----------------------------
INT 15 - SYSTEM - POINTING DEVICE BIOS INTERFACE (PS) - SET DEVICE HANDLER ADDR
	AX = C207h
	ES:BX -> FAR user device handler
Return: CF set on error
	    AH = status (see AX=C200h)
Note:	when the subroutine is called, it is passed the following values on
	  the stack; the handler should return with a FAR return without
	  popping the stack:
		WORD 1: status (see below)
		WORD 2: X data (high byte = 00h)
		WORD 3: Y data (high byte = 00h)
		WORD 4: 0000h
SeeAlso: INT 33/AX=000Ch

Bitfields for status:
 bits 15-8 reserved (0)
 bit 7	Y data overflowed
 bit 6	X data overflowed
 bit 5	Y data is negative
 bit 4	X data is negative
 bit 3	reserved (1)
 bit 2	reserved (0)
 bit 1	right button pressed
 bit 0	left button pressed
--------B-15C3------------------------------
INT 15 - SYSTEM - ENABLE/DISABLE WATCHDOG TIMEOUT (PS50+)
	AH = C3h
	AL = function
	    00h disable PS/2 watchdog timer
	    01h enable PS/2 watchdog timer
		BX = timer counter (0001h-00FFh)
	    02h disable Gearbox system
	    03h enable Gearbox system
Return: CF set on error
	CF clear if successful
Note:	the watchdog timer generates an NMI
--------B-15C4-------------------------------
INT 15 - SYSTEM - PROGRAMMABLE OPTION SELECT (PS50+)
	AH = C4h
	AL = subfunction
	    00h return base POS register address
	    01h enable selected slot for setup
		BL = slot number (1 to 8)
	    02h disable setup for all slots
Return: CF set on error
	DX = base POS register address (if subfunction 00h)
SeeAlso: AH=C6h
--------B-15C5-------------------------------
INT 15 UC - OS HOOK - ROM BIOS TRACING CALLOUT (PS30/286,PS50Z,PS95)
	AH = C5h
	AL = interrupt being invoked
	    01h INT 19
	    02h INT 14
	    03h INT 16
	    04h INT 40 (floppy INT 13)
	    05h INT 17
	    06h INT 10
	    07h INT 12
	    08h INT 11
	    09h INT 1A
Return: all registers except AX must be preserved
Notes:	called as the very first action of the indicated ROM BIOS interrupt
	  handlers on the PS/2 Models 30/286, 50Z, and 95
	default handler does nothing and returns CF clear for the above
	  subfunctions, CF set and AH=86h for all other subfunctions
	value of AX passed to the original interrupt handler is pushed on
	  stack immediately prior to call
--------B-15C6-------------------------------
INT 15 U - later PS/2 models - GET POS DATA
	AH = C6h
	???
Return: ???
Notes:	this function is referenced by name and number in some IBM BIOS manuals
	IBM reports that "there are a number of problems with this call" and
	  does not recommend its use.
SeeAlso: AH=C4h
--------B-15C7-------------------------------
INT 15 - SYSTEM - later PS/2s - RETURN MEMORY-MAP INFORMATION
	AH = C7h
	DS:SI -> user supplied memory map table (see below)
Note:	call AH=C0h and examine bit 4 of feature byte 2 to check if this
	  function is supported
Return: CF set on error, clear if successful
SeeAlso: AH=C0h,AH=C9h,AH=D1h

Format of memory-map table structure:
Offset	Size	Description
 00h	WORD	length of table (excluding this word)
 02h	DWORD	local memory between 1M and 16M, in 1K blocks
 06h	DWORD	local memory between 16M and 4G, in 1K blocks
 0Ah	DWORD	system memory between 1M and 16M, in 1K blocks
 0Eh	DWORD	system memory between 16M and 4G, in 1K blocks
 12h	DWORD	cacheable memory between 1M and 16M, in 1K blocks
 16h	DWORD	cacheable memory between 16M and 4G, in 1K blocks
 1Ah	DWORD	1K blocks before start of non-system memory between 1M and 16M
 1Eh	DWORD	1K blocks before start of non-system memory between 16M and 4G
 22h  2 DWORDs	reserved
--------B-15C8-------------------------------
INT 15 - SYSTEM - ENABLE/DISABLE PROCESSOR FUNCTIONS
	AH = C8h
	AL = function
	    00h disable cache or (90 and 95) disable cache L1
	    01h enable cache or (90 and 95) enable cache L1
	    ---models 90 and 95 only---
	    02h disable cache L2
	    03h enable cache L2
	    04h disable both caches
	    05h enable both caches
	    06h return status of both caches
	    07h-FFh Reserved
Return: CF set on error
	CF clear if successful
	    AH = status (see below)
	For subfunction 06h only:
	    BH = status of cache L2
		00h enabled
		01h disabled or not installed
	    BL = status of cache L1 (same codes as BH)
Notes:	 supported by at least PS/2 70, 70/486, 80-A21, 90, 95
	call AH=C0h and examine bit 3 of feature byte 2 to check if this
	  function is supported.
	on a 486 system, any external caches must be disabled when the
	  on-chip cache (L1) is disabled.
SeeAlso: AH=C0h

Values for status:
 00h	operation successful
 01h	function choice (in AL) is invalid
 02h	NVRAM data is invalid
 03h	cache test error
 04h	(90 and 95 only) cannot perform operation requested due to state of
	  other cache (see note above)
 05h	no L2 cache is present
--------B-15C9-------------------------------
INT 15 - newer PS/2; various BIOSes - GET CPU TYPE AND MASK REVISION
	AH = C9h
	AL = 10h (may be required on some non-PS BIOSes)
Return: CF clear if successful
	    AH = 00h
	    CH = CPU type
		03h 80386DX or clone
		04h 80486
		23h 80386SX or clone
	    CL = mask revision (stepping level)
		80386:
		    03h B1
		    05h D0
		    08h D1/D2/E1
		80386SX
		    08h D1
	CF set on error
	    AH = status (80h,86h = function not supported)
Notes:	the BIOS must save DX at startup in order to be able to support this
	  call; PS/2 Models 56, 57, 90, and 95 are known to support it
	the PS/2 BIOS merely reads CMOS locations 190h (type) and 191h (rev)
--------B-15CA-------------------------------
INT 15 U - PS/2 Model 95 - RESERVED
	AH = CAh
	???
Return: ???
--------B-15CB-------------------------------
INT 15 U - PS/2 Model 95 - RESERVED
	AH = CBh
	???
Return: ???
--------B-15CC-------------------------------
INT 15 U - PS/2 Model 95 - RESERVED
	AH = CCh
	???
Return: ???
--------B-15CD-------------------------------
INT 15 U - PS/2 Model 95 - RESERVED
	AH = CDh
	???
Return: ???
--------B-15CE--BL00-------------------------
INT 15 - later PS/2s - ALLOCATE DMA ARBITRATION LEVEL
	AH = CEh
	BL = 00h-0Eh arbitration level to be allocated
	     0Fh-FFh reserved
	AL = option byte
	    bit 7-1: reserved (0)
	    bit 0: 0 = need DMA channel for arbitration level requested
		   1 = no channel required for arbitration level
Return: CF set on error
	    AH = status (80h,86h = function not supported)
	CF clear on success
	    AL = channel number
		00h-07h channel number allocated for the arbiration level
		08h-FEh reserved
		FFh	no channel requested for arbitration level
	    AH = status
		00h success
		01h arbitration level not available
		02h channel not available
		03h invalid arbitration level passed
Notes:	 arbitration level 00h has the highest priority, 0Eh the lowest
	 to perform a DMA transfer operation, be sure to call this function
	   first, and call AH=CFh afterward.  Failure to use this function
	   can cause unpredictable results.
SeeAlso: AH=CFh
--------B-15CF-------------------------------
INT 15 - later PS/2s - DEALLOCATE DMA ARBITRATION LEVEL
	AH = CFh
	BL = arbitration level to be deallocated (see AH=CEh)
Return: CF set on error
	    AH = status (80h,86h = function not supported)
	CF clear on success
	    AH = status
		00h success
		04h arbitration level not allocated
SeeAlso: AH=CEh
--------B-15D0-------------------------------
INT 15 - later PS/2s - RESERVED
	AH = D0h
	???
Return: ???
--------B-15D100DX0000-----------------------
INT 15 - later PS/2s - GET NUMBER OF DEVICE DESCRIPTOR TABLE (DDT) ENTRIES
	AX = D100h
	DX = 0000h (reserved, must set to 0)
Return: BL = size of one DDT entry, in bytes
	CX = number of DDT entries
	AH = return code (see below)
	CF set on error
	CF clear on success
SeeAlso: AH=C0h,AH=C7h,AH=C9h,AX=D101h,AX=D102h,AX=D103h,AX=D104h

Values for return code:
 00h	success
 01h	requested DDT entry not found
 02h	DDT data not valid
 86h	function not supported
--------B-15D101-----------------------------
INT 15 - later PS/2s - RETURN DEVICE DESCRIPTOR TABLE (DDT) ENTRY BY NUMBER
	AX = D101h
	BX = number of requested entry (starting with 1)
	DX = 0000h (reserved, must be set to 0)
	ES:DI -> buffer to contain DDT entry (see below)
Return:	AH = return code (see AX=D100h)
	CF set on error
	CF clear on success
	    ES:DI buffer filled with DDT entry
SeeAlso: AH=C0h,AH=C7h,AH=C9h,AX=D100h,AX=D102h,AX=D104h

Format of DDT:
Offset	Size	Description
 00h	BYTE	bits 7-4: reserved (set to 0)
		bits 3-0: slot of device (0 = system board)
 01h	BYTE	bits 7-4: second interrupt for this device (0 = none)
		bits 3-0: first interrupt for this device (0 = none)
 02h	BYTE	bits 7-4: second arbitration level for this device
		bits 3-0: first arbitration level for this device
 03h	WORD	DDT indicators (see below)
 05h	BYTE	reserved (0)
 06h	WORD	device ID (0 = none)
 08h	WORD	starting address of first  I/O block (0 = none)
 0Ah	WORD	starting address of second I/O block (0 = none)
 OCh	WORD	starting address of third  I/O block (0 = none)
 OEh	DWORD	start of first non-system memory block (0 = none)
 12h	WORD	size of first non-system memory block (in kilobytes)
 14h	DWORD	start of second non-system memory block (0 = none)
 18h	WORD	size of second non-system memory block (in kilobytes)
 1Ah	BYTE	implementation identifier of the device
 1Bh	BYTE	implementation revision level of the device
Note:	I/O block addresses and non-system memory addresses are listed in
	  ascending order in each DDT entry.

Bitfields for DDT indicators:
 bit 15 reserved (0)
 bit 14 second arbitration level exists
 bit 13 first arbitration level exists
 bit 12 serial interface is RS-422
 bit 11 not address limited
 bit 10 DMA channel used
 bit 9	second arbitration level can be shared
 bit 8	first arbitration level can be shared
 bits 7-0 reserved (0)
--------B-15D102-----------------------------
INT 15 - later PS/2s - RETURN DEVICE DESCRIPTOR TABLE (DDT) ENTRY BY I/O ADDRSS
	AX = D102h
	BX = entry number at which to start searching
	CX = requested I/O port address
	DX = 0000h (reserved, must be set to 0)
	ES:DI -> buffer to contain DDT entry (see AX=D101h)
Return:	AH = return code (see AX=D100h)
	BX = DDT entry number where I/O port was found, or total entries
	     plus 1 if port was not found.
	CF set on error
	CF clear on success
	    ES:DI buffer filled with DDT entry
Desc:	the DDT is searched from the specified entry for the I/O port in CX,
	  and the first entry in which it is found is returned
SeeAlso: AH=C0h,AH=C7h,AH=C9h,AX=D100h,AX=D101h,AX=D103h,AX=D104h
--------B-15D103DX0000-----------------------
INT 15 - later PS/2s - RETURN ENTIRE DDT
	AX = D103h
	DX = 0000h (reserved, must be set to 0)
	ES:DI -> buffer to contain DDT entry (see AX=D101h)
Return:	AH = return code (see AX=D100h)
	CF set on error
	CF clear on success
	    ES:DI buffer filled with DDT entry
SeeAlso: AH=C0h,AH=C7h,AH=C9h,AX=D100h,AX=D104h
--------B-15D104-----------------------------
INT 15 - later PS/2s - RETURN DEVICE DESCRIPTOR TABLE (DDT) ENTRY BY DEVICE ID
	AX = D104h
	BX = entry number at which to start searching
	CX = requested device ID
	DX = 0000h (reserved, must be set to 0)
	ES:DI -> buffer to contain DDT entry (see AX=D101h for format)
Return:	AH = return code (see AX=D100h)
	BX = DDT entry number where device ID was found, or total entries
	     plus 1 if port was not found.
	CF set on error
	CF clear on success
	    ES:DI buffer filled with DDT entry
Desc:	the DDT is searched from the specified entry for the device ID in CX,
	  and the first entry in which it is found is returned.
SeeAlso: AH=C0h,AH=C7h,AH=C9h,AX=D100h,AX=D101h,AX=D103h
--------B-15D2-------------------------------
INT 15 - later PS/2s - RESERVED
	AH = D2h
	???
Return: ???
--------B-15D3-------------------------------
INT 15 - later PS/2s - RESERVED
	AH = D3h
	???
Return: ???
--------B-15D4-------------------------------
INT 15 - later PS/2s - GET PHYSICAL FIXED DISK DRIVE NUMBER (SELECTABLE BOOT)
	AH = D4h
	DL = logical fixed disk drive number
Return:	AH = return code
	    00h success
	    01h specified logical drive number is invalid
	    86h function not supported
	    80h function not supported (on PCjr and PC)
	CF set on error
	CF clear on success
	    AL = physical fixed disk drive number
--------B-15D5-------------------------------
INT 15 - later PS/2s - RESERVED
	AH = D5h
	???
Return: ???
--------B-15D600BL00-------------------------
INT 15 - later PS/2s - READ BOOT DEVICE ID
	AX = D600h
	BL = 00h
	DX = device ID
Return: CF clear if successful
	    AH = 00h
	CF set on error
	    AH = status (86h for function not supported)
SeeAlso: AX=D600h/BL=01h,AX=D601h/BL=00h,AX=D602h
--------B-15D600BL01-------------------------
INT 15 - later PS/2s - WRITE BOOT DEVICE ID
	AX = D600h
	BL = 01h
	DX = device ID
Return: CF clear on success
	    AH = 00h
	CF set on error
	    AH = status (86h for function not supported)
SeeAlso: AX=D600h/BL=00h,AX=D601h/BL=01h
--------B-15D601BL00-------------------------
INT 15 - later PS/2s - READ BOOT DEVICE KEY
	AX = D601h
	BL = 00h
	DX = device ID
Return: CF clear on success
	    AH = 00h
	CF set on error
	    AH = status (86h for function not supported)
SeeAlso: AX=D600h/BL=00h,AX=D601h/BL=01h,AX=D602h
--------B-15D601BL01-------------------------
INT 15 - later PS/2s - WRITE BOOT DEVICE KEY
	AX = D601h
	BL = 01h
	DX = device ID
Return: CF clear on success
	    AH = 00h
	CF set on error
	    AH = status (86h for function not supported)
SeeAlso: AX=D600h/BL=01h,AX=D601h/BL=00h
--------B-15D602-----------------------------
INT 15 - later PS/2s - QUERY BOOT REFERENCE PARTITION
	AX = D602h
Return: CF clear on success
	    AH = 00h
	    AL = status of reference-partition boot request
		00h boot not requested
		01h boot requested
	CF set on error
	    AH = status (86h for function not supported)
SeeAlso: AX=D601h/BL=00h
--------X-15D800-----------------------------
INT 15 - EISA SYSTEM ROM - READ SLOT CONFIGURATION INFORMATION
	AX = D800h
	CL = slot number (including embedded and virtual)
Return: CF clear if successful
	    AH = 00h
	CF set on error
	    AH = error code
		80h invalid slot number
		82h EISA CMOS corrupt
		83h empty slot
		86h invalid BIOS-FW function call
		87h invalid system configuration
	AL bit flags
	    bit 7: set if duplicate IDs
	    bit 6: set if product ID readable
	    bits 4,5: slot type (00=expansion, 01=embedded, 10=virtual device)
	    bits 0-3: duplicate ID number if bit 7 set
	BH = major revision level of configuration utility
	BL = minor revision level of configuration utility
	CX = checksum of configuration file
	DH = number of device functions
	DL = combined function information byte
	SI:DI = 4-byte compressed ID (DI = bytes 0&1, SI = bytes 2&3)
Note:	call with AL=80h if using 32-bit CS addressing mode instead of 16-bit
SeeAlso: AX=D801h,AX=D804h
--------X-15D801-----------------------------
INT 15 - EISA SYSTEM ROM - READ FUNCTION CONFIGURATION INFORMATION
	AX = D801h
	CH = function number to read
	CL = slot number (including embedded and virtual)
	DS:SI -> 320-byte buffer for standard configuration data block
Return: CF clear if successful
	    AH = 00h
	    DS:SI buffer filled
	CF set on error
	    AH = error code
		80h invalid slot number
		81h invalid function number
		82h EISA CMOS corrupt
		83h empty slot
		86h invalid BIOS-FW function call
		87h invalid system configuration
	BX destroyed
Note:	call with AL=81h if using 32-bit CS addressing mode instead of 16-bit
--------X-15D802-----------------------------
INT 15 - EISA SYSTEM ROM - CLEAR NONVOLATILE MEMORY (EISA CMOS)
	AX = D802h
	BH = EISA config utility major revision level
	BL = EISA config utility minor revision level
Return: CF clear if successful
	    AH = 00h
	CF set on error
	    AH = error code
		84h error clearing CMOS
		86h invalid BIOS-FW function call
		88h config utility version not supported
Note:	call with AL=82h if using 32-bit CS addressing mode instead of 16-bit
SeeAlso: AX=D803h
--------X-15D803-----------------------------
INT 15 - EISA SYSTEM ROM - WRITE NONVOLATILE MEMORY
	AX = D803h
	CX = length of data structure (0000h = empty slot)
		includes two bytes for config file checksum
	DS:SI -> configuration data
Return: CF clear if successful
	    AH = 00h
	CF set on error
	    AH = error code
		84h error clearing CMOS
		85h EISA CMOS is full
		86h invalid BIOS-FW function call
Note:	call with AL=83h if using 32-bit CS addressing mode instead of 16-bit
SeeAlso: AX=D802h
--------X-15D804-----------------------------
INT 15 - EISA SYSTEM ROM - READ PHYSICAL SLOT
	AX = D804h
	CL = slot number (including embedded and virtual)
Return: CF clear if successful
	    AH = 00h
	CF set on error
	    AH = error code
		80h invalid slot number
		83h empty slot
		86h invalid BIOS-FW function call
	SI:DI = 4-byte compressed ID (DI = bytes 0&1, SI = bytes 2&3)
Note:	call with AL=84h if using 32-bit CS addressing mode instead of 16-bit
SeeAlso: AX=D800h
--------X-15D8-------------------------------
INT 15 - EISA SYSTEM ROM - 32-bit CS ADDRESSING MODE CALLS
	AH = D8h
	AL = 80h to 84h
	other registers as appropriate for AL=00h to 04h
Return: as appropriate for AL=00h to 04h
Note:	these functions are identical to AX=D800h to D804h, except that they
	  should be called when using 32-bit CS addressing mode (pointers use
	  ESI rather than SI as offset) instead of 16-bit addressing mode
SeeAlso: AX=D800h,AX=D801h,AX=D802h,AX=D803h,AX=D804h
--------Q-15DE00-----------------------------
INT 15 - DESQview - GET PROGRAM NAME
	AX = DE00h
Return: AX = offset into DESQVIEW.DVO of program most recently selected from
		the "Switch Windows" menu (see below)
Note:	always returns AX=0000h under DESQview/X
SeeAlso: AX=DE07h

Format of program entry in DESQVIEW.DVO:
Offset	Size	Description
 00h	BYTE	length of name (FFh if end of file)
 01h  N BYTEs	name
      2 BYTEs	keys to invoke program (second = 00h if only one key used)
	BYTE	program type
		00h normal program
		04h divider
		80h Delete a Program
		81h Change a Program
	WORD	??? apparently always 0000h
--------Q-15DE01-----------------------------
INT 15 - DESQview - UPDATE "OPEN WINDOW" MENU
	AX = DE01h
Return: nothing
Notes:	reads DESQVIEW.DVO, disables Open menu if file not in current directory
	NOP for DESQview/X
--------Q-15DE02-----------------------------
INT 15 - DESQview 1.x only - SET ??? FLAG FOR CURRENT WINDOW
	AX = DE02h
Return: nothing
Note:	this call is a NOP in DV 2.x
SeeAlso: AX=DE03h
--------Q-15DE03-----------------------------
INT 15 - DESQview 1.x only - GET ??? FOR CURRENT WINDOW
	AX = DE03h
Return: AX = ??? for current window
	BX = ??? for current window
Note:	this call is a NOP in DV 2.x
SeeAlso: AX=DE02h
--------Q-15DE04-----------------------------
INT 15 - DESQview - GET AVAILABLE COMMON MEMORY
	AX = DE04h
Return: BX = bytes of common memory available
	CX = largest block available
	DX = total common memory in bytes
SeeAlso: AX=DE05h,AX=DE06h
--------Q-15DE05-----------------------------
INT 15 - DESQview - GET AVAILABLE CONVENTIONAL MEMORY
	AX = DE05h
Return: BX = KB of memory available
	CX = largest block available
	DX = total conventional memory in KB
SeeAlso: AX=DE04h,AX=DE06h
--------Q-15DE06-----------------------------
INT 15 - DESQview - GET AVAILABLE EXPANDED MEMORY
	AX = DE06h
Return: BX = KB of expanded memory available
	CX = largest block available
	DX = total expanded memory in KB
SeeAlso: AX=DE04h,AX=DE05h
--------Q-15DE07-----------------------------
INT 15 - DESQview - "APPNUM" - GET CURRENT PROGRAM'S NUMBER
	AX = DE07h
Return: AX = number of program as it appears on the "Switch Windows" menu
Note:	this API call may be made from a hardware interrupt handler
SeeAlso: AX=DE00h
--------Q-15DE08-----------------------------
INT 15 - DESQview - GET ???
	AX = DE08h
Return: AX = 0000h if ??? is not set to the current task
	     0001h if ??? is set to the current task
--------Q-15DE09-----------------------------
INT 15 - DESQview - UNIMPLEMENTED
	AX = DE09h
Return: nothing (NOP in DV 1.x and 2.x)
--------Q-15DE0A-----------------------------
INT 15 - DESQview v2.00+ - "DBGPOKE" - DISPLAY CHARACTER ON STATUS LINE
	AX = DE0Ah
	BL = character
Return: character displayed, next call will display in next position (which
	wraps back to the start of the line if off the right edge of screen)
Notes:	displays character on bottom line of *physical* screen, regardless
	  of current size of window (even entirely hidden)
	does not know about graphics display modes, just pokes the characters
	  into display memory
	this API call may be made from a hardware interrupt handler
SeeAlso: AX=1003h
--------Q-15DE0B-----------------------------
INT 15 - DESQview v2.00+ - "APILEVEL" - DEFINE MINIMUM API LEVEL REQUIRED
	AX = DE0Bh
	BL = API level minor version number
	BH = API level major version number
Return: AX = maximum API level (AH = major, AL = minor)
Notes:	if the requested API level is greater than the version of DESQview, a
	  "You need a newer version" error window is popped up
	the API level defaults to 1.00, and is inherited by child tasks
--------Q-15DE0C-----------------------------
INT 15 - DESQview v2.00+ - "GETMEM" - ALLOCATE "SYSTEM" MEMORY
	AX = DE0Ch
	BX = number of bytes
Return: ES:DI -> allocated block or 0000h:0000h (DV 2.26+)
Note:	use SETERROR (AX=DE15h) to avoid a user prompt if there is insufficient
	  system memory
SeeAlso: AX=1001h,AX=102Eh,AX=DE0Dh,AX=DE15h,AX=DE19h
--------Q-15DE0D-----------------------------
INT 15 - DESQview v2.00+ - "PUTMEM" - DEALLOCATE "SYSTEM" MEMORY
	AX = DE0Dh
	ES:DI -> previously allocated block
Return: nothing
SeeAlso: AX=1002h,AX=DE0Ch
--------Q-15DE0E-----------------------------
INT 15 - DESQview v2.00+ - "FINDMAIL" - FIND MAILBOX BY NAME
	AX = DE0Eh
	ES:DI -> name to find
	CX = length of name
Return: BX = 0000h not found
	     0001h found
		DS:SI = object handle
SeeAlso: AH=12h/BH=11h,AH=12h/BX=1200h"GETNAME"

Special mailbox names:
 "COM1" ... "COM4"	RBcomm using COM1 ... COM4
 "DESQview/X Help Engine"
 "DESQview/X Network Server"  Network Manager
 "DESQview X Server0"	X-Windows server
 "DESQview X Server7"	X-Windows printing service
 "INBOX"		DESQview/X LPD requests
 "OUTBOX"		DESQview/X LPD responses
 "WAITBOX"		semaphore to synchronize DESQview/X LPD communications
 "_DVNM_"		DV/X v1.10 network manager
--------Q-15DE0F-----------------------------
INT 15 - DESQview v2.00+ - ENABLE DESQview EXTENSIONS
	AX = DE0Fh
Return: AX and BX destroyed (seems to be bug, weren't saved&restored)
Notes:	sends a manager stream with opcodes AEh, BDh, and BFh to task's window
	enables an additional mouse mode
--------Q-15DE10-----------------------------
INT 15 - DESQview v2.00+ - "PUSHKEY" - PUT KEY INTO KEYBOARD INPUT STREAM
	AX = DE10h
	BH = scan code
	BL = character
Return: nothing
Notes:	a later read will get the keystroke as if it had been typed by the user
	multiple pushes are read last-in first-out
	if a script exists for the pushed key in the current application, the
	  script will be executed
	early copies of DV 2.00 destroy AX, BX, ES, and DI
SeeAlso: INT 16/AH=05h
--------Q-15DE11BL00-------------------------
INT 15 - DESQview v2.00+ - "JUSTIFY" - EN/DISABLE AUTOM. WINDOW JUSTIFICATION
	AX = DE11h
	BL = 00h      viewport will not move automatically
	     nonzero  viewport will move to keep cursor visible (default)
Return: nothing
--------Q-15DE12BX0000-----------------------
INT 15 - DESQview v2.01+ - "CSTYLE" - SET "C"-COMPATIBLE CONTROL CHAR INTERPRET
	AX = DE12h
	BX = 0000h    select normal style (linefeed only moves down)
	     nonzero  select C style (linefeed moves to start of next line)
Return: nothing
Note:	set on a per-task basis, and inherited from the parent task
--------Q-15DE13-----------------------------
INT 15 - DESQview v2.20+ - "GETCRIT" - GET CRITICAL NESTING COUNT
	AX = DE13h
Return: BX = number of calls to BEGINC or ENTERC (see INT 15/AX=101Bh,DE1Ch)
	     without matching ENDC (see INT 15/AX=101Ch)
Note:	this API call may be made from within a hardware interrupt handler
SeeAlso: AX=101Bh,AX=101Ch,AX=DE1Bh,AX=DE1Ch
--------Q-15DE14-----------------------------
INT 15 - DESQview v2.20+ - GET OBJECT TYPE
	AX = DE14h
	ES:DI -> object
Return: BL = 00h not an object
	     08h window or task
	     09h mailbox
	     0Ah keyboard
	     0Bh timer
	     0Ch objectq
	     0Fh pointer
	     10h panel
SeeAlso: AX=1016h
--------Q-15DE15-----------------------------
INT 15 - DESQview v2.20+ - SET ERROR HANDLING
	AX = DE15h
	BL = error handling mode
	    00h post system error on all error conditions
	    01h return carry flag set on calls to ADDTO, SUBFROM, and WRITE
		messages sent to mailboxes which fail due to lack of system
		or common memory
	    02h (v2.26+) same as 01h, but also return null pointer for GETMEM
		calls which fail due to lack of system memory
Return: nothing
SeeAlso: AX=DE0Ch,AX=DE16h
--------Q-15DE16-----------------------------
INT 15 - DESQview v2.20+ - GET ERROR HANDLING
	AX = DE16h
Return: BL = current mode
	    00h always post system error
	    01h return carry flag set on failed mailbox writes
	    02h return CF set on failed mailbox writes and NULL on failed
		GETMEM calls
SeeAlso: AX=DE15h
--------Q-15DE17-----------------------------
INT 15 - DESQview v2.20-2.25 - reserved
	AX = DE17h
Return: pops up "Programming error" window
Note:	AX = 1117h is NOT identical to this call under DESQview 2.20 thru 2.25
SeeAlso: AX=1117h
--------Q-15DE17-----------------------------
INT 15 - DESQview v2.26+ - "ASSERTMAP" - GET/SET MAPPING CONTEXT
	AX = DE17h
	BX = function
	    0000h   get current mapping context without setting
	    nonzero set new mapping context to BX
Return: BX = mapping context in effect before call
Notes:	mapping contexts determine conventional-memory addressability; setting
	  a mapping context ensures that the associated program and data areas
	  are in memory for access.  Usable by drivers, TSRs and shared
	  programs.
	caller need not be running under DESQview
	this API call may be made from a hardware interrupt handler
SeeAlso: AX=1016h,AX=1117h,AX=DE21h,INT 2F/AX=1685h
--------Q-15DE18-----------------------------
INT 15 - DESQview v2.20+ - internal - ???
	AX = DE18h
	BP = function number
	    high byte must be 10h
	    low byte is function
		00h set ???
		    BL = ???  (00h-10h, video mode???)
		    BH = value to store
		03h set ???
		    BL = ??? (stored in driver)
		0Ah get ???
		    ES:DI -> 18-byte buffer to hold ???
Note:	calls video driver (NOP for Hercules driver,probably CGA and MCGA also)
--------Q-15DE19-----------------------------
INT 15 - DESQview v2.23+ - "GETCOMMON" - ALLOCATE "COMMON" MEMORY
	AX = DE19h
	BX = number of bytes to allocate
Return: AX = 0000h successful
		ES:DI -> allocated block
	     nonzero insufficient memory
Note:	this API call may be made from within a hardware interrupt handler
SeeAlso: AX=DE0Ch,AX=DE15h,AX=DE1Ah
--------Q-15DE1A-----------------------------
INT 15 - DESQview v2.23+ - "PUTCOMMON" - DEALLOCATE "COMMON" MEMORY
	AX = DE1Ah
	ES:DI -> previously allocated block
Return:	AX = 0000h (successful)
Note:	this function may be called from within a hardware interrupt handler
SeeAlso: AX=DE0Dh,AX=DE19h
--------Q-15DE1B-----------------------------
INT 15 - DESQview v2.23+ internal - DECREMENT CRITICAL NESTING COUNT
	AX = DE1Bh
Return: nothing
SeeAlso: AX=101Ch,AX=DE13h,AX=DE1Ch
--------Q-15DE1C-----------------------------
INT 15 - DESQview v2.23+ - "ENTERC" - INCREMENT CRITICAL NESTING COUNT
	AX = DE1Ch
Return: nothing
Notes:	similar to AX=101Bh, but begins the critical region without ensuring
	  that DOS is free
	the official documentation states that this call should be paired with
	  "ENDC" (AX=101Ch); no mention is made of AX=DE1Bh
	this API call may be made from within a hardware interrupt handler
SeeAlso: AX=101Bh,AX=101Ch,AX=DE13h,AX=DE1Bh
--------Q-15DE1D-----------------------------
INT 15 - DESQview v2.23+ - "PUTKEY" - FAKE USER KEYSTROKES
	AX = DE1Dh
	DX = segment of handle for task to receive keystroke
	BL = character
	BH = scan code
Return: AX = 0000h if successful
	   nonzero if receiver's keyboard buffer was full
Notes:	the key is treated as though the user had pressed it, ignoring any
	  script which may be bound to the key, and using the current field
	  table if the keyboard object is in field processing mode
	multiple PUTKEYs are seen in the order in which they are executed
SeeAlso: AX=DE10h
--------Q-15DE1E-----------------------------
INT 15 - DESQview v2.23+ - "SCRNINFO" - GET TRUE VIDEO PARAMETERS
	AX = DE1Eh
Return: CL = actual number of rows on screen
	CH = actual number of columns on screen
	BL = actual video mode (may differ from INT 10/AH=0Fh return) (v2.26+)
Note:	this API call may be made from a hardware interrupt handler
SeeAlso: INT 10/AH=0Fh
--------Q-15DE1F-----------------------------
INT 15 - DESQview v2.23+ - "DOSUSER" - GET HANDLE OF TASK CURRENTLY USING DOS
	AX = DE1Fh
Return: BX = segment of task handle or 0000h if no tasks are using DOS
Note:	this API call may be made from within a hardware interrupt handler
SeeAlso: AX=DE13h,INT 21/AH=34h
--------Q-15DE20-----------------------------
INT 15 - DESQview v2.26+ - "DISPATCHINT" - INTERRUPT ANOTHER TASK
	AX = DE20h
	BX = segment of handle of task to interupt
	DX:CX -> FAR interrupt routine
	BP,SI,DI,DS,ES as required by interrupt routine
Return: nothing
Notes:	unlike "PGMINT" (AX=1021h), DISPATCHINT may be applied to the task
	  making the DISPATCHINT call
	multiple "DISPATCHINT" calls are processed in the order in which they
	  were executed
	the FAR routine is entered with the current ES, DS, SI, DI, and BP
	  values, using the task's internal stack (see AX=101Ah); only SS:SP
	  needs to be preserved
	this API call may be made from within a hardware interrupt handler
SeeAlso: AX=1021h,AX=DE2Ah
--------Q-15DE21-----------------------------
INT 15 - DESQview v2.26+ - "ASSERTVIR" - CONTROL 386 SCREEN VIRTUALIZATION
	AX = DE21h
	BX = new state
	    0000h turn off
	    nonzero turn on
Return: BX = old state of virtualization
Notes:	this API call may be made from within a hardware interrupt handler
	under DV 2.40 and 2.42, this call appears to have no effect and always
	  returns a nonzero value in BX which appears to be the offset within
	  the DV common memory segment of the caller's task object; it may
	  only have an effect within a hardware interrupt handler
SeeAlso: AX=1117h,AX=DE17h
--------Q-15DE22-----------------------------
INT 15 - DESQview v2.26+ - "PROCESSMEM" - GET TASK MEMORY STATUS
	AX = DE22h
	DX = segment of task handle
Return: DX = total amount of memory in paragraphs
	BX = amount of system memory in paragraphs
	CX = largest block of system memory available in paragraphs
	AX = flags
	    bit 0: system memory resides in shared memory
	    bit 1: process's memory is swapped out
	    bit 2: process's system memory is swapped out
Notes:	if the task handle is a child task, the returned values will be for the
	  process containing the task, rather than the task itself
	if the process's system memory is swapped out, BX,CX,DX remain
	  unchanged, because the memory usage cannot be determined
SeeAlso: AX=DE04h,AX=DE05h,AX=DE06h
--------Q-15DE23-----------------------------
INT 15 U - DESQview v2.31+ - ???
	AX = DE23h
	BX = ??? IRQ number on first PIC?
	CX = ??? IRQ number on second PIC?
Return: ???
Note:	called by QEMM 6.00+
--------Q-15DE24-----------------------------
INT 15 - DESQview v2.40+ - "XNEWPROC" - START NEW APPLICATION
	AX = DE24h
	BX = length of .DVP data
	CX = length of ??? string
	DS:SI -> ??? string
	ES:DI -> .DVP data (see AX=102Ch)
Return: BX = segment of task handle??? or 0000h on error
Note:	this call is similar to AX=102Ch except that it can interpret the
	  extended DVP data
SeeAlso: AX=102Ch
--------Q-15DE25-----------------------------
INT 15 - DESQview v2.40+ - "GETDVPATH" - GET DESQview DIRECTORY
	AX = DE25h
	ES:DI -> 67-byte buffer for ASCIZ directory name
Return: ES:DI buffer filled with directory from which DESQview was started
BUG:	DV 2.42 does not place a terminating NUL at the end of the directory
	  name, so if the buffer is not cleared to zeros before the call,
	  there is no way to tell where the directory name ends.  This bug
	  has been fixed in DV 2.52 (DV/X 1.02)
SeeAlso: AX=DE2Eh,INT 21/AH=47h
--------Q-15DE26-----------------------------
INT 15 - DESQview v2.40+ - "GETFOREGROUND" - GET KEYBOARD FOCUS
	AX = DE26h
Return: BX = segment of handle for task with keyboard focus
Note:	under DESQview/X, the X server always has the keyboard focus unless a
	  "direct" window is active
SeeAlso: AX=DE2Fh,INT 2F/AX=DE0Ah
--------Q-15DE27-----------------------------
INT 15 - DESQview v2.50+ - "ADDINSTANCEDATA" - ADD PER-TASK SAVE/RESTORE AREA
	AX = DE27h
	BX = type
	    0000h process
	    0001h task
	ES:DI -> list of Instance Item Structures (see below)
Return: CF clear if successful
	    AX = ???
	    BX = ???
	CF set on error
	    AX = error code???
		0004h invalid BX value
Note:	DESQview 2.50-2.52 are distributed as part of DESQview/X v1.0x.
SeeAlso: INT 2F/AX=DE08h,INT 2F/AX=DE09h

Format of Instance Item Structure [one element of list]:
Offset	Size	Description
 00h	WORD	length of data area DESQview should save and restore on context
		switches (0000h = end of list)
 02h	DWORD	pointer to area to be saved/restored
--------Q-15DE28-----------------------------
INT 15 U - DESQview v2.50+ - ???
	AX = DE28h
	BX = segment of ??? or 0000h for default
	???
Return: ???
Note:	DESQview 2.50-2.52 are distributed as part of DESQview/X v1.0x.
SeeAlso: AX=DE2Ah
--------Q-15DE29BX0000-----------------------
INT 15 U - DESQview v2.50+ - ???
	AX = DE29h
	BX = 0000h
	???
Return: CF clear if successful
	    ???
	CF set on error
Note:	DESQview 2.50-2.52 are distributed as part of DESQview/X v1.0x.
--------Q-15DE29BX0001-----------------------
INT 15 U - DESQview v2.50+ - ???
	AX = DE29h
	BX = 0001h
	DX = segment of window handle
Return: CF clear if successful
	    AX = ???
	    DX = ???
	CF set on error
Note:	DESQview 2.50-2.52 are distributed as part of DESQview/X v1.0x.
--------Q-15DE29BX0002-----------------------
INT 15 U - DESQview v2.50+ - ???
	AX = DE29h
	BX = 0002h
	DX = segment of window handle
Return: CF clear if successful
	    AX = ???
	    DX = ???
	CF set on error
Note:	DESQview 2.50-2.52 are distributed as part of DESQview/X v1.0x.
--------Q-15DE29BX0003-----------------------
INT 15 U - DESQview v2.50+ - ???
	AX = DE29h
	BX = 0003h
	DX = segment of window handle
Return: CF clear if successful
	    ???
	CF set on error
Note:	DESQview 2.50-2.52 are distributed as part of DESQview/X v1.0x.
--------Q-15DE29BX0004-----------------------
INT 15 U - DESQview v2.50+ - GET DISPLAY NAME
	AX = DE29h
	BX = 0004h
	CX = size of buffer in bytes
	DX = segment of window handle
	ES:DI -> buffer for display name
Return: CF clear if successful
	    buffer filled with ASCIZ display name (truncated if necessary) or
	      null string if no display
	CF set on error
Notes:	DESQview 2.50-2.52 are distributed as part of DESQview/X v1.0x.
	the name ":0" refers to the local display
--------Q-15DE29BX0005-----------------------
INT 15 U - DESQview v2.50+ - ???
	AX = DE29h
	BX = 0005h
	???
Return: CF clear if successful
	    ???
	CF set on error
Note:	DESQview 2.50-2.52 are distributed as part of DESQview/X v1.0x.
--------Q-15DE2A-----------------------------
INT 15 - DESQview v2.50+ - "DISPATCHINTAFTERDOS" - INTERRUPT ANOTHER TASK
	AX = DE2Ah
	BX = segment of handle for task to interrupt or 0000h for caller
	DX:CX -> interrupt routine
	BP,SI,DI,DS,ES as required by interrupt routine
Return: nothing
Notes:	DESQview 2.50-2.52 are distributed as part of DESQview/X v1.0x.
	this call is the same as AX=DE20h except that it will delay
	  interrupting the specified task until after it has exited DOS
SeeAlso: AX=1021h,AX=DE20h
--------Q-15DE2B-----------------------------
INT 15 - DESQview v2.50+ - "OBJNEXT" - TRAVERSE OBJECT LIST
	AX = DE2Bh
	ES:DI -> starting object
		0000h:0000h for first object in list???
Return: AX = status
	    0000h successful
		ES:DI -> next object of same type (window/non-window)
	    0001h failed (ES:DI was not a valid handle)
Notes:	DESQview 2.50-2.52 are distributed as part of DESQview/X v1.0x.
	there are two separate lists, one for window/task objects and one
	  for all other objects
SeeAlso: AX=1016h,AX=DE2Ah,AX=DE2Ch
--------Q-15DE2C-----------------------------
INT 15 - DESQview v2.50+ - "WININFO" - GET WINDOW INFORMATION
	AX = DE2Ch
	DX = window information format version (0100h for DESQview 2.5x)
	BX = segment of window handle or 0000h for default
	ES:DI -> buffer for window information (see below)
Return: AX = status
	    0000h successful
Note:	DESQview 2.50-2.52 are distributed as part of DESQview/X v1.0x.
SeeAlso: AX=1000h,AX=1016h,AX=DE01h,AX=DE2Bh

Format of window information:
Offset	Size	Description
 00h	BYTE	task flag: 00h window, 01h task
 01h	BYTE	process number if owner task
		00h if non-owner task
 02h	WORD	segment of owner's handle, 0000h if orphaned
 04h	WORD	mapping context (see AX=1016h)
 06h	BYTE	task status (see below)
 07h	BYTE	unused
 08h	WORD	status bits (see below)
 0Ah	BYTE	01h if foreground-only window

Values for task status:
 00h	"Waiting" waiting for input
 01h	"Idle" keyboard poll limit reached
 03h	same as 01h
 04h	"Pausing" INT 15/AX=1000h pause called
 04h	DV/X direct: user did something to allow task switch
 05h	"ModeChg" video mode about to be changed
 06h	"ModeNtf" notify that video mode changed
 07h	"MoniCh" requested change to other monitor
 08h	"StartPgm" control relinquished to start new process
 09h	"MgrCan" made window manager CANCEL command
 0Ah	"Slicing" time slice expired
 0Bh	"Exit DOS" notify on DOS calls
 0Ch	"Enter DOS" process is re-entering DOS
 0Dh	"Terminate" INT 21/AH=4Ch or task freed
 0Eh	"BrkNxt" Control-Break pressed
 0Fh	"MgrCol" keyboard focus taken away
 10h	"PgmInt" interrupted by API call from another task
 11h	"BldOpen" call to INT 15/AX=DE01h

Bitfields for status bits:
 bit 0	DESQview process
 bit 1	process swapped out
 bit 2	process is resized direct window (suspended)
 bit 3	process suspended itself
 bit 4	user suspended process
 bit 5	process is being created
 bit 6	task is freeing another task
--------Q-15DE2D-----------------------------
INT 15 U - DESQview v2.50+ - GET/SET SOCKET HANDLER
	AX = DE2Dh
	CX = direction
	    FFFFh set socket handler
		DX:BX -> FAR function for socket interface
			must be of the format described under INT 63"DESQview"
	    other get socket handler
		Return: DX:BX -> socket handler
Notes:	DESQview 2.50-2.52 are distributed as part of DESQview/X v1.0x.
	the "set" subfunction is normally called only by SOCKET.DVR
SeeAlso: AX=DE2Eh,INT 63"DESQview"
--------Q-15DE2E-----------------------------
INT 15 U - DESQview v2.50+ - SOCKET API
	AX = DE2Eh
	DX:BX -> socket record or 0000h:0000h to create a new socket record
Return: CX = size of socket record in bytes
	DX:BX -> socket record which was used
Notes:	DESQview 2.50-2.52 are distributed as part of DESQview/X v1.0x.
	socket records are allocated from common memory
	for Unix compatibility, each socket and connection on a socket is
	  allocated a DOS file handle (referencing an SFT for NUL) which is
	  used on various calls to specify which of possibly multiple
	  connections is to be operated upon
SeeAlso: AX=DE2Dh,INT 61/AX=0001h"VINES",INT 63"DESQview"

Values for function number:
 0000h	initialize socket???
 0001h	"gethostname"
 0002h	"ioctl" check for input
 0003h	"sleep" delay for specified period
 0004h	"htons" convert word to network (big-endian) byte order
 0005h	"select"
 0006h	"bsd_close"/"so_close" close socket
 0007h	NOP
 0008h	"connect" initiate connection on socket
 0009h	"recv"/"recvfrom" read from socket
 000Ah	"socket"
 000Bh	???
 000Ch	"gethostbyname"
 000Dh	"send"/"sendto" write to socket
 000Eh	??? (does something to all connections for process)
 000Fh	"getpid" get process identifier
 0010h	"gettimeofday"
 0011h	"bind" assign name to socket
 0012h	"listen" listen for connections on socket
 0013h	"accept" accept connection on socket
 0014h	connect to X server
 0015h	"gethostbyaddr" get host information for an address
 0016h	"getprotobyname"
 0017h	"getprotobynumber"
 0018h	"getservbyname"
 0019h	"getservbyport"
 001Ah	"getsockname" determine name bound to socket
 001Bh	"getpeername" get name of connected peer
 001Ch	"getsockopt"/"setsockopt"
 001Dh	"so_exit"	 close all sockets for calling process
 001Eh	"issock" determine whether file handle references socket
 001Fh	"so_attach" reattach previously detached socket
 0020h	"so_detach" temporarily detach socket
 0021h	get DESQview directory
 0022h	"NewProc" start new application (see AX=102Ch)
 0023h	"so_linkup"
 0024h	canonicalize filename
 0025h	indirect INT 15h call
 0026h	Network Manager interface
 0027h	"so_unlink"    close connection from "so_linkup"
 0028h	"raisepriority"
 0029h	"lowerpriority"
 002Ah	???
 FFFFh	"NetExit" (appears to be a NOP)

Format of socket record:
Offset	Size	Description
 00h	WORD	signature F0ADh
 02h	WORD	function number (see above)
 04h	WORD	returned error code (see below)
 06h	WORD	maximum message size??? (usually 0400h)
 08h	WORD	PSP segment to use or 0000h if socket not valid
 0Ah	WORD	scratch space (JFT size)
 0Ch	DWORD	scratch space (JFT address)
 10h	DWORD	mailbox handle (initialized by function 0000h)
 14h	DWORD	timer object handle (initialized by function 0000h)
---function 0000h---
 18h	WORD	(return) ???
---function 0001h---
 18h	WORD	(return) status???
 1Ah 128 BYTEs	(return) ASCIZ hostname (empty string if not on network)
 9Ah	WORD	maximum length of hostname to return
---function 0002h---
 18h	WORD	(return) status
 1Ah	WORD	socket's file handle
 1Ch	WORD	IOCTL function
		05h "FIONREAD" determine available input
		06h "FIONBIO" set blocking state of socket
 1Eh	WORD	(return, subfn 05h) number of bytes available for reading
		(call, subfn 06h) 0000h blocking, nonzero nonblocking
---function 0003h---
 18h  2 BYTEs	unused
 1Ah	WORD	delay time in seconds
---function 0004h---
 18h	WORD	(return) result in network (big-endian) byte order
 1Ah	WORD	value to convert to network byte order
---function 0005h---
 18h	WORD	(return) number of handles meeting the specified conditions???
 1Ah	WORD	number of file handles in each bitset???
 1Ch	DWORD	bitset of socket handles to check for readability???
 20h	DWORD	bitset of socket handles to check for writability???
 24h	DWORD	bitset of socket handles to check for errors???
 28h	WORD	timeout in ??? or 0000h to block until some socket ready
 2Ah	DWORD	???
 2Eh	DWORD	???
---function 0006h---
 18h	WORD	(return) status: 0000h if successful, FFFFh on error
 1Ah	WORD	socket's file handle
---function 0008h---
 18h	WORD	(return) status: 0000h if successful, FFFFh on error
 1Ah	WORD	socket's file handle
 1Ch	WORD	0001h if socket name specified, 0000h if not
 1Eh	WORD	length of socket name
 20h  N BYTEs	name of socket to which to connect
---function 0009h---
 18h	WORD	(return) number of bytes actually read, 0000h if connection
			closed, or FFFFh on error
 1Ah	WORD	socket's file handle
 1Ch	WORD	number of bytes to read
 1Eh	WORD	flags
 20h	WORD	0000h if no source address desired
		0001h if source address is to be stored (datagram sockets)
 22h	WORD	length of source address
 24h 110 BYTEs	source address
 92h 1K BYTEs	buffer for data to be read
---function 000Ah---
 18h	WORD	(return) socket's file handle or FFFFh on error
 1Ah	WORD	address family (0001h,0002h)
 1Ch	WORD	socket type
 1Eh	WORD	protocol
---function 000Bh---
 18h	WORD	(return) 0001h if ??? or FFFFh on error
 1Ah	WORD	socket's file handle
 1Eh	WORD	(call) ???
---function 000Ch---
 18h 128 BYTEs	buffer containing ASCIZ hostname
		special case if empty string or "unix"
 98h	???	'struct hostent' ???
 A2h	???	(return) ???
---function 000Dh---
 18h	WORD	(return) number of bytes actually written or FFFFh on error
 1Ah	WORD	socket's file handle
 1Ch	WORD	number of bytes to write
 1Eh	WORD	number of bytes to follow in subsequent writes???
 20h	WORD	flags
 22h	WORD	0000h if no destination specified, 0001h if destination present
 24h	WORD	???
 26h	WORD	length of destination address
 28h 110 BYTEs	destination address
 96h 1K BYTEs	buffer containing data to be written
---function 000Eh---
 no additional fields
---function 000Fh---
 18h	DWORD	(return) DESQview task handle of calling process
---function 0010h---
 18h	DWORD	(return) current time
 1Ch	DWORD	(return) ???
---function 0011h---
 18h	WORD	(return) status: 0000h if successful, FFFFh on error
 1Ah	WORD	socket's file handle
 1Ch	WORD	length of name
 1Eh  N BYTEs	buffer for socket name
---function 0012h---
 18h	WORD	(return) status: 0000h if successful, FFFFh on error
 1Ah	WORD	socket's file handle
 1Ch	WORD	maximum backlog of pending connections allowed on socket
---function 0013h---
 18h	WORD	(return) file handle for new connection or FFFFh on error
 1Ah	WORD	listen()ing socket's file handle
 1Ch	WORD	(call) length of buffer for connecting entity's address
		(return) actual length of address
 1Eh  N BYTEs	buffer for connecting entity's address
---function 0014h---
 18h	WORD	(return) socket's file handle or FFFFh on error
 1Ah  4 BYTEs	(return) ???
 1Eh	WORD	(return) ???
 20h	WORD	(return) ???
 22h 256 BYTEs	ASCIZ X display name
122h	???
---function 0015h---
 18h	WORD	(call) type of address??? (test for 0001h seen)
 1Ah	WORD	(call) length of buffer for host address
 1Ch 110 BYTEs	buffer containing host address
 8Ah	WORD	(return) offset of official host name???
 8Ch	WORD	(return) offset of alias list???
 8Eh	WORD	(return) address type???
 90h	WORD	(return) length of an address in bytes???
 92h	WORD	(return) offset of address???
 9Ah  N BYTEs	(return) ??? buffer for hostname, alias list, and host address
---function 0016h---
 18h	???	buffer for protocol name???
 98h	???
---function 0017h---
 18h	WORD	(call) protocol number???
 1Ah	WORD	(return) ??? or 0001h
---function 0018h---
 18h 128 BYTEs	buffer containing ???
 98h 128 BYTEs	buffer containing ???
118h	WORD	(return) ???
---function 0019h---
 18h	WORD	length of name???
 1Ah 128 BYTEs	buffer for name???
 9Ah	WORD	(return) ???
---function 001Ah---
 18h	WORD	(return) 0000h if successful, FFFFh on error
 1Ah	WORD	socket's file handle
 1Ch	WORD	(call) length of buffer for socket name
		(return) actual length of socket name
 1Eh  N BYTEs	buffer for socket name
---function 001Bh---
 18h	WORD	(return) status: 0000h if successful, FFFFh on error
 1Ah	WORD	socket's file handle
 1Ch	WORD	(call) size of buffer for name
		(return) actual size of name
 1Eh  N BYTEs	buffer for peer's name
---function 001Ch---
 18h	WORD	(return) status: 0000h if successful, FFFFh on error
 1Ah	WORD	direction: 0000h to get, 0001h to set
 1Ch	WORD	socket's file handle
 1Eh	WORD	option level
 20h	WORD	option name
 22h	WORD	(call) length of buffer for option value
		(return) actual length of option value
 24h  N BYTEs	buffer for option value
---function 001Dh---
 no additional fields
---function 001Eh---
 18h	WORD	(return) status: 0000h ??? or 0001h ???
 1Ah	WORD	file handle which may or may not be a socket
---function 001Fh---
 18h	WORD	(return) file handle or FFFFh on error
 1Ah	DWORD	(call) pointer to Socket Context Record (see below) of a
			previously detached socket
---function 0020h---
 18h	WORD	(return) status: 0000h if successful or FFFFh on error
 1Ah	WORD	socket's file handle
 1Ch	DWORD	(return) pointer to Socket Context Record (see below) for
			the file handle
---function 0021h---
 18h 64 BYTEs	buffer for DESQview startup directory (see AX=DE25h)
---function 0022h---
 18h	DWORD	(return) task handle of new application
 1Ch	WORD	size of .DVP data
 1Eh 129 BYTEs	ASCIZ ???
 9Fh  N BYTEs	.DVP data (see AX=102Ch)
---function 0023h---
 18h	WORD	(return) ??? or FFFFh on error
 1Ah	WORD	socket's file handle???
---function 0024h---
 18h	WORD	(return) DOS error code (see INT 21/AH=59h)
			0000h if successful
 1Ah 129 BYTEs	ASCIZ filename/pathname
11Bh 129 BYTEs	ASCIZ canonicalized filename/pathname (see INT 21/AH=60h)
---function 0025h---
 18h	WORD	value of AX
 1Ah	WORD	value of BX
 1Ch	WORD	(call) value of CX for call if AH value other than 12h
		(call) number of stack parameters if AH value is 12h
		(return) returned CX for calls other than INT 15/AH=12h
 1Eh	WORD	value of DX
 20h	WORD	value of DI
 22h	WORD	value of SI
 24h	WORD	value of DS
 26h	WORD	value of ES
 28h	WORD	(return) value of FLAGS after call
 2Ah  N DWORDs	(call) stack parameters for INT 15/AH=12h call
		(return) stack results from INT 15/AH=12h call
---function 0026h---
 18h	WORD	(call) Network Manager subfunction (see below)
		(return) status???
 1Ah	WORD	(call) size of parameter data
		(return) size of returned data
 1Ch  N BYTEs	(call) parameter data required by call (see below)
		(return) result data (see below)
---function 0027h---
 18h	WORD	(return) status: 0000h if successful, FFFFh on error
 1Ah	WORD	socket's file handle
---functions 0028h,0029h---
 18h	WORD	(call) file handle for which to set priority low/high
			FFFFh to change calling task's priority
---function 002Ah---
 no additional fields

Values for Network Manager subfunction:
 0004h	"so_exit"???
 0005h	"gethostbyname"
 0006h	"gethostname"
 0009h	"socket"
 000Dh	"gethostbyaddr"
 000Fh	"getprotobyname"
 0010h	get protocol name for protocol number
 0011h	"getservbyname"
 0012h	"getservbyport"
 0013h	"getsockname"???
 0016h	???
 0017h	kill Network Manager
 0018h	"getpeername"???
 0019h	??? (called by socket function 0000h)
 001Ah	???
 001Bh	"so_linkup"
 001Dh	get network services
 001Fh	"getpwuid"
 0020h	"getpwnam"
 0021h	"getpwvar"
 0022h	"crypt"
 0023h	"so_unlink"
 0024h	"getlogin"
 0028h	"sethostent"
 0029h	"gethostent"
 002Ah	"soaddhost"
 002Bh	"soupdatehost"
 002Ch	"sodeletehost"
 002Dh	"setservent"
 002Eh	"getservent"
 002Fh	"setpwent"
 0030h	"getpwent"
 0031h	???
 0032h	???
 0033h	???
 0034h	get IP network number
 0035h	??? (pops up Network Manager window)
 0037h	???
 0038h	get machine name and IP address
 0039h	???

Format of Function 0026h/Subfunction 000Fh data:
Offset	Size	Description
 00h  8 BYTEs	(return) ???

Format of Function 0026h/Subfunction 0010h data:
Offset	Size	Description
 00h  2 BYTEs	(return) ???
 02h	WORD	(return) protocol number
 04h	WORD	(call) protocol number for which to get name
 06h	WORD	(return) ???
 08h	var	(return) ASCIZ protocol name
 N	var	(return) ASCIZ protocol name

Format of Function 0026h/Subfunction 0011h data:
Offset	Size	Description
 00h  8 BYTEs	???
 08h	var	(return) ASCIZ protocol name
	var	(return) ASCIZ ??? name
	var	(return) ASCIZ ??? name

Format of Function 0026h/Subfunction 0012h data:
Offset	Size	Description
 00h  8 BYTEs	(return) ???

Format of Function 0026h/Subfunction 0013h data:
Offset	Size	Description
 00h 116 BYTEs	(return) ???

Format of Function 0026h/Subfunction 0016h data:
Offset	Size	Description
 00h  4 BYTEs	(return) ???

Format of Function 0026h/Subfunction 0018h data:
Offset	Size	Description
 00h 116 BYTEs	(return) ???

Format of Function 0026h/Subfunction 0019h data:
Offset	Size	Description
 00h  4 BYTEs	(return) ???
 04h	DWORD	(return) task handle of ???

Format of Function 0026h/Subfunction 001Ah data:
Offset	Size	Description
 00h 38 BYTEs	(return) ???

Format of Function 0026h/Subfunction 001Bh data:
Offset	Size	Description
 00h 10 BYTEs	(return) ???

Format of Function 0026h/Subfunction 001Dh return data [array]:
Offset	Size	Description
 00h	WORD	??? or FFFFh if end of array
 02h  7 BYTEs	???
 09h 27 BYTEs	ASCIZ name of service

Format of Function 0026h/Subfunction 0024h return data:
Offset	Size	Description
 00h	var	ASCIZ username

Format of Function 0026h/Subfunction 0030h data:
Offset	Size	Description
 00h	WORD	(call) UID or 0000h for current user
		(return) ???
 02h	WORD	(return) UID
 04h  6 BYTEs	(return) ???
 0Ah	var	(return) ASCIZ username
	var	(return) ASCIZ encrypted password
	var	(return) ASCIZ initial ("home") directory

Format of Function 0026h/Subfunction 0034h data:
Offset	Size	Description
 00h  1-3 BYTEs IP network number of caller's machine (low byte first)

Format of Function 0026h/Subfunction 0038h return data:
Offset	Size	Description
 00h	BYTE	???
 01h  4 BYTEs	IP address
 05h	var	ASCIZ machine name
	???

Values for error code:
 0000h	successful
 0009h	"BADF" bad file handle
 000Ch	"ENOMEM" out of memory
 000Eh	"EFAULT" bad address
 0016h	"EINVAL" invalid argument
 0018h	"EMFILE" too many open files
 0020h	"EPIPE" ??? broken pipe
 0023h	"EWOULDBLOCK" operation cannot be completed at this time
 0024h	"EINPROGRESS" operation now in progress
 0026h	"ENOTSOCK" socket invalid
 0028h	"EMSGSIZE" message too long to send atomically
 002Ch	"ESOCKTNOSUPPORT" socket type not supported
 002Fh	"EAFNOSUPPORT" address family not supp. by protocol fam.
 0031h	"EDOM" argument too large
 0038h	"EISCONN" socket is already connected
 0039h	"ENOTCONN" socket is not connected

Format of Socket Context Record:
Offset	Size	Description
 00h	DWORD	pointer to next Socket Context Record, 0000h:0000h if last
 04h	WORD	SFT index for socket, 00FFh if not connected, FFFFh if detached
 06h	WORD	PSP segment of owner or 0000h
 08h	WORD	mapping context of owning window (see AX=1016h)
 0Ah  2 BYTEs	???
 0Ch	WORD	address family
 0Eh	WORD	socket type
 10h	WORD	protocol
 12h	WORD	socket state
		0001h created
		0002h bound
		0003h listening???
		0005h connected
 14h	DWORD	timer object handle
 18h	DWORD	object handle (mailbox???)
 1Ch	DWORD	object handle of parent of above object or 0000h:0000h
 20h	DWORD	pointer to ??? or 0000h
 24h  6 BYTEs	???
 2Ah	WORD	file handle for socket or FFFFh
 2Ch  2 BYTEs	???
 2Eh	WORD	nonzero if socket nonblocking
---network connections only---
 30h  2 BYTEs	???
 32h	WORD	???
 34h  4 BYTEs	(big-endian) IP address of remote
 38h  6 BYTEs	???
--------Q-15DE2F-----------------------------
INT 15 - DESQview v2.50+ - "VIDEONOTIFY" - HAS DIRECT WINDOW BEEN ACTIVE?
	AX = DE2Fh
Return: BX = status
	    0001h keyboard focus has been given to a direct window since the
		last call
	    0000h if not
Notes:	DESQview 2.50-2.52 are distributed as part of DESQview/X v1.0x.
	Quarterdeck states that this call will not be available under future
	  versions of DESQview Classic
--------Q-15DE30-----------------------------
INT 15 - DESQview v2.50+ - "GETDVXVERSION" - GET DESQview/X VERSION
	AX = DE30h
Return: BX = version (BH=major, BL=minor) or 0000h if not DESQview/X
Notes:	DESQview 2.50-2.52 are distributed as part of DESQview/X v1.0x.
	you must first check the DESQview version to verify that it is 2.50 or
	  greater
SeeAlso: INT 21/AH=2Bh/CX=4445h
--------Q-15DE31-----------------------------
INT 15 - DESQview/X v1.10 - ???
	AX = DE31h
	CX = ???
	    0000h ???
	    nonzero ???
	???
Return: ???
--------b-15E00F-----------------------------
INT 15 - Compaq Systempro - MULTIPROCESSOR DISPATCH
	AX = E00Fh
	ES:BX -> start of 2nd processor's execution
Return: AL = 0Fh successful
	   = 00h failure
SeeAlso: AX=E10Eh,AX=E200h
--------b-15E10E-----------------------------
INT 15 - Compaq Systempro - MULTIPROCESSOR END-OF-DISPATCH
	AX = E10Eh
	ES:BX -> start of 2nd processor's execution
Return: AL = 0Fh successful (halted)
	   = 00h failure (not halted)
SeeAlso: AX=E00Fh,AX=E200h
--------b-15E200-----------------------------
INT 15 - Compaq Systempro - MULTIPROCESSOR AVAILABLE
	AX = E200h
Return: AX = 8000h if 2nd processor available
SeeAlso: AX=E00Fh,AX=E10Eh
----------15E4-------------------------------
INT 15 - Tandy??? - ???
	AH = E4h
	AL = subfunction
	    21h, 89h, 8Ah, 8Bh called by 386MAX v6.01
	DL = ???
Return: DL = 00h if successful???
Note:	the section of code in 386MAX which calls these functions also checks
	  whether the ROM BIOS has both Tandy and Phoenix Technologies
	  signatures if these calls fail
--------m-15F200CX454D-----------------------
INT 15 - Tandon memory mapper - Tandon MAPPER HARDWARE INITIALISATION CHECK ???
	AX = F200h
	CX = 454Dh
Return: CF clear if hardware already initialised
	    BX = upper RAM areas in use
		bit 0: C000-C3FF
		bit 1: C400-C7FF
		...
		bit 11: EC00-EFFF
	CF set if hardware not initialised yet
--------!------------------------------------
